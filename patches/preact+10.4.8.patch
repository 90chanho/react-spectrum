diff --git a/node_modules/preact/.DS_Store b/node_modules/preact/.DS_Store
new file mode 100644
index 0000000..5008ddf
Binary files /dev/null and b/node_modules/preact/.DS_Store differ
diff --git a/node_modules/preact/compat/dist/compat.js b/node_modules/preact/compat/dist/compat.js
index b2f8d44..e596e65 100644
--- a/node_modules/preact/compat/dist/compat.js
+++ b/node_modules/preact/compat/dist/compat.js
@@ -1,2 +1,2 @@
-var n=require("preact/hooks"),t=require("preact");function e(n,t){for(var e in t)n[e]=t[e];return n}function r(n,t){for(var e in n)if("__source"!==e&&!(e in t))return!0;for(var r in t)if("__source"!==r&&n[r]!==t[r])return!0;return!1}function o(n){this.props=n}function u(n,e){function o(n){var t=this.props.ref,o=t==n.ref;return!o&&t&&(t.call?t(null):t.current=null),e?!e(this.props,n)||!o:r(this.props,n)}function u(e){return this.shouldComponentUpdate=o,t.createElement(n,e)}return u.displayName="Memo("+(n.displayName||n.name)+")",u.prototype.isReactComponent=!0,u.__f=!0,u}(o.prototype=new t.Component).isPureReactComponent=!0,o.prototype.shouldComponentUpdate=function(n,t){return r(this.props,n)||r(this.state,t)};var i=t.options.__b;t.options.__b=function(n){n.type&&n.type.__f&&n.ref&&(n.props.ref=n.ref,n.ref=null),i&&i(n)};var f="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.forward_ref")||3911;function c(n){function t(t,r){var o=e({},t);return delete o.ref,n(o,(r=t.ref||r)&&("object"!=typeof r||"current"in r)?r:null)}return t.$$typeof=f,t.render=t,t.prototype.isReactComponent=t.__f=!0,t.displayName="ForwardRef("+(n.displayName||n.name)+")",t}var l=function(n,e){return n?t.toChildArray(t.toChildArray(n).map(e)):null},a={map:l,forEach:l,count:function(n){return n?t.toChildArray(n).length:0},only:function(n){var e=t.toChildArray(n);if(1!==e.length)throw"Children.only";return e[0]},toArray:t.toChildArray},s=t.options.__e;function p(n){return n&&((n=e({},n)).__c=null,n.__k=n.__k&&n.__k.map(p)),n}function v(n){return n&&(n.__v=null,n.__k=n.__k&&n.__k.map(v)),n}function h(){this.__u=0,this.t=null,this.__b=null}function d(n){var t=n.__.__c;return t&&t.o&&t.o(n)}function x(n){var e,r,o;function u(u){if(e||(e=n()).then(function(n){r=n.default||n},function(n){o=n}),o)throw o;if(!r)throw e;return t.createElement(r,u)}return u.displayName="Lazy",u.__f=!0,u}function m(){this.u=null,this.i=null}t.options.__e=function(n,t,e){if(n.then)for(var r,o=t;o=o.__;)if((r=o.__c)&&r.__c)return null==t.__e&&(t.__e=e.__e,t.__k=e.__k),r.__c(n,t.__c);s(n,t,e)},(h.prototype=new t.Component).__c=function(n,t){var e=this;null==e.t&&(e.t=[]),e.t.push(t);var r=d(e.__v),o=!1,u=function(){o||(o=!0,t.componentWillUnmount=t.__c,r?r(i):i())};t.__c=t.componentWillUnmount,t.componentWillUnmount=function(){u(),t.__c&&t.__c()};var i=function(){var n;if(!--e.__u)for(e.__v.__k[0]=v(e.state.o),e.setState({o:e.__b=null});n=e.t.pop();)n.forceUpdate()};e.__u++||e.setState({o:e.__b=e.__v.__k[0]}),n.then(u,u)},h.prototype.componentWillUnmount=function(){this.t=[]},h.prototype.render=function(n,e){return this.__b&&(this.__v.__k&&(this.__v.__k[0]=p(this.__b)),this.__b=null),[t.createElement(t.Fragment,null,e.o?null:n.children),e.o&&n.fallback]};var _=function(n,t,e){if(++e[1]===e[0]&&n.i.delete(t),n.props.revealOrder&&("t"!==n.props.revealOrder[0]||!n.i.size))for(e=n.u;e;){for(;e.length>3;)e.pop()();if(e[1]<e[0])break;n.u=e=e[2]}};function y(n){return this.getChildContext=function(){return n.context},n.children}function b(n){var e=this,r=n.l,o=t.createElement(y,{context:e.context},n.__v);e.componentWillUnmount=function(){var n=e.s.parentNode;n&&n.removeChild(e.s),t.__u(e.p)},e.l&&e.l!==r&&(e.componentWillUnmount(),e.v=!1),n.__v?e.v?(r.__k=e.__k,t.render(o,r),e.__k=r.__k):(e.s=document.createTextNode(""),e.__k=r.__k,t.hydrate("",r),r.appendChild(e.s),e.v=!0,e.l=r,t.render(o,r,e.s),r.__k=e.__k,e.__k=e.s.__k):e.v&&e.componentWillUnmount(),e.p=o}function S(n,e){return t.createElement(b,{__v:n,l:e})}(m.prototype=new t.Component).o=function(n){var t=this,e=d(t.__v),r=t.i.get(n);return r[0]++,function(o){var u=function(){t.props.revealOrder?(r.push(o),_(t,n,r)):o()};e?e(u):u()}},m.prototype.render=function(n){this.u=null,this.i=new Map;var e=t.toChildArray(n.children);n.revealOrder&&"b"===n.revealOrder[0]&&e.reverse();for(var r=e.length;r--;)this.i.set(e[r],this.u=[1,0,this.u]);return n.children},m.prototype.componentDidUpdate=m.prototype.componentDidMount=function(){var n=this;this.i.forEach(function(t,e){_(n,e,t)})};var E=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;t.Component.prototype.isReactComponent={};var w="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103;function C(n,e,r){if(null==e.__k)for(;e.firstChild;)e.removeChild(e.firstChild);return t.render(n,e),"function"==typeof r&&r(),n?n.__c:null}function R(n,e,r){return t.hydrate(n,e),"function"==typeof r&&r(),n?n.__c:null}var g=t.options.event;function A(n,t){n["UNSAFE_"+t]&&!n[t]&&Object.defineProperty(n,t,{get:function(){return this["UNSAFE_"+t]},set:function(n){this["UNSAFE_"+t]=n}})}t.options.event=function(n){g&&(n=g(n)),n.persist=function(){};var t=!1,e=!1,r=n.stopPropagation;n.stopPropagation=function(){r.call(n),t=!0};var o=n.preventDefault;return n.preventDefault=function(){o.call(n),e=!0},n.isPropagationStopped=function(){return t},n.isDefaultPrevented=function(){return e},n.nativeEvent=n};var N,U={configurable:!0,get:function(){return this.class}},O=t.options.vnode;t.options.vnode=function(n){n.$$typeof=w;var e=n.type,r=n.props;if(e){var o;if(r.class!=r.className&&(U.enumerable="className"in r,null!=r.className&&(r.class=r.className),Object.defineProperty(r,"className",U)),"function"!=typeof e)for(o in r.defaultValue&&void 0!==r.value&&(r.value||0===r.value||(r.value=r.defaultValue),r.defaultValue=void 0),"select"===e&&r.multiple&&Array.isArray(r.value)&&(t.toChildArray(r.children).forEach(function(n){-1!=r.value.indexOf(n.props.value)&&(n.props.selected=!0)}),r.value=void 0),!0===r.download&&(r.download=""),r){var u=E.test(o);u&&(n.props[o.replace(/[A-Z0-9]/,"-$&").toLowerCase()]=r[o]),(u||null===r[o])&&(r[o]=void 0)}else e.prototype&&!e.prototype.h&&(e.prototype.h=!0,A(e.prototype,"componentWillMount"),A(e.prototype,"componentWillReceiveProps"),A(e.prototype,"componentWillUpdate"));!function(t){var e=n.type,r=n.props;if(r&&"string"==typeof e){var o={};for(var u in r)/^on(Ani|Tra|Tou)/.test(u)&&(r[u.toLowerCase()]=r[u],delete r[u]),o[u.toLowerCase()]=u;if(o.ondoubleclick&&(r.ondblclick=r[o.ondoubleclick],delete r[o.ondoubleclick]),o.onbeforeinput&&(r.onbeforeinput=r[o.onbeforeinput],delete r[o.onbeforeinput]),o.onchange&&("textarea"===e||"input"===e.toLowerCase()&&!/^fil|che|ra/i.test(r.type))){var i=o.oninput||"oninput";r[i]||(r[i]=r[o.onchange],delete r[o.onchange])}}}()}O&&O(n)};var F=t.options.__r;t.options.__r=function(n){F&&F(n),N=n.__c};var L={ReactCurrentDispatcher:{current:{readContext:function(n){return N.__n[n.__c].props.value}}}};function k(n){return t.createElement.bind(null,n)}function M(n){return!!n&&n.$$typeof===w}function D(n){return M(n)?t.cloneElement.apply(null,arguments):n}function T(n){return!!n.__k&&(t.render(null,n),!0)}function W(n){return n&&(n.base||1===n.nodeType&&n)||null}var j=function(n,t){return n(t)},I=t.Fragment,P={useState:n.useState,useReducer:n.useReducer,useEffect:n.useEffect,useLayoutEffect:n.useLayoutEffect,useRef:n.useRef,useImperativeHandle:n.useImperativeHandle,useMemo:n.useMemo,useCallback:n.useCallback,useContext:n.useContext,useDebugValue:n.useDebugValue,version:"16.8.0",Children:a,render:C,hydrate:R,unmountComponentAtNode:T,createPortal:S,createElement:t.createElement,createContext:t.createContext,createFactory:k,cloneElement:D,createRef:t.createRef,Fragment:t.Fragment,isValidElement:M,findDOMNode:W,Component:t.Component,PureComponent:o,memo:u,forwardRef:c,unstable_batchedUpdates:j,StrictMode:I,Suspense:h,SuspenseList:m,lazy:x,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:L};Object.keys(n).forEach(function(t){exports[t]=n[t]}),exports.createElement=t.createElement,exports.createContext=t.createContext,exports.createRef=t.createRef,exports.Fragment=t.Fragment,exports.Component=t.Component,exports.version="16.8.0",exports.Children=a,exports.render=C,exports.hydrate=R,exports.unmountComponentAtNode=T,exports.createPortal=S,exports.createFactory=k,exports.cloneElement=D,exports.isValidElement=M,exports.findDOMNode=W,exports.PureComponent=o,exports.memo=u,exports.forwardRef=c,exports.unstable_batchedUpdates=j,exports.StrictMode=I,exports.Suspense=h,exports.SuspenseList=m,exports.lazy=x,exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=L,exports.default=P;
+var n=require("preact/hooks"),t=require("preact");function e(n,t){for(var e in t)n[e]=t[e];return n}function r(n,t){for(var e in n)if("__source"!==e&&!(e in t))return!0;for(var r in t)if("__source"!==r&&n[r]!==t[r])return!0;return!1}function o(n){this.props=n}function u(n,e){function o(n){var t=this.props.ref,o=t==n.ref;return!o&&t&&(t.call?t(null):t.current=null),e?!e(this.props,n)||!o:r(this.props,n)}function u(e){return this.shouldComponentUpdate=o,t.createElement(n,e)}return u.displayName="Memo("+(n.displayName||n.name)+")",u.prototype.isReactComponent=!0,u.__f=!0,u}(o.prototype=new t.Component).isPureReactComponent=!0,o.prototype.shouldComponentUpdate=function(n,t){return r(this.props,n)||r(this.state,t)};var i=t.options.__b;t.options.__b=function(n){n.type&&n.type.__f&&n.ref&&(n.props.ref=n.ref,n.ref=null),i&&i(n)};var c="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.forward_ref")||3911;function f(n){function t(t,r){var o=e({},t);return delete o.ref,n(o,(r=t.ref||r)&&("object"!=typeof r||"current"in r)?r:null)}return t.$$typeof=c,t.render=t,t.prototype.isReactComponent=t.__f=!0,t.displayName="ForwardRef("+(n.displayName||n.name)+")",t}var l=function(n,e){return null==n?null:t.toChildArray(t.toChildArray(n).map(e))},a={map:l,forEach:l,count:function(n){return n?t.toChildArray(n).length:0},only:function(n){var e=t.toChildArray(n);if(1!==e.length)throw"Children.only";return e[0]},toArray:t.toChildArray},s=t.options.__e;function p(n){return n&&((n=e({},n)).__c=null,n.__k=n.__k&&n.__k.map(p)),n}function h(n){return n&&(n.__v=null,n.__k=n.__k&&n.__k.map(h)),n}function v(){this.__u=0,this.t=null,this.__b=null}function d(n){var t=n.__.__c;return t&&t.o&&t.o(n)}function x(n){var e,r,o;function u(u){if(e||(e=n()).then(function(n){r=n.default||n},function(n){o=n}),o)throw o;if(!r)throw e;return t.createElement(r,u)}return u.displayName="Lazy",u.__f=!0,u}function m(){this.u=null,this.i=null}t.options.__e=function(n,t,e){if(n.then)for(var r,o=t;o=o.__;)if((r=o.__c)&&r.__c)return null==t.__e&&(t.__e=e.__e,t.__k=e.__k),r.__c(n,t.__c);s(n,t,e)},(v.prototype=new t.Component).__c=function(n,t){var e=this;null==e.t&&(e.t=[]),e.t.push(t);var r=d(e.__v),o=!1,u=function(){o||(o=!0,t.componentWillUnmount=t.__c,r?r(i):i())};t.__c=t.componentWillUnmount,t.componentWillUnmount=function(){u(),t.__c&&t.__c()};var i=function(){var n;if(!--e.__u)for(e.__v.__k[0]=h(e.state.o),e.setState({o:e.__b=null});n=e.t.pop();)n.forceUpdate()};e.__u++||e.setState({o:e.__b=e.__v.__k[0]}),n.then(u,u)},v.prototype.componentWillUnmount=function(){this.t=[]},v.prototype.render=function(n,e){return this.__b&&(this.__v.__k&&(this.__v.__k[0]=p(this.__b)),this.__b=null),[t.createElement(t.Fragment,null,e.o?null:n.children),e.o&&n.fallback]};var b=function(n,t,e){if(++e[1]===e[0]&&n.i.delete(t),n.props.revealOrder&&("t"!==n.props.revealOrder[0]||!n.i.size))for(e=n.u;e;){for(;e.length>3;)e.pop()();if(e[1]<e[0])break;n.u=e=e[2]}};function y(n){return this.getChildContext=function(){return n.context},n.children}function _(n){var e=this,r=n.l,o=t.createElement(y,{context:e.context},n.__v);e.componentWillUnmount=function(){var n=e.s.parentNode;n&&n.removeChild(e.s),t.__u(e.p)},e.l&&e.l!==r&&(e.componentWillUnmount(),e.h=!1),n.__v?e.h?(r.__k=e.__k,t.render(o,r),e.__k=r.__k):(e.s=document.createTextNode(""),e.__k=r.__k,t.hydrate("",r),r.appendChild(e.s),e.h=!0,e.l=r,t.render(o,r,e.s),r.__k=e.__k,e.__k=e.s.__k):e.h&&e.componentWillUnmount(),e.p=o}function S(n,e){return t.createElement(_,{__v:n,l:e})}(m.prototype=new t.Component).o=function(n){var t=this,e=d(t.__v),r=t.i.get(n);return r[0]++,function(o){var u=function(){t.props.revealOrder?(r.push(o),b(t,n,r)):o()};e?e(u):u()}},m.prototype.render=function(n){this.u=null,this.i=new Map;var e=t.toChildArray(n.children);n.revealOrder&&"b"===n.revealOrder[0]&&e.reverse();for(var r=e.length;r--;)this.i.set(e[r],this.u=[1,0,this.u]);return n.children},m.prototype.componentDidUpdate=m.prototype.componentDidMount=function(){var n=this;this.i.forEach(function(t,e){b(n,e,t)})};var w="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103,E=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,g="undefined"!=typeof Symbol?/fil|che|rad/i:/fil|che|ra/i;function C(n,e,r){return null==e.__k&&(e.textContent=""),t.render(n,e),"function"==typeof r&&r(),n?n.__c:null}function R(n,e,r){return t.hydrate(n,e),"function"==typeof r&&r(),n?n.__c:null}t.Component.prototype.isReactComponent={},["componentWillMount","componentWillReceiveProps","componentWillUpdate"].forEach(function(n){Object.defineProperty(t.Component.prototype,n,{configurable:!0,get:function(){return this["UNSAFE_"+n]},set:function(t){Object.defineProperty(this,n,{configurable:!0,writable:!0,value:t})}})});var N=t.options.event;function O(){}function k(){return this.cancelBubble}function A(){return this.defaultPrevented}t.options.event=function(n){return N&&(n=N(n)),n.persist=O,n.isPropagationStopped=k,n.isDefaultPrevented=A,n.nativeEvent=n};var L,U={configurable:!0,get:function(){return this.class}},j=t.options.vnode;t.options.vnode=function(n){n.$$typeof=w;var e=n.type,r=n.props;if("function"==typeof e)(U.enumerable="className"in r)&&(r.class=r.className),Object.defineProperty(r,"className",U);else if(e){var o={};for(var u in r){var i=r[u];"className"===u&&(o.class=i,U.enumerable=!0),"defaultValue"===u&&"value"in r&&null==r.value?u="value":"download"===u&&!0===i?i="":/ondoubleclick/i.test(u)?u="ondblclick":/^onchange(textarea|input)/i.test(u+e)&&!g.test(r.type)?u="oninput":/^on(Ani|Tra|Tou|BeforeInp)/.test(u)?u=u.toLowerCase():E.test(u)?u=u.replace(/[A-Z0-9]/,"-$&").toLowerCase():null===i&&(i=void 0),o[u]=i}Object.defineProperty(o,"className",U),"select"==e&&o.multiple&&Array.isArray(o.value)&&(o.value=t.toChildArray(r.children).forEach(function(n){n.props.selected=-1!=o.value.indexOf(n.props.value)})),n.props=o}j&&j(n)};var M=t.options.__r;t.options.__r=function(n){M&&M(n),L=n.__c};var D={ReactCurrentDispatcher:{current:{readContext:function(n){return L.__n[n.__c].props.value}}}};function F(n){return t.createElement.bind(null,n)}function I(n){return!!n&&n.$$typeof===w}function T(n){return I(n)?t.cloneElement.apply(null,arguments):n}function W(n){return!!n.__k&&(t.render(null,n),!0)}function P(n){return n&&(n.base||1===n.nodeType&&n)||null}var z=function(n,t){return n(t)},V=t.Fragment,q={useState:n.useState,useReducer:n.useReducer,useEffect:n.useEffect,useLayoutEffect:n.useLayoutEffect,useRef:n.useRef,useImperativeHandle:n.useImperativeHandle,useMemo:n.useMemo,useCallback:n.useCallback,useContext:n.useContext,useDebugValue:n.useDebugValue,version:"16.8.0",Children:a,render:C,hydrate:R,unmountComponentAtNode:W,createPortal:S,createElement:t.createElement,createContext:t.createContext,createFactory:F,cloneElement:T,createRef:t.createRef,Fragment:t.Fragment,isValidElement:I,findDOMNode:P,Component:t.Component,PureComponent:o,memo:u,forwardRef:f,unstable_batchedUpdates:z,StrictMode:V,Suspense:v,SuspenseList:m,lazy:x,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:D};Object.keys(n).forEach(function(t){exports[t]=n[t]}),exports.createElement=t.createElement,exports.createContext=t.createContext,exports.createRef=t.createRef,exports.Fragment=t.Fragment,exports.Component=t.Component,exports.version="16.8.0",exports.Children=a,exports.render=C,exports.hydrate=R,exports.unmountComponentAtNode=W,exports.createPortal=S,exports.createFactory=F,exports.cloneElement=T,exports.isValidElement=I,exports.findDOMNode=P,exports.PureComponent=o,exports.memo=u,exports.forwardRef=f,exports.unstable_batchedUpdates=z,exports.StrictMode=V,exports.Suspense=v,exports.SuspenseList=m,exports.lazy=x,exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=D,exports.default=q;
 //# sourceMappingURL=compat.js.map
diff --git a/node_modules/preact/compat/dist/compat.js.map b/node_modules/preact/compat/dist/compat.js.map
index 610318a..3b2e9f0 100644
--- a/node_modules/preact/compat/dist/compat.js.map
+++ b/node_modules/preact/compat/dist/compat.js.map
@@ -1 +1 @@
-{"version":3,"file":"compat.js","sources":["../src/util.js","../src/PureComponent.js","../src/memo.js","../src/forwardRef.js","../src/Children.js","../src/suspense.js","../src/suspense-list.js","../src/portals.js","../src/render.js","../src/events.js","../src/index.js"],"sourcesContent":["/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Check if two objects have a different shape\n * @param {object} a\n * @param {object} b\n * @returns {boolean}\n */\nexport function shallowDiffers(a, b) {\n\tfor (let i in a) if (i !== '__source' && !(i in b)) return true;\n\tfor (let i in b) if (i !== '__source' && a[i] !== b[i]) return true;\n\treturn false;\n}\n","import { Component } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Component class with a predefined `shouldComponentUpdate` implementation\n */\nexport function PureComponent(p) {\n\tthis.props = p;\n}\nPureComponent.prototype = new Component();\n// Some third-party libraries check if this property is present\nPureComponent.prototype.isPureReactComponent = true;\nPureComponent.prototype.shouldComponentUpdate = function(props, state) {\n\treturn shallowDiffers(this.props, props) || shallowDiffers(this.state, state);\n};\n","import { createElement } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Memoize a component, so that it only updates when the props actually have\n * changed. This was previously known as `React.pure`.\n * @param {import('./internal').FunctionalComponent} c functional component\n * @param {(prev: object, next: object) => boolean} [comparer] Custom equality function\n * @returns {import('./internal').FunctionalComponent}\n */\nexport function memo(c, comparer) {\n\tfunction shouldUpdate(nextProps) {\n\t\tlet ref = this.props.ref;\n\t\tlet updateRef = ref == nextProps.ref;\n\t\tif (!updateRef && ref) {\n\t\t\tref.call ? ref(null) : (ref.current = null);\n\t\t}\n\n\t\tif (!comparer) {\n\t\t\treturn shallowDiffers(this.props, nextProps);\n\t\t}\n\n\t\treturn !comparer(this.props, nextProps) || !updateRef;\n\t}\n\n\tfunction Memoed(props) {\n\t\tthis.shouldComponentUpdate = shouldUpdate;\n\t\treturn createElement(c, props);\n\t}\n\tMemoed.displayName = 'Memo(' + (c.displayName || c.name) + ')';\n\tMemoed.prototype.isReactComponent = true;\n\tMemoed._forwarded = true;\n\treturn Memoed;\n}\n","import { options } from 'preact';\nimport { assign } from './util';\n\nlet oldDiffHook = options._diff;\noptions._diff = vnode => {\n\tif (vnode.type && vnode.type._forwarded && vnode.ref) {\n\t\tvnode.props.ref = vnode.ref;\n\t\tvnode.ref = null;\n\t}\n\tif (oldDiffHook) oldDiffHook(vnode);\n};\n\nexport const REACT_FORWARD_SYMBOL =\n\t(typeof Symbol != 'undefined' &&\n\t\tSymbol.for &&\n\t\tSymbol.for('react.forward_ref')) ||\n\t0xf47;\n\n/**\n * Pass ref down to a child. This is mainly used in libraries with HOCs that\n * wrap components. Using `forwardRef` there is an easy way to get a reference\n * of the wrapped component instead of one of the wrapper itself.\n * @param {import('./index').ForwardFn} fn\n * @returns {import('./internal').FunctionalComponent}\n */\nexport function forwardRef(fn) {\n\t// We always have ref in props.ref, except for\n\t// mobx-react. It will call this function directly\n\t// and always pass ref as the second argument.\n\tfunction Forwarded(props, ref) {\n\t\tlet clone = assign({}, props);\n\t\tdelete clone.ref;\n\t\tref = props.ref || ref;\n\t\treturn fn(\n\t\t\tclone,\n\t\t\t!ref || (typeof ref === 'object' && !('current' in ref)) ? null : ref\n\t\t);\n\t}\n\n\t// mobx-react checks for this being present\n\tForwarded.$$typeof = REACT_FORWARD_SYMBOL;\n\t// mobx-react heavily relies on implementation details.\n\t// It expects an object here with a `render` property,\n\t// and prototype.render will fail. Without this\n\t// mobx-react throws.\n\tForwarded.render = Forwarded;\n\n\tForwarded.prototype.isReactComponent = Forwarded._forwarded = true;\n\tForwarded.displayName = 'ForwardRef(' + (fn.displayName || fn.name) + ')';\n\treturn Forwarded;\n}\n","import { toChildArray } from 'preact';\n\nconst mapFn = (children, fn) => {\n\tif (!children) return null;\n\treturn toChildArray(toChildArray(children).map(fn));\n};\n\n// This API is completely unnecessary for Preact, so it's basically passthrough.\nexport const Children = {\n\tmap: mapFn,\n\tforEach: mapFn,\n\tcount(children) {\n\t\treturn children ? toChildArray(children).length : 0;\n\t},\n\tonly(children) {\n\t\tconst normalized = toChildArray(children);\n\t\tif (normalized.length !== 1) throw 'Children.only';\n\t\treturn normalized[0];\n\t},\n\ttoArray: toChildArray\n};\n","import { Component, createElement, options, Fragment } from 'preact';\nimport { assign } from './util';\n\nconst oldCatchError = options._catchError;\noptions._catchError = function(error, newVNode, oldVNode) {\n\tif (error.then) {\n\t\t/** @type {import('./internal').Component} */\n\t\tlet component;\n\t\tlet vnode = newVNode;\n\n\t\tfor (; (vnode = vnode._parent); ) {\n\t\t\tif ((component = vnode._component) && component._childDidSuspend) {\n\t\t\t\tif (newVNode._dom == null) {\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t}\n\t\t\t\t// Don't call oldCatchError if we found a Suspense\n\t\t\t\treturn component._childDidSuspend(error, newVNode._component);\n\t\t\t}\n\t\t}\n\t}\n\toldCatchError(error, newVNode, oldVNode);\n};\n\nfunction detachedClone(vnode) {\n\tif (vnode) {\n\t\tvnode = assign({}, vnode);\n\t\tvnode._component = null;\n\t\tvnode._children = vnode._children && vnode._children.map(detachedClone);\n\t}\n\treturn vnode;\n}\n\nfunction removeOriginal(vnode) {\n\tif (vnode) {\n\t\tvnode._original = null;\n\t\tvnode._children = vnode._children && vnode._children.map(removeOriginal);\n\t}\n\treturn vnode;\n}\n\n// having custom inheritance instead of a class here saves a lot of bytes\nexport function Suspense() {\n\t// we do not call super here to golf some bytes...\n\tthis._pendingSuspensionCount = 0;\n\tthis._suspenders = null;\n\tthis._detachOnNextRender = null;\n}\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspense.prototype = new Component();\n\n/**\n * @param {Promise} promise The thrown promise\n * @param {Component<any, any>} suspendingComponent The suspending component\n */\nSuspense.prototype._childDidSuspend = function(promise, suspendingComponent) {\n\t/** @type {import('./internal').SuspenseComponent} */\n\tconst c = this;\n\n\tif (c._suspenders == null) {\n\t\tc._suspenders = [];\n\t}\n\tc._suspenders.push(suspendingComponent);\n\n\tconst resolve = suspended(c._vnode);\n\n\tlet resolved = false;\n\tconst onResolved = () => {\n\t\tif (resolved) return;\n\n\t\tresolved = true;\n\t\tsuspendingComponent.componentWillUnmount =\n\t\t\tsuspendingComponent._suspendedComponentWillUnmount;\n\n\t\tif (resolve) {\n\t\t\tresolve(onSuspensionComplete);\n\t\t} else {\n\t\t\tonSuspensionComplete();\n\t\t}\n\t};\n\n\tsuspendingComponent._suspendedComponentWillUnmount =\n\t\tsuspendingComponent.componentWillUnmount;\n\tsuspendingComponent.componentWillUnmount = () => {\n\t\tonResolved();\n\n\t\tif (suspendingComponent._suspendedComponentWillUnmount) {\n\t\t\tsuspendingComponent._suspendedComponentWillUnmount();\n\t\t}\n\t};\n\n\tconst onSuspensionComplete = () => {\n\t\tif (!--c._pendingSuspensionCount) {\n\t\t\tc._vnode._children[0] = removeOriginal(c.state._suspended);\n\t\t\tc.setState({ _suspended: (c._detachOnNextRender = null) });\n\n\t\t\tlet suspended;\n\t\t\twhile ((suspended = c._suspenders.pop())) {\n\t\t\t\tsuspended.forceUpdate();\n\t\t\t}\n\t\t}\n\t};\n\n\tif (!c._pendingSuspensionCount++) {\n\t\tc.setState({ _suspended: (c._detachOnNextRender = c._vnode._children[0]) });\n\t}\n\tpromise.then(onResolved, onResolved);\n};\n\nSuspense.prototype.componentWillUnmount = function() {\n\tthis._suspenders = [];\n};\n\nSuspense.prototype.render = function(props, state) {\n\tif (this._detachOnNextRender) {\n\t\t// When the Suspense's _vnode was created by a call to createVNode\n\t\t// (i.e. due to a setState further up in the tree)\n\t\t// it's _children prop is null, in this case we \"forget\" about the parked vnodes to detach\n\t\tif (this._vnode._children)\n\t\t\tthis._vnode._children[0] = detachedClone(this._detachOnNextRender);\n\t\tthis._detachOnNextRender = null;\n\t}\n\n\treturn [\n\t\tcreateElement(Fragment, null, state._suspended ? null : props.children),\n\t\tstate._suspended && props.fallback\n\t];\n};\n\n/**\n * Checks and calls the parent component's _suspended method, passing in the\n * suspended vnode. This is a way for a parent (e.g. SuspenseList) to get notified\n * that one of its children/descendants suspended.\n *\n * The parent MAY return a callback. The callback will get called when the\n * suspension resolves, notifying the parent of the fact.\n * Moreover, the callback gets function `unsuspend` as a parameter. The resolved\n * child descendant will not actually get unsuspended until `unsuspend` gets called.\n * This is a way for the parent to delay unsuspending.\n *\n * If the parent does not return a callback then the resolved vnode\n * gets unsuspended immediately when it resolves.\n *\n * @param {import('../src/internal').VNode} vnode\n * @returns {((unsuspend: () => void) => void)?}\n */\nexport function suspended(vnode) {\n\tlet component = vnode._parent._component;\n\treturn component && component._suspended && component._suspended(vnode);\n}\n\nexport function lazy(loader) {\n\tlet prom;\n\tlet component;\n\tlet error;\n\n\tfunction Lazy(props) {\n\t\tif (!prom) {\n\t\t\tprom = loader();\n\t\t\tprom.then(\n\t\t\t\texports => {\n\t\t\t\t\tcomponent = exports.default || exports;\n\t\t\t\t},\n\t\t\t\te => {\n\t\t\t\t\terror = e;\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tif (!component) {\n\t\t\tthrow prom;\n\t\t}\n\n\t\treturn createElement(component, props);\n\t}\n\n\tLazy.displayName = 'Lazy';\n\tLazy._forwarded = true;\n\treturn Lazy;\n}\n","import { Component, toChildArray } from 'preact';\nimport { suspended } from './suspense.js';\n\n// Indexes to linked list nodes (nodes are stored as arrays to save bytes).\nconst SUSPENDED_COUNT = 0;\nconst RESOLVED_COUNT = 1;\nconst NEXT_NODE = 2;\n\n// Having custom inheritance instead of a class here saves a lot of bytes.\nexport function SuspenseList() {\n\tthis._next = null;\n\tthis._map = null;\n}\n\n// Mark one of child's earlier suspensions as resolved.\n// Some pending callbacks may become callable due to this\n// (e.g. the last suspended descendant gets resolved when\n// revealOrder === 'together'). Process those callbacks as well.\nconst resolve = (list, child, node) => {\n\tif (++node[RESOLVED_COUNT] === node[SUSPENDED_COUNT]) {\n\t\t// The number a child (or any of its descendants) has been suspended\n\t\t// matches the number of times it's been resolved. Therefore we\n\t\t// mark the child as completely resolved by deleting it from ._map.\n\t\t// This is used to figure out when *all* children have been completely\n\t\t// resolved when revealOrder is 'together'.\n\t\tlist._map.delete(child);\n\t}\n\n\t// If revealOrder is falsy then we can do an early exit, as the\n\t// callbacks won't get queued in the node anyway.\n\t// If revealOrder is 'together' then also do an early exit\n\t// if all suspended descendants have not yet been resolved.\n\tif (\n\t\t!list.props.revealOrder ||\n\t\t(list.props.revealOrder[0] === 't' && list._map.size)\n\t) {\n\t\treturn;\n\t}\n\n\t// Walk the currently suspended children in order, calling their\n\t// stored callbacks on the way. Stop if we encounter a child that\n\t// has not been completely resolved yet.\n\tnode = list._next;\n\twhile (node) {\n\t\twhile (node.length > 3) {\n\t\t\tnode.pop()();\n\t\t}\n\t\tif (node[RESOLVED_COUNT] < node[SUSPENDED_COUNT]) {\n\t\t\tbreak;\n\t\t}\n\t\tlist._next = node = node[NEXT_NODE];\n\t}\n};\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspenseList.prototype = new Component();\n\nSuspenseList.prototype._suspended = function(child) {\n\tconst list = this;\n\tconst delegated = suspended(list._vnode);\n\n\tlet node = list._map.get(child);\n\tnode[SUSPENDED_COUNT]++;\n\n\treturn unsuspend => {\n\t\tconst wrappedUnsuspend = () => {\n\t\t\tif (!list.props.revealOrder) {\n\t\t\t\t// Special case the undefined (falsy) revealOrder, as there\n\t\t\t\t// is no need to coordinate a specific order or unsuspends.\n\t\t\t\tunsuspend();\n\t\t\t} else {\n\t\t\t\tnode.push(unsuspend);\n\t\t\t\tresolve(list, child, node);\n\t\t\t}\n\t\t};\n\t\tif (delegated) {\n\t\t\tdelegated(wrappedUnsuspend);\n\t\t} else {\n\t\t\twrappedUnsuspend();\n\t\t}\n\t};\n};\n\nSuspenseList.prototype.render = function(props) {\n\tthis._next = null;\n\tthis._map = new Map();\n\n\tconst children = toChildArray(props.children);\n\tif (props.revealOrder && props.revealOrder[0] === 'b') {\n\t\t// If order === 'backwards' (or, well, anything starting with a 'b')\n\t\t// then flip the child list around so that the last child will be\n\t\t// the first in the linked list.\n\t\tchildren.reverse();\n\t}\n\t// Build the linked list. Iterate through the children in reverse order\n\t// so that `_next` points to the first linked list node to be resolved.\n\tfor (let i = children.length; i--; ) {\n\t\t// Create a new linked list node as an array of form:\n\t\t// \t[suspended_count, resolved_count, next_node]\n\t\t// where suspended_count and resolved_count are numeric counters for\n\t\t// keeping track how many times a node has been suspended and resolved.\n\t\t//\n\t\t// Note that suspended_count starts from 1 instead of 0, so we can block\n\t\t// processing callbacks until componentDidMount has been called. In a sense\n\t\t// node is suspended at least until componentDidMount gets called!\n\t\t//\n\t\t// Pending callbacks are added to the end of the node:\n\t\t// \t[suspended_count, resolved_count, next_node, callback_0, callback_1, ...]\n\t\tthis._map.set(children[i], (this._next = [1, 0, this._next]));\n\t}\n\treturn props.children;\n};\n\nSuspenseList.prototype.componentDidUpdate = SuspenseList.prototype.componentDidMount = function() {\n\t// Iterate through all children after mounting for two reasons:\n\t// 1. As each node[SUSPENDED_COUNT] starts from 1, this iteration increases\n\t//    each node[RELEASED_COUNT] by 1, therefore balancing the counters.\n\t//    The nodes can now be completely consumed from the linked list.\n\t// 2. Handle nodes that might have gotten resolved between render and\n\t//    componentDidMount.\n\tthis._map.forEach((node, child) => {\n\t\tresolve(this, child, node);\n\t});\n};\n","import { createElement, hydrate, render, __u as _unmount } from 'preact';\n\nfunction ContextProvider(props) {\n\tthis.getChildContext = () => props.context;\n\treturn props.children;\n}\n\n/**\n * Portal component\n * @param {object | null | undefined} props\n *\n * TODO: this could use the \"fake root node\" trick from the partial hydration demo\n */\nfunction Portal(props) {\n\tconst _this = this;\n\tlet container = props._container;\n\tlet wrap = createElement(\n\t\tContextProvider,\n\t\t{ context: _this.context },\n\t\tprops._vnode\n\t);\n\n\t_this.componentWillUnmount = function() {\n\t\tlet parent = _this._temp.parentNode;\n\t\tif (parent) parent.removeChild(_this._temp);\n\t\t_unmount(_this._wrap);\n\t};\n\n\t// When we change container we should clear our old container and\n\t// indicate a new mount.\n\tif (_this._container && _this._container !== container) {\n\t\t_this.componentWillUnmount();\n\t\t// if (_this._temp.parentNode) _this._container.removeChild(_this._temp);\n\t\t// _unmount(_this._wrap);\n\t\t_this._hasMounted = false;\n\t}\n\n\t// When props.vnode is undefined/false/null we are dealing with some kind of\n\t// conditional vnode. This should not trigger a render.\n\tif (props._vnode) {\n\t\tif (!_this._hasMounted) {\n\t\t\t// Create a placeholder that we can use to insert into.\n\t\t\t_this._temp = document.createTextNode('');\n\t\t\t// temporarily store the current children of the container to restore them after render\n\t\t\t_this._children = container._children;\n\t\t\t// Hydrate existing nodes to keep the dom intact, when rendering\n\t\t\t// wrap into the container.\n\t\t\thydrate('', container);\n\t\t\t// Append to the container (this matches React's behavior)\n\t\t\tcontainer.appendChild(_this._temp);\n\t\t\t// At this point we have mounted and should set our container.\n\t\t\t_this._hasMounted = true;\n\t\t\t_this._container = container;\n\t\t\t// Render our wrapping element into temp.\n\t\t\trender(wrap, container, _this._temp);\n\t\t\t// restore the previous children of the container\n\t\t\tcontainer._children = _this._children;\n\t\t\t// store the children of the new vnode to be used in subsequent re-renders\n\t\t\t_this._children = _this._temp._children;\n\t\t} else {\n\t\t\t// When we have mounted and the vnode is present it means the\n\t\t\t// props have changed or a parent is triggering a rerender.\n\t\t\t// This implies we only need to call render. But we need to keep\n\t\t\t// the old tree around, otherwise will treat the vnodes as new and\n\t\t\t// will wrongly call `componentDidMount` on them\n\t\t\tcontainer._children = _this._children;\n\t\t\trender(wrap, container);\n\t\t\t_this._children = container._children;\n\t\t}\n\t}\n\t// When we come from a conditional render, on a mounted\n\t// portal we should clear the DOM.\n\telse if (_this._hasMounted) {\n\t\t_this.componentWillUnmount();\n\t\t// if (_this._temp.parentNode) _this._container.removeChild(_this._temp);\n\t\t// _unmount(_this._wrap);\n\t}\n\t// Set the wrapping element for future unmounting.\n\t_this._wrap = wrap;\n}\n\n/**\n * Create a `Portal` to continue rendering the vnode tree at a different DOM node\n * @param {import('./internal').VNode} vnode The vnode to render\n * @param {import('./internal').PreactElement} container The DOM node to continue rendering in to.\n */\nexport function createPortal(vnode, container) {\n\treturn createElement(Portal, { _vnode: vnode, _container: container });\n}\n","import {\n\trender as preactRender,\n\thydrate as preactHydrate,\n\toptions,\n\ttoChildArray,\n\tComponent\n} from 'preact';\nimport { applyEventNormalization } from './events';\n\nconst CAMEL_PROPS = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;\n\n// Some libraries like `react-virtualized` explicitly check for this.\nComponent.prototype.isReactComponent = {};\n\nexport const REACT_ELEMENT_TYPE =\n\t(typeof Symbol != 'undefined' && Symbol.for && Symbol.for('react.element')) ||\n\t0xeac7;\n\n/**\n * Proxy render() since React returns a Component reference.\n * @param {import('./internal').VNode} vnode VNode tree to render\n * @param {import('./internal').PreactElement} parent DOM node to render vnode tree into\n * @param {() => void} [callback] Optional callback that will be called after rendering\n * @returns {import('./internal').Component | null} The root component reference or null\n */\nexport function render(vnode, parent, callback) {\n\t// React destroys any existing DOM nodes, see #1727\n\t// ...but only on the first render, see #1828\n\tif (parent._children == null) {\n\t\twhile (parent.firstChild) {\n\t\t\tparent.removeChild(parent.firstChild);\n\t\t}\n\t}\n\n\tpreactRender(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nexport function hydrate(vnode, parent, callback) {\n\tpreactHydrate(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nlet oldEventHook = options.event;\noptions.event = e => {\n\tif (oldEventHook) e = oldEventHook(e);\n\te.persist = () => {};\n\tlet stoppedPropagating = false,\n\t\tdefaultPrevented = false;\n\n\tconst origStopPropagation = e.stopPropagation;\n\te.stopPropagation = () => {\n\t\torigStopPropagation.call(e);\n\t\tstoppedPropagating = true;\n\t};\n\n\tconst origPreventDefault = e.preventDefault;\n\te.preventDefault = () => {\n\t\torigPreventDefault.call(e);\n\t\tdefaultPrevented = true;\n\t};\n\n\te.isPropagationStopped = () => stoppedPropagating;\n\te.isDefaultPrevented = () => defaultPrevented;\n\treturn (e.nativeEvent = e);\n};\n\n// Patch in `UNSAFE_*` lifecycle hooks\nfunction setSafeDescriptor(proto, key) {\n\tif (proto['UNSAFE_' + key] && !proto[key]) {\n\t\tObject.defineProperty(proto, key, {\n\t\t\tget() {\n\t\t\t\treturn this['UNSAFE_' + key];\n\t\t\t},\n\t\t\t// This `set` is only used if a user sets a lifecycle like cWU\n\t\t\t// after setting a lifecycle like UNSAFE_cWU. I doubt anyone\n\t\t\t// actually does this in practice so not testing it\n\t\t\t/* istanbul ignore next */\n\t\t\tset(v) {\n\t\t\t\tthis['UNSAFE_' + key] = v;\n\t\t\t}\n\t\t});\n\t}\n}\n\nlet classNameDescriptor = {\n\tconfigurable: true,\n\tget() {\n\t\treturn this.class;\n\t}\n};\n\nlet oldVNodeHook = options.vnode;\noptions.vnode = vnode => {\n\tvnode.$$typeof = REACT_ELEMENT_TYPE;\n\n\tlet type = vnode.type;\n\tlet props = vnode.props;\n\n\tif (type) {\n\t\t// Alias `class` prop to `className` if available\n\t\tif (props.class != props.className) {\n\t\t\tclassNameDescriptor.enumerable = 'className' in props;\n\t\t\tif (props.className != null) props.class = props.className;\n\t\t\tObject.defineProperty(props, 'className', classNameDescriptor);\n\t\t}\n\n\t\t// Apply DOM VNode compat\n\t\tif (typeof type != 'function') {\n\t\t\t// Apply defaultValue to value\n\t\t\tif (props.defaultValue && props.value !== undefined) {\n\t\t\t\tif (!props.value && props.value !== 0) {\n\t\t\t\t\tprops.value = props.defaultValue;\n\t\t\t\t}\n\t\t\t\tprops.defaultValue = undefined;\n\t\t\t}\n\n\t\t\t// Add support for array select values: <select value={[]} />\n\t\t\tif (type === 'select' && props.multiple && Array.isArray(props.value)) {\n\t\t\t\ttoChildArray(props.children).forEach(child => {\n\t\t\t\t\tif (props.value.indexOf(child.props.value) != -1) {\n\t\t\t\t\t\tchild.props.selected = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tprops.value = undefined;\n\t\t\t}\n\n\t\t\t// Calling `setAttribute` with a truthy value will lead to it being\n\t\t\t// passed as a stringified value, e.g. `download=\"true\"`. React\n\t\t\t// converts it to an empty string instead, otherwise the attribute\n\t\t\t// value will be used as the file name and the file will be called\n\t\t\t// \"true\" upon downloading it.\n\t\t\tif (props.download === true) {\n\t\t\t\tprops.download = '';\n\t\t\t}\n\n\t\t\t// Normalize DOM vnode properties.\n\t\t\tlet i;\n\t\t\tfor (i in props) {\n\t\t\t\tlet shouldSanitize = CAMEL_PROPS.test(i);\n\t\t\t\tif (shouldSanitize)\n\t\t\t\t\tvnode.props[i.replace(/[A-Z0-9]/, '-$&').toLowerCase()] = props[i];\n\t\t\t\tif (shouldSanitize || props[i] === null) props[i] = undefined;\n\t\t\t}\n\t\t}\n\t\t// Component base class compat\n\t\t// We can't just patch the base component class, because components that use\n\t\t// inheritance and are transpiled down to ES5 will overwrite our patched\n\t\t// getters and setters. See #1941\n\t\telse if (type.prototype && !type.prototype._patchedLifecycles) {\n\t\t\ttype.prototype._patchedLifecycles = true;\n\t\t\tsetSafeDescriptor(type.prototype, 'componentWillMount');\n\t\t\tsetSafeDescriptor(type.prototype, 'componentWillReceiveProps');\n\t\t\tsetSafeDescriptor(type.prototype, 'componentWillUpdate');\n\t\t}\n\n\t\t// Events\n\t\tapplyEventNormalization(vnode);\n\t}\n\n\tif (oldVNodeHook) oldVNodeHook(vnode);\n};\n\n// Only needed for react-relay\nlet currentComponent;\nconst oldBeforeRender = options._render;\noptions._render = function(vnode) {\n\tif (oldBeforeRender) {\n\t\toldBeforeRender(vnode);\n\t}\n\tcurrentComponent = vnode._component;\n};\n\n// This is a very very private internal function for React it\n// is used to sort-of do runtime dependency injection. So far\n// only `react-relay` makes use of it. It uses it to read the\n// context value.\nexport const __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = {\n\tReactCurrentDispatcher: {\n\t\tcurrent: {\n\t\t\treadContext(context) {\n\t\t\t\treturn currentComponent._globalContext[context._id].props.value;\n\t\t\t}\n\t\t}\n\t}\n};\n","/**\n * Normalize event handlers like react does. Most famously it uses `onChange` for any input element.\n * @param {import('./internal').VNode} vnode The vnode to normalize events on\n */\nexport function applyEventNormalization({ type, props }) {\n\tif (!props || typeof type != 'string') return;\n\tlet newProps = {};\n\n\tfor (let i in props) {\n\t\tif (/^on(Ani|Tra|Tou)/.test(i)) {\n\t\t\tprops[i.toLowerCase()] = props[i];\n\t\t\tdelete props[i];\n\t\t}\n\t\tnewProps[i.toLowerCase()] = i;\n\t}\n\tif (newProps.ondoubleclick) {\n\t\tprops.ondblclick = props[newProps.ondoubleclick];\n\t\tdelete props[newProps.ondoubleclick];\n\t}\n\tif (newProps.onbeforeinput) {\n\t\tprops.onbeforeinput = props[newProps.onbeforeinput];\n\t\tdelete props[newProps.onbeforeinput];\n\t}\n\t// for *textual inputs* (incl textarea), normalize `onChange` -> `onInput`:\n\tif (\n\t\tnewProps.onchange &&\n\t\t(type === 'textarea' ||\n\t\t\t(type.toLowerCase() === 'input' && !/^fil|che|ra/i.test(props.type)))\n\t) {\n\t\tlet normalized = newProps.oninput || 'oninput';\n\t\tif (!props[normalized]) {\n\t\t\tprops[normalized] = props[newProps.onchange];\n\t\t\tdelete props[newProps.onchange];\n\t\t}\n\t}\n}\n","import {\n\tcreateElement,\n\trender as preactRender,\n\tcloneElement as preactCloneElement,\n\tcreateRef,\n\tComponent,\n\tcreateContext,\n\tFragment\n} from 'preact';\nimport {\n\tuseState,\n\tuseReducer,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseRef,\n\tuseImperativeHandle,\n\tuseMemo,\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue\n} from 'preact/hooks';\nimport { PureComponent } from './PureComponent';\nimport { memo } from './memo';\nimport { forwardRef } from './forwardRef';\nimport { Children } from './Children';\nimport { Suspense, lazy } from './suspense';\nimport { SuspenseList } from './suspense-list';\nimport { createPortal } from './portals';\nimport {\n\thydrate,\n\trender,\n\tREACT_ELEMENT_TYPE,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n} from './render';\n\nconst version = '16.8.0'; // trick libraries to think we are react\n\n/**\n * Legacy version of createElement.\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component constructor\n */\nfunction createFactory(type) {\n\treturn createElement.bind(null, type);\n}\n\n/**\n * Check if the passed element is a valid (p)react node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isValidElement(element) {\n\treturn !!element && element.$$typeof === REACT_ELEMENT_TYPE;\n}\n\n/**\n * Wrap `cloneElement` to abort if the passed element is not a valid element and apply\n * all vnode normalizations.\n * @param {import('./internal').VNode} element The vnode to clone\n * @param {object} props Props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Optional component children\n */\nfunction cloneElement(element) {\n\tif (!isValidElement(element)) return element;\n\treturn preactCloneElement.apply(null, arguments);\n}\n\n/**\n * Remove a component tree from the DOM, including state and event handlers.\n * @param {import('./internal').PreactElement} container\n * @returns {boolean}\n */\nfunction unmountComponentAtNode(container) {\n\tif (container._children) {\n\t\tpreactRender(null, container);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**\n * Get the matching DOM node for a component\n * @param {import('./internal').Component} component\n * @returns {import('./internal').PreactElement | null}\n */\nfunction findDOMNode(component) {\n\treturn (\n\t\t(component &&\n\t\t\t(component.base || (component.nodeType === 1 && component))) ||\n\t\tnull\n\t);\n}\n\n/**\n * Deprecated way to control batched rendering inside the reconciler, but we\n * already schedule in batches inside our rendering code\n * @template Arg\n * @param {(arg: Arg) => void} callback function that triggers the updated\n * @param {Arg} [arg] Optional argument that can be passed to the callback\n */\n// eslint-disable-next-line camelcase\nconst unstable_batchedUpdates = (callback, arg) => callback(arg);\n\n/**\n * Strict Mode is not implemented in Preact, so we provide a stand-in for it\n * that just renders its children without imposing any restrictions.\n */\nconst StrictMode = Fragment;\n\nexport * from 'preact/hooks';\nexport {\n\tversion,\n\tChildren,\n\trender,\n\thydrate,\n\tunmountComponentAtNode,\n\tcreatePortal,\n\tcreateElement,\n\tcreateContext,\n\tcreateFactory,\n\tcloneElement,\n\tcreateRef,\n\tFragment,\n\tisValidElement,\n\tfindDOMNode,\n\tComponent,\n\tPureComponent,\n\tmemo,\n\tforwardRef,\n\t// eslint-disable-next-line camelcase\n\tunstable_batchedUpdates,\n\tStrictMode,\n\tSuspense,\n\tSuspenseList,\n\tlazy,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n\n// React copies the named exports to the default one.\nexport default {\n\tuseState,\n\tuseReducer,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseRef,\n\tuseImperativeHandle,\n\tuseMemo,\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue,\n\tversion,\n\tChildren,\n\trender,\n\thydrate,\n\tunmountComponentAtNode,\n\tcreatePortal,\n\tcreateElement,\n\tcreateContext,\n\tcreateFactory,\n\tcloneElement,\n\tcreateRef,\n\tFragment,\n\tisValidElement,\n\tfindDOMNode,\n\tComponent,\n\tPureComponent,\n\tmemo,\n\tforwardRef,\n\tunstable_batchedUpdates,\n\tStrictMode,\n\tSuspense,\n\tSuspenseList,\n\tlazy,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n"],"names":["assign","obj","props","i","shallowDiffers","a","b","PureComponent","p","memo","c","comparer","shouldUpdate","nextProps","ref","this","updateRef","call","current","Memoed","shouldComponentUpdate","createElement","displayName","name","prototype","isReactComponent","Component","isPureReactComponent","state","oldDiffHook","options","vnode","type","REACT_FORWARD_SYMBOL","Symbol","for","forwardRef","fn","Forwarded","clone","$$typeof","render","mapFn","children","toChildArray","map","Children","forEach","count","length","only","normalized","toArray","oldCatchError","detachedClone","removeOriginal","Suspense","_suspenders","suspended","component","_suspended","lazy","loader","prom","error","Lazy","then","exports","default","e","SuspenseList","_next","_map","newVNode","oldVNode","promise","suspendingComponent","push","resolve","resolved","onResolved","componentWillUnmount","onSuspensionComplete","setState","pop","forceUpdate","Fragment","fallback","list","child","node","delete","revealOrder","size","ContextProvider","getChildContext","context","Portal","_this","container","_container","wrap","parent","_temp","parentNode","removeChild","_unmount","_wrap","_hasMounted","document","createTextNode","hydrate","appendChild","createPortal","delegated","get","unsuspend","wrappedUnsuspend","Map","reverse","set","componentDidUpdate","componentDidMount","CAMEL_PROPS","REACT_ELEMENT_TYPE","callback","firstChild","preactRender","preactHydrate","oldEventHook","event","setSafeDescriptor","proto","key","Object","defineProperty","v","persist","stoppedPropagating","defaultPrevented","origStopPropagation","stopPropagation","origPreventDefault","preventDefault","isPropagationStopped","isDefaultPrevented","nativeEvent","currentComponent","classNameDescriptor","configurable","class","oldVNodeHook","className","enumerable","defaultValue","undefined","value","multiple","Array","isArray","indexOf","selected","download","shouldSanitize","test","replace","toLowerCase","_patchedLifecycles","newProps","ondoubleclick","ondblclick","onbeforeinput","onchange","oninput","applyEventNormalization","oldBeforeRender","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentDispatcher","readContext","createFactory","bind","isValidElement","element","cloneElement","preactCloneElement","apply","arguments","unmountComponentAtNode","findDOMNode","base","nodeType","unstable_batchedUpdates","arg","StrictMode","useState","useReducer","useEffect","useLayoutEffect","useRef","useImperativeHandle","useMemo","useCallback","useContext","useDebugValue","version","createContext","createRef"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"compat.js","sources":["../src/util.js","../src/PureComponent.js","../src/memo.js","../src/forwardRef.js","../src/Children.js","../src/suspense.js","../src/suspense-list.js","../src/portals.js","../src/render.js","../src/index.js"],"sourcesContent":["/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Check if two objects have a different shape\n * @param {object} a\n * @param {object} b\n * @returns {boolean}\n */\nexport function shallowDiffers(a, b) {\n\tfor (let i in a) if (i !== '__source' && !(i in b)) return true;\n\tfor (let i in b) if (i !== '__source' && a[i] !== b[i]) return true;\n\treturn false;\n}\n","import { Component } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Component class with a predefined `shouldComponentUpdate` implementation\n */\nexport function PureComponent(p) {\n\tthis.props = p;\n}\nPureComponent.prototype = new Component();\n// Some third-party libraries check if this property is present\nPureComponent.prototype.isPureReactComponent = true;\nPureComponent.prototype.shouldComponentUpdate = function(props, state) {\n\treturn shallowDiffers(this.props, props) || shallowDiffers(this.state, state);\n};\n","import { createElement } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Memoize a component, so that it only updates when the props actually have\n * changed. This was previously known as `React.pure`.\n * @param {import('./internal').FunctionalComponent} c functional component\n * @param {(prev: object, next: object) => boolean} [comparer] Custom equality function\n * @returns {import('./internal').FunctionalComponent}\n */\nexport function memo(c, comparer) {\n\tfunction shouldUpdate(nextProps) {\n\t\tlet ref = this.props.ref;\n\t\tlet updateRef = ref == nextProps.ref;\n\t\tif (!updateRef && ref) {\n\t\t\tref.call ? ref(null) : (ref.current = null);\n\t\t}\n\n\t\tif (!comparer) {\n\t\t\treturn shallowDiffers(this.props, nextProps);\n\t\t}\n\n\t\treturn !comparer(this.props, nextProps) || !updateRef;\n\t}\n\n\tfunction Memoed(props) {\n\t\tthis.shouldComponentUpdate = shouldUpdate;\n\t\treturn createElement(c, props);\n\t}\n\tMemoed.displayName = 'Memo(' + (c.displayName || c.name) + ')';\n\tMemoed.prototype.isReactComponent = true;\n\tMemoed._forwarded = true;\n\treturn Memoed;\n}\n","import { options } from 'preact';\nimport { assign } from './util';\n\nlet oldDiffHook = options._diff;\noptions._diff = vnode => {\n\tif (vnode.type && vnode.type._forwarded && vnode.ref) {\n\t\tvnode.props.ref = vnode.ref;\n\t\tvnode.ref = null;\n\t}\n\tif (oldDiffHook) oldDiffHook(vnode);\n};\n\nexport const REACT_FORWARD_SYMBOL =\n\t(typeof Symbol != 'undefined' &&\n\t\tSymbol.for &&\n\t\tSymbol.for('react.forward_ref')) ||\n\t0xf47;\n\n/**\n * Pass ref down to a child. This is mainly used in libraries with HOCs that\n * wrap components. Using `forwardRef` there is an easy way to get a reference\n * of the wrapped component instead of one of the wrapper itself.\n * @param {import('./index').ForwardFn} fn\n * @returns {import('./internal').FunctionalComponent}\n */\nexport function forwardRef(fn) {\n\t// We always have ref in props.ref, except for\n\t// mobx-react. It will call this function directly\n\t// and always pass ref as the second argument.\n\tfunction Forwarded(props, ref) {\n\t\tlet clone = assign({}, props);\n\t\tdelete clone.ref;\n\t\tref = props.ref || ref;\n\t\treturn fn(\n\t\t\tclone,\n\t\t\t!ref || (typeof ref === 'object' && !('current' in ref)) ? null : ref\n\t\t);\n\t}\n\n\t// mobx-react checks for this being present\n\tForwarded.$$typeof = REACT_FORWARD_SYMBOL;\n\t// mobx-react heavily relies on implementation details.\n\t// It expects an object here with a `render` property,\n\t// and prototype.render will fail. Without this\n\t// mobx-react throws.\n\tForwarded.render = Forwarded;\n\n\tForwarded.prototype.isReactComponent = Forwarded._forwarded = true;\n\tForwarded.displayName = 'ForwardRef(' + (fn.displayName || fn.name) + ')';\n\treturn Forwarded;\n}\n","import { toChildArray } from 'preact';\n\nconst mapFn = (children, fn) => {\n\tif (children == null) return null;\n\treturn toChildArray(toChildArray(children).map(fn));\n};\n\n// This API is completely unnecessary for Preact, so it's basically passthrough.\nexport const Children = {\n\tmap: mapFn,\n\tforEach: mapFn,\n\tcount(children) {\n\t\treturn children ? toChildArray(children).length : 0;\n\t},\n\tonly(children) {\n\t\tconst normalized = toChildArray(children);\n\t\tif (normalized.length !== 1) throw 'Children.only';\n\t\treturn normalized[0];\n\t},\n\ttoArray: toChildArray\n};\n","import { Component, createElement, options, Fragment } from 'preact';\nimport { assign } from './util';\n\nconst oldCatchError = options._catchError;\noptions._catchError = function(error, newVNode, oldVNode) {\n\tif (error.then) {\n\t\t/** @type {import('./internal').Component} */\n\t\tlet component;\n\t\tlet vnode = newVNode;\n\n\t\tfor (; (vnode = vnode._parent); ) {\n\t\t\tif ((component = vnode._component) && component._childDidSuspend) {\n\t\t\t\tif (newVNode._dom == null) {\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t}\n\t\t\t\t// Don't call oldCatchError if we found a Suspense\n\t\t\t\treturn component._childDidSuspend(error, newVNode._component);\n\t\t\t}\n\t\t}\n\t}\n\toldCatchError(error, newVNode, oldVNode);\n};\n\nfunction detachedClone(vnode) {\n\tif (vnode) {\n\t\tvnode = assign({}, vnode);\n\t\tvnode._component = null;\n\t\tvnode._children = vnode._children && vnode._children.map(detachedClone);\n\t}\n\treturn vnode;\n}\n\nfunction removeOriginal(vnode) {\n\tif (vnode) {\n\t\tvnode._original = null;\n\t\tvnode._children = vnode._children && vnode._children.map(removeOriginal);\n\t}\n\treturn vnode;\n}\n\n// having custom inheritance instead of a class here saves a lot of bytes\nexport function Suspense() {\n\t// we do not call super here to golf some bytes...\n\tthis._pendingSuspensionCount = 0;\n\tthis._suspenders = null;\n\tthis._detachOnNextRender = null;\n}\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspense.prototype = new Component();\n\n/**\n * @param {Promise} promise The thrown promise\n * @param {Component<any, any>} suspendingComponent The suspending component\n */\nSuspense.prototype._childDidSuspend = function(promise, suspendingComponent) {\n\t/** @type {import('./internal').SuspenseComponent} */\n\tconst c = this;\n\n\tif (c._suspenders == null) {\n\t\tc._suspenders = [];\n\t}\n\tc._suspenders.push(suspendingComponent);\n\n\tconst resolve = suspended(c._vnode);\n\n\tlet resolved = false;\n\tconst onResolved = () => {\n\t\tif (resolved) return;\n\n\t\tresolved = true;\n\t\tsuspendingComponent.componentWillUnmount =\n\t\t\tsuspendingComponent._suspendedComponentWillUnmount;\n\n\t\tif (resolve) {\n\t\t\tresolve(onSuspensionComplete);\n\t\t} else {\n\t\t\tonSuspensionComplete();\n\t\t}\n\t};\n\n\tsuspendingComponent._suspendedComponentWillUnmount =\n\t\tsuspendingComponent.componentWillUnmount;\n\tsuspendingComponent.componentWillUnmount = () => {\n\t\tonResolved();\n\n\t\tif (suspendingComponent._suspendedComponentWillUnmount) {\n\t\t\tsuspendingComponent._suspendedComponentWillUnmount();\n\t\t}\n\t};\n\n\tconst onSuspensionComplete = () => {\n\t\tif (!--c._pendingSuspensionCount) {\n\t\t\tc._vnode._children[0] = removeOriginal(c.state._suspended);\n\t\t\tc.setState({ _suspended: (c._detachOnNextRender = null) });\n\n\t\t\tlet suspended;\n\t\t\twhile ((suspended = c._suspenders.pop())) {\n\t\t\t\tsuspended.forceUpdate();\n\t\t\t}\n\t\t}\n\t};\n\n\tif (!c._pendingSuspensionCount++) {\n\t\tc.setState({ _suspended: (c._detachOnNextRender = c._vnode._children[0]) });\n\t}\n\tpromise.then(onResolved, onResolved);\n};\n\nSuspense.prototype.componentWillUnmount = function() {\n\tthis._suspenders = [];\n};\n\nSuspense.prototype.render = function(props, state) {\n\tif (this._detachOnNextRender) {\n\t\t// When the Suspense's _vnode was created by a call to createVNode\n\t\t// (i.e. due to a setState further up in the tree)\n\t\t// it's _children prop is null, in this case we \"forget\" about the parked vnodes to detach\n\t\tif (this._vnode._children)\n\t\t\tthis._vnode._children[0] = detachedClone(this._detachOnNextRender);\n\t\tthis._detachOnNextRender = null;\n\t}\n\n\treturn [\n\t\tcreateElement(Fragment, null, state._suspended ? null : props.children),\n\t\tstate._suspended && props.fallback\n\t];\n};\n\n/**\n * Checks and calls the parent component's _suspended method, passing in the\n * suspended vnode. This is a way for a parent (e.g. SuspenseList) to get notified\n * that one of its children/descendants suspended.\n *\n * The parent MAY return a callback. The callback will get called when the\n * suspension resolves, notifying the parent of the fact.\n * Moreover, the callback gets function `unsuspend` as a parameter. The resolved\n * child descendant will not actually get unsuspended until `unsuspend` gets called.\n * This is a way for the parent to delay unsuspending.\n *\n * If the parent does not return a callback then the resolved vnode\n * gets unsuspended immediately when it resolves.\n *\n * @param {import('../src/internal').VNode} vnode\n * @returns {((unsuspend: () => void) => void)?}\n */\nexport function suspended(vnode) {\n\tlet component = vnode._parent._component;\n\treturn component && component._suspended && component._suspended(vnode);\n}\n\nexport function lazy(loader) {\n\tlet prom;\n\tlet component;\n\tlet error;\n\n\tfunction Lazy(props) {\n\t\tif (!prom) {\n\t\t\tprom = loader();\n\t\t\tprom.then(\n\t\t\t\texports => {\n\t\t\t\t\tcomponent = exports.default || exports;\n\t\t\t\t},\n\t\t\t\te => {\n\t\t\t\t\terror = e;\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tif (!component) {\n\t\t\tthrow prom;\n\t\t}\n\n\t\treturn createElement(component, props);\n\t}\n\n\tLazy.displayName = 'Lazy';\n\tLazy._forwarded = true;\n\treturn Lazy;\n}\n","import { Component, toChildArray } from 'preact';\nimport { suspended } from './suspense.js';\n\n// Indexes to linked list nodes (nodes are stored as arrays to save bytes).\nconst SUSPENDED_COUNT = 0;\nconst RESOLVED_COUNT = 1;\nconst NEXT_NODE = 2;\n\n// Having custom inheritance instead of a class here saves a lot of bytes.\nexport function SuspenseList() {\n\tthis._next = null;\n\tthis._map = null;\n}\n\n// Mark one of child's earlier suspensions as resolved.\n// Some pending callbacks may become callable due to this\n// (e.g. the last suspended descendant gets resolved when\n// revealOrder === 'together'). Process those callbacks as well.\nconst resolve = (list, child, node) => {\n\tif (++node[RESOLVED_COUNT] === node[SUSPENDED_COUNT]) {\n\t\t// The number a child (or any of its descendants) has been suspended\n\t\t// matches the number of times it's been resolved. Therefore we\n\t\t// mark the child as completely resolved by deleting it from ._map.\n\t\t// This is used to figure out when *all* children have been completely\n\t\t// resolved when revealOrder is 'together'.\n\t\tlist._map.delete(child);\n\t}\n\n\t// If revealOrder is falsy then we can do an early exit, as the\n\t// callbacks won't get queued in the node anyway.\n\t// If revealOrder is 'together' then also do an early exit\n\t// if all suspended descendants have not yet been resolved.\n\tif (\n\t\t!list.props.revealOrder ||\n\t\t(list.props.revealOrder[0] === 't' && list._map.size)\n\t) {\n\t\treturn;\n\t}\n\n\t// Walk the currently suspended children in order, calling their\n\t// stored callbacks on the way. Stop if we encounter a child that\n\t// has not been completely resolved yet.\n\tnode = list._next;\n\twhile (node) {\n\t\twhile (node.length > 3) {\n\t\t\tnode.pop()();\n\t\t}\n\t\tif (node[RESOLVED_COUNT] < node[SUSPENDED_COUNT]) {\n\t\t\tbreak;\n\t\t}\n\t\tlist._next = node = node[NEXT_NODE];\n\t}\n};\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspenseList.prototype = new Component();\n\nSuspenseList.prototype._suspended = function(child) {\n\tconst list = this;\n\tconst delegated = suspended(list._vnode);\n\n\tlet node = list._map.get(child);\n\tnode[SUSPENDED_COUNT]++;\n\n\treturn unsuspend => {\n\t\tconst wrappedUnsuspend = () => {\n\t\t\tif (!list.props.revealOrder) {\n\t\t\t\t// Special case the undefined (falsy) revealOrder, as there\n\t\t\t\t// is no need to coordinate a specific order or unsuspends.\n\t\t\t\tunsuspend();\n\t\t\t} else {\n\t\t\t\tnode.push(unsuspend);\n\t\t\t\tresolve(list, child, node);\n\t\t\t}\n\t\t};\n\t\tif (delegated) {\n\t\t\tdelegated(wrappedUnsuspend);\n\t\t} else {\n\t\t\twrappedUnsuspend();\n\t\t}\n\t};\n};\n\nSuspenseList.prototype.render = function(props) {\n\tthis._next = null;\n\tthis._map = new Map();\n\n\tconst children = toChildArray(props.children);\n\tif (props.revealOrder && props.revealOrder[0] === 'b') {\n\t\t// If order === 'backwards' (or, well, anything starting with a 'b')\n\t\t// then flip the child list around so that the last child will be\n\t\t// the first in the linked list.\n\t\tchildren.reverse();\n\t}\n\t// Build the linked list. Iterate through the children in reverse order\n\t// so that `_next` points to the first linked list node to be resolved.\n\tfor (let i = children.length; i--; ) {\n\t\t// Create a new linked list node as an array of form:\n\t\t// \t[suspended_count, resolved_count, next_node]\n\t\t// where suspended_count and resolved_count are numeric counters for\n\t\t// keeping track how many times a node has been suspended and resolved.\n\t\t//\n\t\t// Note that suspended_count starts from 1 instead of 0, so we can block\n\t\t// processing callbacks until componentDidMount has been called. In a sense\n\t\t// node is suspended at least until componentDidMount gets called!\n\t\t//\n\t\t// Pending callbacks are added to the end of the node:\n\t\t// \t[suspended_count, resolved_count, next_node, callback_0, callback_1, ...]\n\t\tthis._map.set(children[i], (this._next = [1, 0, this._next]));\n\t}\n\treturn props.children;\n};\n\nSuspenseList.prototype.componentDidUpdate = SuspenseList.prototype.componentDidMount = function() {\n\t// Iterate through all children after mounting for two reasons:\n\t// 1. As each node[SUSPENDED_COUNT] starts from 1, this iteration increases\n\t//    each node[RELEASED_COUNT] by 1, therefore balancing the counters.\n\t//    The nodes can now be completely consumed from the linked list.\n\t// 2. Handle nodes that might have gotten resolved between render and\n\t//    componentDidMount.\n\tthis._map.forEach((node, child) => {\n\t\tresolve(this, child, node);\n\t});\n};\n","import { createElement, hydrate, render, __u as _unmount } from 'preact';\n\nfunction ContextProvider(props) {\n\tthis.getChildContext = () => props.context;\n\treturn props.children;\n}\n\n/**\n * Portal component\n * @param {object | null | undefined} props\n *\n * TODO: this could use the \"fake root node\" trick from the partial hydration demo\n */\nfunction Portal(props) {\n\tconst _this = this;\n\tlet container = props._container;\n\tlet wrap = createElement(\n\t\tContextProvider,\n\t\t{ context: _this.context },\n\t\tprops._vnode\n\t);\n\n\t_this.componentWillUnmount = function() {\n\t\tlet parent = _this._temp.parentNode;\n\t\tif (parent) parent.removeChild(_this._temp);\n\t\t_unmount(_this._wrap);\n\t};\n\n\t// When we change container we should clear our old container and\n\t// indicate a new mount.\n\tif (_this._container && _this._container !== container) {\n\t\t_this.componentWillUnmount();\n\t\t// if (_this._temp.parentNode) _this._container.removeChild(_this._temp);\n\t\t// _unmount(_this._wrap);\n\t\t_this._hasMounted = false;\n\t}\n\n\t// When props.vnode is undefined/false/null we are dealing with some kind of\n\t// conditional vnode. This should not trigger a render.\n\tif (props._vnode) {\n\t\tif (!_this._hasMounted) {\n\t\t\t// Create a placeholder that we can use to insert into.\n\t\t\t_this._temp = document.createTextNode('');\n\t\t\t// temporarily store the current children of the container to restore them after render\n\t\t\t_this._children = container._children;\n\t\t\t// Hydrate existing nodes to keep the dom intact, when rendering\n\t\t\t// wrap into the container.\n\t\t\thydrate('', container);\n\t\t\t// Append to the container (this matches React's behavior)\n\t\t\tcontainer.appendChild(_this._temp);\n\t\t\t// At this point we have mounted and should set our container.\n\t\t\t_this._hasMounted = true;\n\t\t\t_this._container = container;\n\t\t\t// Render our wrapping element into temp.\n\t\t\trender(wrap, container, _this._temp);\n\t\t\t// restore the previous children of the container\n\t\t\tcontainer._children = _this._children;\n\t\t\t// store the children of the new vnode to be used in subsequent re-renders\n\t\t\t_this._children = _this._temp._children;\n\t\t} else {\n\t\t\t// When we have mounted and the vnode is present it means the\n\t\t\t// props have changed or a parent is triggering a rerender.\n\t\t\t// This implies we only need to call render. But we need to keep\n\t\t\t// the old tree around, otherwise will treat the vnodes as new and\n\t\t\t// will wrongly call `componentDidMount` on them\n\t\t\tcontainer._children = _this._children;\n\t\t\trender(wrap, container);\n\t\t\t_this._children = container._children;\n\t\t}\n\t}\n\t// When we come from a conditional render, on a mounted\n\t// portal we should clear the DOM.\n\telse if (_this._hasMounted) {\n\t\t_this.componentWillUnmount();\n\t\t// if (_this._temp.parentNode) _this._container.removeChild(_this._temp);\n\t\t// _unmount(_this._wrap);\n\t}\n\t// Set the wrapping element for future unmounting.\n\t_this._wrap = wrap;\n}\n\n/**\n * Create a `Portal` to continue rendering the vnode tree at a different DOM node\n * @param {import('./internal').VNode} vnode The vnode to render\n * @param {import('./internal').PreactElement} container The DOM node to continue rendering in to.\n */\nexport function createPortal(vnode, container) {\n\treturn createElement(Portal, { _vnode: vnode, _container: container });\n}\n","import {\n\trender as preactRender,\n\thydrate as preactHydrate,\n\toptions,\n\ttoChildArray,\n\tComponent\n} from 'preact';\n\nexport const REACT_ELEMENT_TYPE =\n\t(typeof Symbol != 'undefined' && Symbol.for && Symbol.for('react.element')) ||\n\t0xeac7;\n\nconst CAMEL_PROPS = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;\n\n// Input types for which onchange should not be converted to oninput.\n// type=\"file|checkbox|radio\", plus \"range\" in IE11.\n// (IE11 doesn't support Symbol, which we use here to turn `rad` into `ra` which matches \"range\")\nconst ONCHANGE_INPUT_TYPES =\n\ttypeof Symbol != 'undefined' ? /fil|che|rad/i : /fil|che|ra/i;\n\n// Some libraries like `react-virtualized` explicitly check for this.\nComponent.prototype.isReactComponent = {};\n\n// `UNSAFE_*` lifecycle hooks\n// Preact only ever invokes the unprefixed methods.\n// Here we provide a base \"fallback\" implementation that calls any defined UNSAFE_ prefixed method.\n// - If a component defines its own `componentDidMount()` (including via defineProperty), use that.\n// - If a component defines `UNSAFE_componentDidMount()`, `componentDidMount` is the alias getter/setter.\n// - If anything assigns to an `UNSAFE_*` property, the assignment is forwarded to the unprefixed property.\n// See https://github.com/preactjs/preact/issues/1941\n[\n\t'componentWillMount',\n\t'componentWillReceiveProps',\n\t'componentWillUpdate'\n].forEach(key => {\n\tObject.defineProperty(Component.prototype, key, {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn this['UNSAFE_' + key];\n\t\t},\n\t\tset(v) {\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: v\n\t\t\t});\n\t\t}\n\t});\n});\n\n/**\n * Proxy render() since React returns a Component reference.\n * @param {import('./internal').VNode} vnode VNode tree to render\n * @param {import('./internal').PreactElement} parent DOM node to render vnode tree into\n * @param {() => void} [callback] Optional callback that will be called after rendering\n * @returns {import('./internal').Component | null} The root component reference or null\n */\nexport function render(vnode, parent, callback) {\n\t// React destroys any existing DOM nodes, see #1727\n\t// ...but only on the first render, see #1828\n\tif (parent._children == null) {\n\t\tparent.textContent = '';\n\t}\n\n\tpreactRender(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nexport function hydrate(vnode, parent, callback) {\n\tpreactHydrate(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nlet oldEventHook = options.event;\noptions.event = e => {\n\tif (oldEventHook) e = oldEventHook(e);\n\te.persist = empty;\n\te.isPropagationStopped = isPropagationStopped;\n\te.isDefaultPrevented = isDefaultPrevented;\n\treturn (e.nativeEvent = e);\n};\n\nfunction empty() {}\n\nfunction isPropagationStopped() {\n\treturn this.cancelBubble;\n}\n\nfunction isDefaultPrevented() {\n\treturn this.defaultPrevented;\n}\n\nlet classNameDescriptor = {\n\tconfigurable: true,\n\tget() {\n\t\treturn this.class;\n\t}\n};\n\nlet oldVNodeHook = options.vnode;\noptions.vnode = vnode => {\n\tvnode.$$typeof = REACT_ELEMENT_TYPE;\n\n\tlet type = vnode.type;\n\tlet props = vnode.props;\n\n\tconst isComponent = typeof type == 'function';\n\tif (isComponent) {\n\t\tif ((classNameDescriptor.enumerable = 'className' in props)) {\n\t\t\tprops.class = props.className;\n\t\t}\n\t\tObject.defineProperty(props, 'className', classNameDescriptor);\n\t} else if (type) {\n\t\tlet normalizedProps = {};\n\n\t\tfor (let i in props) {\n\t\t\tlet value = props[i];\n\n\t\t\t// Alias `class` prop to `className` if available\n\t\t\tif (i === 'className') {\n\t\t\t\tnormalizedProps.class = value;\n\t\t\t\tclassNameDescriptor.enumerable = true;\n\t\t\t}\n\n\t\t\tif (i === 'defaultValue' && 'value' in props && props.value == null) {\n\t\t\t\t// `defaultValue` is treated as a fallback `value` when a value prop is present but null/undefined.\n\t\t\t\t// `defaultValue` for Elements with no value prop is the same as the DOM defaultValue property.\n\t\t\t\ti = 'value';\n\t\t\t} else if (i === 'download' && value === true) {\n\t\t\t\t// Calling `setAttribute` with a truthy value will lead to it being\n\t\t\t\t// passed as a stringified value, e.g. `download=\"true\"`. React\n\t\t\t\t// converts it to an empty string instead, otherwise the attribute\n\t\t\t\t// value will be used as the file name and the file will be called\n\t\t\t\t// \"true\" upon downloading it.\n\t\t\t\tvalue = '';\n\t\t\t} else if (/ondoubleclick/i.test(i)) {\n\t\t\t\ti = 'ondblclick';\n\t\t\t} else if (\n\t\t\t\t/^onchange(textarea|input)/i.test(i + type) &&\n\t\t\t\t!ONCHANGE_INPUT_TYPES.test(props.type)\n\t\t\t) {\n\t\t\t\ti = 'oninput';\n\t\t\t} else if (/^on(Ani|Tra|Tou|BeforeInp)/.test(i)) {\n\t\t\t\ti = i.toLowerCase();\n\t\t\t} else if (CAMEL_PROPS.test(i)) {\n\t\t\t\ti = i.replace(/[A-Z0-9]/, '-$&').toLowerCase();\n\t\t\t} else if (value === null) {\n\t\t\t\tvalue = undefined;\n\t\t\t}\n\n\t\t\tnormalizedProps[i] = value;\n\t\t}\n\n\t\tObject.defineProperty(normalizedProps, 'className', classNameDescriptor);\n\n\t\t// Add support for array select values: <select multiple value={[]} />\n\t\tif (\n\t\t\ttype == 'select' &&\n\t\t\tnormalizedProps.multiple &&\n\t\t\tArray.isArray(normalizedProps.value)\n\t\t) {\n\t\t\t// forEach() always returns undefined, which we abuse here to unset the value prop.\n\t\t\tnormalizedProps.value = toChildArray(props.children).forEach(child => {\n\t\t\t\tchild.props.selected =\n\t\t\t\t\tnormalizedProps.value.indexOf(child.props.value) != -1;\n\t\t\t});\n\t\t}\n\n\t\tvnode.props = normalizedProps;\n\t}\n\n\tif (oldVNodeHook) oldVNodeHook(vnode);\n};\n\n// Only needed for react-relay\nlet currentComponent;\nconst oldBeforeRender = options._render;\noptions._render = function(vnode) {\n\tif (oldBeforeRender) {\n\t\toldBeforeRender(vnode);\n\t}\n\tcurrentComponent = vnode._component;\n};\n\n// This is a very very private internal function for React it\n// is used to sort-of do runtime dependency injection. So far\n// only `react-relay` makes use of it. It uses it to read the\n// context value.\nexport const __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = {\n\tReactCurrentDispatcher: {\n\t\tcurrent: {\n\t\t\treadContext(context) {\n\t\t\t\treturn currentComponent._globalContext[context._id].props.value;\n\t\t\t}\n\t\t}\n\t}\n};\n","import {\n\tcreateElement,\n\trender as preactRender,\n\tcloneElement as preactCloneElement,\n\tcreateRef,\n\tComponent,\n\tcreateContext,\n\tFragment\n} from 'preact';\nimport {\n\tuseState,\n\tuseReducer,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseRef,\n\tuseImperativeHandle,\n\tuseMemo,\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue\n} from 'preact/hooks';\nimport { PureComponent } from './PureComponent';\nimport { memo } from './memo';\nimport { forwardRef } from './forwardRef';\nimport { Children } from './Children';\nimport { Suspense, lazy } from './suspense';\nimport { SuspenseList } from './suspense-list';\nimport { createPortal } from './portals';\nimport {\n\thydrate,\n\trender,\n\tREACT_ELEMENT_TYPE,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n} from './render';\n\nconst version = '16.8.0'; // trick libraries to think we are react\n\n/**\n * Legacy version of createElement.\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component constructor\n */\nfunction createFactory(type) {\n\treturn createElement.bind(null, type);\n}\n\n/**\n * Check if the passed element is a valid (p)react node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isValidElement(element) {\n\treturn !!element && element.$$typeof === REACT_ELEMENT_TYPE;\n}\n\n/**\n * Wrap `cloneElement` to abort if the passed element is not a valid element and apply\n * all vnode normalizations.\n * @param {import('./internal').VNode} element The vnode to clone\n * @param {object} props Props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Optional component children\n */\nfunction cloneElement(element) {\n\tif (!isValidElement(element)) return element;\n\treturn preactCloneElement.apply(null, arguments);\n}\n\n/**\n * Remove a component tree from the DOM, including state and event handlers.\n * @param {import('./internal').PreactElement} container\n * @returns {boolean}\n */\nfunction unmountComponentAtNode(container) {\n\tif (container._children) {\n\t\tpreactRender(null, container);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**\n * Get the matching DOM node for a component\n * @param {import('./internal').Component} component\n * @returns {import('./internal').PreactElement | null}\n */\nfunction findDOMNode(component) {\n\treturn (\n\t\t(component &&\n\t\t\t(component.base || (component.nodeType === 1 && component))) ||\n\t\tnull\n\t);\n}\n\n/**\n * Deprecated way to control batched rendering inside the reconciler, but we\n * already schedule in batches inside our rendering code\n * @template Arg\n * @param {(arg: Arg) => void} callback function that triggers the updated\n * @param {Arg} [arg] Optional argument that can be passed to the callback\n */\n// eslint-disable-next-line camelcase\nconst unstable_batchedUpdates = (callback, arg) => callback(arg);\n\n/**\n * Strict Mode is not implemented in Preact, so we provide a stand-in for it\n * that just renders its children without imposing any restrictions.\n */\nconst StrictMode = Fragment;\n\nexport * from 'preact/hooks';\nexport {\n\tversion,\n\tChildren,\n\trender,\n\thydrate,\n\tunmountComponentAtNode,\n\tcreatePortal,\n\tcreateElement,\n\tcreateContext,\n\tcreateFactory,\n\tcloneElement,\n\tcreateRef,\n\tFragment,\n\tisValidElement,\n\tfindDOMNode,\n\tComponent,\n\tPureComponent,\n\tmemo,\n\tforwardRef,\n\t// eslint-disable-next-line camelcase\n\tunstable_batchedUpdates,\n\tStrictMode,\n\tSuspense,\n\tSuspenseList,\n\tlazy,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n\n// React copies the named exports to the default one.\nexport default {\n\tuseState,\n\tuseReducer,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseRef,\n\tuseImperativeHandle,\n\tuseMemo,\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue,\n\tversion,\n\tChildren,\n\trender,\n\thydrate,\n\tunmountComponentAtNode,\n\tcreatePortal,\n\tcreateElement,\n\tcreateContext,\n\tcreateFactory,\n\tcloneElement,\n\tcreateRef,\n\tFragment,\n\tisValidElement,\n\tfindDOMNode,\n\tComponent,\n\tPureComponent,\n\tmemo,\n\tforwardRef,\n\tunstable_batchedUpdates,\n\tStrictMode,\n\tSuspense,\n\tSuspenseList,\n\tlazy,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n"],"names":["assign","obj","props","i","shallowDiffers","a","b","PureComponent","p","memo","c","comparer","shouldUpdate","nextProps","ref","this","updateRef","call","current","Memoed","shouldComponentUpdate","createElement","displayName","name","prototype","isReactComponent","Component","isPureReactComponent","state","oldDiffHook","options","vnode","type","REACT_FORWARD_SYMBOL","Symbol","for","forwardRef","fn","Forwarded","clone","$$typeof","render","mapFn","children","toChildArray","map","Children","forEach","count","length","only","normalized","toArray","oldCatchError","detachedClone","removeOriginal","Suspense","_suspenders","suspended","component","_suspended","lazy","loader","prom","error","Lazy","then","exports","default","e","SuspenseList","_next","_map","newVNode","oldVNode","promise","suspendingComponent","push","resolve","resolved","onResolved","componentWillUnmount","onSuspensionComplete","setState","pop","forceUpdate","Fragment","fallback","list","child","node","delete","revealOrder","size","ContextProvider","getChildContext","context","Portal","_this","container","_container","wrap","parent","_temp","parentNode","removeChild","_unmount","_wrap","_hasMounted","document","createTextNode","hydrate","appendChild","createPortal","delegated","get","unsuspend","wrappedUnsuspend","Map","reverse","set","componentDidUpdate","componentDidMount","REACT_ELEMENT_TYPE","CAMEL_PROPS","ONCHANGE_INPUT_TYPES","callback","textContent","preactRender","preactHydrate","key","Object","defineProperty","configurable","v","writable","value","oldEventHook","event","empty","isPropagationStopped","cancelBubble","isDefaultPrevented","defaultPrevented","persist","nativeEvent","currentComponent","classNameDescriptor","class","oldVNodeHook","enumerable","className","normalizedProps","test","toLowerCase","replace","undefined","multiple","Array","isArray","selected","indexOf","oldBeforeRender","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentDispatcher","readContext","createFactory","bind","isValidElement","element","cloneElement","preactCloneElement","apply","arguments","unmountComponentAtNode","findDOMNode","base","nodeType","unstable_batchedUpdates","arg","StrictMode","useState","useReducer","useEffect","useLayoutEffect","useRef","useImperativeHandle","useMemo","useCallback","useContext","useDebugValue","version","createContext","createRef"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/preact/compat/dist/compat.mjs b/node_modules/preact/compat/dist/compat.mjs
index 1b0477f..1c1b784 100644
--- a/node_modules/preact/compat/dist/compat.mjs
+++ b/node_modules/preact/compat/dist/compat.mjs
@@ -1,2 +1,2 @@
-import{useState as n,useReducer as t,useEffect as e,useLayoutEffect as r,useRef as o,useImperativeHandle as u,useMemo as i,useCallback as f,useContext as c,useDebugValue as a}from"preact/hooks";export*from"preact/hooks";import{Component as l,createElement as s,options as v,toChildArray as h,Fragment as d,hydrate as p,render as m,__u as _,cloneElement as y,createRef as b,createContext as E}from"preact";export{createElement,createContext,createRef,Fragment,Component}from"preact";function S(n,t){for(var e in t)n[e]=t[e];return n}function C(n,t){for(var e in n)if("__source"!==e&&!(e in t))return!0;for(var r in t)if("__source"!==r&&n[r]!==t[r])return!0;return!1}function R(n){this.props=n}function w(n,t){function e(n){var e=this.props.ref,r=e==n.ref;return!r&&e&&(e.call?e(null):e.current=null),t?!t(this.props,n)||!r:C(this.props,n)}function r(t){return this.shouldComponentUpdate=e,s(n,t)}return r.displayName="Memo("+(n.displayName||n.name)+")",r.prototype.isReactComponent=!0,r.__f=!0,r}(R.prototype=new l).isPureReactComponent=!0,R.prototype.shouldComponentUpdate=function(n,t){return C(this.props,n)||C(this.state,t)};var x=v.__b;v.__b=function(n){n.type&&n.type.__f&&n.ref&&(n.props.ref=n.ref,n.ref=null),x&&x(n)};var g="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.forward_ref")||3911;function A(n){function t(t,e){var r=S({},t);return delete r.ref,n(r,(e=t.ref||e)&&("object"!=typeof e||"current"in e)?e:null)}return t.$$typeof=g,t.render=t,t.prototype.isReactComponent=t.__f=!0,t.displayName="ForwardRef("+(n.displayName||n.name)+")",t}var N=function(n,t){return n?h(h(n).map(t)):null},U={map:N,forEach:N,count:function(n){return n?h(n).length:0},only:function(n){var t=h(n);if(1!==t.length)throw"Children.only";return t[0]},toArray:h},F=v.__e;function k(n){return n&&((n=S({},n)).__c=null,n.__k=n.__k&&n.__k.map(k)),n}function L(n){return n&&(n.__v=null,n.__k=n.__k&&n.__k.map(L)),n}function O(){this.__u=0,this.t=null,this.__b=null}function M(n){var t=n.__.__c;return t&&t.o&&t.o(n)}function D(n){var t,e,r;function o(o){if(t||(t=n()).then(function(n){e=n.default||n},function(n){r=n}),r)throw r;if(!e)throw t;return s(e,o)}return o.displayName="Lazy",o.__f=!0,o}function T(){this.u=null,this.i=null}v.__e=function(n,t,e){if(n.then)for(var r,o=t;o=o.__;)if((r=o.__c)&&r.__c)return null==t.__e&&(t.__e=e.__e,t.__k=e.__k),r.__c(n,t.__c);F(n,t,e)},(O.prototype=new l).__c=function(n,t){var e=this;null==e.t&&(e.t=[]),e.t.push(t);var r=M(e.__v),o=!1,u=function(){o||(o=!0,t.componentWillUnmount=t.__c,r?r(i):i())};t.__c=t.componentWillUnmount,t.componentWillUnmount=function(){u(),t.__c&&t.__c()};var i=function(){var n;if(!--e.__u)for(e.__v.__k[0]=L(e.state.o),e.setState({o:e.__b=null});n=e.t.pop();)n.forceUpdate()};e.__u++||e.setState({o:e.__b=e.__v.__k[0]}),n.then(u,u)},O.prototype.componentWillUnmount=function(){this.t=[]},O.prototype.render=function(n,t){return this.__b&&(this.__v.__k&&(this.__v.__k[0]=k(this.__b)),this.__b=null),[s(d,null,t.o?null:n.children),t.o&&n.fallback]};var W=function(n,t,e){if(++e[1]===e[0]&&n.i.delete(t),n.props.revealOrder&&("t"!==n.props.revealOrder[0]||!n.i.size))for(e=n.u;e;){for(;e.length>3;)e.pop()();if(e[1]<e[0])break;n.u=e=e[2]}};function I(n){return this.getChildContext=function(){return n.context},n.children}function P(n){var t=this,e=n.l,r=s(I,{context:t.context},n.__v);t.componentWillUnmount=function(){var n=t.s.parentNode;n&&n.removeChild(t.s),_(t.v)},t.l&&t.l!==e&&(t.componentWillUnmount(),t.h=!1),n.__v?t.h?(e.__k=t.__k,m(r,e),t.__k=e.__k):(t.s=document.createTextNode(""),t.__k=e.__k,p("",e),e.appendChild(t.s),t.h=!0,t.l=e,m(r,e,t.s),e.__k=t.__k,t.__k=t.s.__k):t.h&&t.componentWillUnmount(),t.v=r}function j(n,t){return s(P,{__v:n,l:t})}(T.prototype=new l).o=function(n){var t=this,e=M(t.__v),r=t.i.get(n);return r[0]++,function(o){var u=function(){t.props.revealOrder?(r.push(o),W(t,n,r)):o()};e?e(u):u()}},T.prototype.render=function(n){this.u=null,this.i=new Map;var t=h(n.children);n.revealOrder&&"b"===n.revealOrder[0]&&t.reverse();for(var e=t.length;e--;)this.i.set(t[e],this.u=[1,0,this.u]);return n.children},T.prototype.componentDidUpdate=T.prototype.componentDidMount=function(){var n=this;this.i.forEach(function(t,e){W(n,e,t)})};var z=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;l.prototype.isReactComponent={};var H="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103;function V(n,t,e){if(null==t.__k)for(;t.firstChild;)t.removeChild(t.firstChild);return m(n,t),"function"==typeof e&&e(),n?n.__c:null}function Z(n,t,e){return p(n,t),"function"==typeof e&&e(),n?n.__c:null}var B=v.event;function Y(n,t){n["UNSAFE_"+t]&&!n[t]&&Object.defineProperty(n,t,{get:function(){return this["UNSAFE_"+t]},set:function(n){this["UNSAFE_"+t]=n}})}v.event=function(n){B&&(n=B(n)),n.persist=function(){};var t=!1,e=!1,r=n.stopPropagation;n.stopPropagation=function(){r.call(n),t=!0};var o=n.preventDefault;return n.preventDefault=function(){o.call(n),e=!0},n.isPropagationStopped=function(){return t},n.isDefaultPrevented=function(){return e},n.nativeEvent=n};var $,q={configurable:!0,get:function(){return this.class}},G=v.vnode;v.vnode=function(n){n.$$typeof=H;var t=n.type,e=n.props;if(t){var r;if(e.class!=e.className&&(q.enumerable="className"in e,null!=e.className&&(e.class=e.className),Object.defineProperty(e,"className",q)),"function"!=typeof t)for(r in e.defaultValue&&void 0!==e.value&&(e.value||0===e.value||(e.value=e.defaultValue),e.defaultValue=void 0),"select"===t&&e.multiple&&Array.isArray(e.value)&&(h(e.children).forEach(function(n){-1!=e.value.indexOf(n.props.value)&&(n.props.selected=!0)}),e.value=void 0),!0===e.download&&(e.download=""),e){var o=z.test(r);o&&(n.props[r.replace(/[A-Z0-9]/,"-$&").toLowerCase()]=e[r]),(o||null===e[r])&&(e[r]=void 0)}else t.prototype&&!t.prototype.p&&(t.prototype.p=!0,Y(t.prototype,"componentWillMount"),Y(t.prototype,"componentWillReceiveProps"),Y(t.prototype,"componentWillUpdate"));!function(t){var e=n.type,r=n.props;if(r&&"string"==typeof e){var o={};for(var u in r)/^on(Ani|Tra|Tou)/.test(u)&&(r[u.toLowerCase()]=r[u],delete r[u]),o[u.toLowerCase()]=u;if(o.ondoubleclick&&(r.ondblclick=r[o.ondoubleclick],delete r[o.ondoubleclick]),o.onbeforeinput&&(r.onbeforeinput=r[o.onbeforeinput],delete r[o.onbeforeinput]),o.onchange&&("textarea"===e||"input"===e.toLowerCase()&&!/^fil|che|ra/i.test(r.type))){var i=o.oninput||"oninput";r[i]||(r[i]=r[o.onchange],delete r[o.onchange])}}}()}G&&G(n)};var J=v.__r;v.__r=function(n){J&&J(n),$=n.__c};var K={ReactCurrentDispatcher:{current:{readContext:function(n){return $.__n[n.__c].props.value}}}},Q="16.8.0";function X(n){return s.bind(null,n)}function nn(n){return!!n&&n.$$typeof===H}function tn(n){return nn(n)?y.apply(null,arguments):n}function en(n){return!!n.__k&&(m(null,n),!0)}function rn(n){return n&&(n.base||1===n.nodeType&&n)||null}var on=function(n,t){return n(t)},un=d;export default{useState:n,useReducer:t,useEffect:e,useLayoutEffect:r,useRef:o,useImperativeHandle:u,useMemo:i,useCallback:f,useContext:c,useDebugValue:a,version:"16.8.0",Children:U,render:V,hydrate:Z,unmountComponentAtNode:en,createPortal:j,createElement:s,createContext:E,createFactory:X,cloneElement:tn,createRef:b,Fragment:d,isValidElement:nn,findDOMNode:rn,Component:l,PureComponent:R,memo:w,forwardRef:A,unstable_batchedUpdates:on,StrictMode:d,Suspense:O,SuspenseList:T,lazy:D,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:K};export{Q as version,U as Children,V as render,Z as hydrate,en as unmountComponentAtNode,j as createPortal,X as createFactory,tn as cloneElement,nn as isValidElement,rn as findDOMNode,R as PureComponent,w as memo,A as forwardRef,on as unstable_batchedUpdates,un as StrictMode,O as Suspense,T as SuspenseList,D as lazy,K as __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED};
+import{useState as n,useReducer as t,useEffect as e,useLayoutEffect as r,useRef as u,useImperativeHandle as o,useMemo as i,useCallback as c,useContext as f,useDebugValue as l}from"preact/hooks";export*from"preact/hooks";import{Component as a,createElement as s,options as h,toChildArray as v,Fragment as d,hydrate as p,render as m,__u as b,cloneElement as y,createRef as _,createContext as E}from"preact";export{createElement,createContext,createRef,Fragment,Component}from"preact";function S(n,t){for(var e in t)n[e]=t[e];return n}function w(n,t){for(var e in n)if("__source"!==e&&!(e in t))return!0;for(var r in t)if("__source"!==r&&n[r]!==t[r])return!0;return!1}function C(n){this.props=n}function g(n,t){function e(n){var e=this.props.ref,r=e==n.ref;return!r&&e&&(e.call?e(null):e.current=null),t?!t(this.props,n)||!r:w(this.props,n)}function r(t){return this.shouldComponentUpdate=e,s(n,t)}return r.displayName="Memo("+(n.displayName||n.name)+")",r.prototype.isReactComponent=!0,r.__f=!0,r}(C.prototype=new a).isPureReactComponent=!0,C.prototype.shouldComponentUpdate=function(n,t){return w(this.props,n)||w(this.state,t)};var R=h.__b;h.__b=function(n){n.type&&n.type.__f&&n.ref&&(n.props.ref=n.ref,n.ref=null),R&&R(n)};var x="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.forward_ref")||3911;function N(n){function t(t,e){var r=S({},t);return delete r.ref,n(r,(e=t.ref||e)&&("object"!=typeof e||"current"in e)?e:null)}return t.$$typeof=x,t.render=t,t.prototype.isReactComponent=t.__f=!0,t.displayName="ForwardRef("+(n.displayName||n.name)+")",t}var k=function(n,t){return null==n?null:v(v(n).map(t))},O={map:k,forEach:k,count:function(n){return n?v(n).length:0},only:function(n){var t=v(n);if(1!==t.length)throw"Children.only";return t[0]},toArray:v},A=h.__e;function L(n){return n&&((n=S({},n)).__c=null,n.__k=n.__k&&n.__k.map(L)),n}function U(n){return n&&(n.__v=null,n.__k=n.__k&&n.__k.map(U)),n}function F(){this.__u=0,this.t=null,this.__b=null}function M(n){var t=n.__.__c;return t&&t.u&&t.u(n)}function j(n){var t,e,r;function u(u){if(t||(t=n()).then(function(n){e=n.default||n},function(n){r=n}),r)throw r;if(!e)throw t;return s(e,u)}return u.displayName="Lazy",u.__f=!0,u}function D(){this.o=null,this.i=null}h.__e=function(n,t,e){if(n.then)for(var r,u=t;u=u.__;)if((r=u.__c)&&r.__c)return null==t.__e&&(t.__e=e.__e,t.__k=e.__k),r.__c(n,t.__c);A(n,t,e)},(F.prototype=new a).__c=function(n,t){var e=this;null==e.t&&(e.t=[]),e.t.push(t);var r=M(e.__v),u=!1,o=function(){u||(u=!0,t.componentWillUnmount=t.__c,r?r(i):i())};t.__c=t.componentWillUnmount,t.componentWillUnmount=function(){o(),t.__c&&t.__c()};var i=function(){var n;if(!--e.__u)for(e.__v.__k[0]=U(e.state.u),e.setState({u:e.__b=null});n=e.t.pop();)n.forceUpdate()};e.__u++||e.setState({u:e.__b=e.__v.__k[0]}),n.then(o,o)},F.prototype.componentWillUnmount=function(){this.t=[]},F.prototype.render=function(n,t){return this.__b&&(this.__v.__k&&(this.__v.__k[0]=L(this.__b)),this.__b=null),[s(d,null,t.u?null:n.children),t.u&&n.fallback]};var I=function(n,t,e){if(++e[1]===e[0]&&n.i.delete(t),n.props.revealOrder&&("t"!==n.props.revealOrder[0]||!n.i.size))for(e=n.o;e;){for(;e.length>3;)e.pop()();if(e[1]<e[0])break;n.o=e=e[2]}};function T(n){return this.getChildContext=function(){return n.context},n.children}function W(n){var t=this,e=n.l,r=s(T,{context:t.context},n.__v);t.componentWillUnmount=function(){var n=t.s.parentNode;n&&n.removeChild(t.s),b(t.h)},t.l&&t.l!==e&&(t.componentWillUnmount(),t.v=!1),n.__v?t.v?(e.__k=t.__k,m(r,e),t.__k=e.__k):(t.s=document.createTextNode(""),t.__k=e.__k,p("",e),e.appendChild(t.s),t.v=!0,t.l=e,m(r,e,t.s),e.__k=t.__k,t.__k=t.s.__k):t.v&&t.componentWillUnmount(),t.h=r}function P(n,t){return s(W,{__v:n,l:t})}(D.prototype=new a).u=function(n){var t=this,e=M(t.__v),r=t.i.get(n);return r[0]++,function(u){var o=function(){t.props.revealOrder?(r.push(u),I(t,n,r)):u()};e?e(o):o()}},D.prototype.render=function(n){this.o=null,this.i=new Map;var t=v(n.children);n.revealOrder&&"b"===n.revealOrder[0]&&t.reverse();for(var e=t.length;e--;)this.i.set(t[e],this.o=[1,0,this.o]);return n.children},D.prototype.componentDidUpdate=D.prototype.componentDidMount=function(){var n=this;this.i.forEach(function(t,e){I(n,e,t)})};var z="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103,V=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,B="undefined"!=typeof Symbol?/fil|che|rad/i:/fil|che|ra/i;function H(n,t,e){return null==t.__k&&(t.textContent=""),m(n,t),"function"==typeof e&&e(),n?n.__c:null}function Z(n,t,e){return p(n,t),"function"==typeof e&&e(),n?n.__c:null}a.prototype.isReactComponent={},["componentWillMount","componentWillReceiveProps","componentWillUpdate"].forEach(function(n){Object.defineProperty(a.prototype,n,{configurable:!0,get:function(){return this["UNSAFE_"+n]},set:function(t){Object.defineProperty(this,n,{configurable:!0,writable:!0,value:t})}})});var Y=h.event;function $(){}function q(){return this.cancelBubble}function G(){return this.defaultPrevented}h.event=function(n){return Y&&(n=Y(n)),n.persist=$,n.isPropagationStopped=q,n.isDefaultPrevented=G,n.nativeEvent=n};var J,K={configurable:!0,get:function(){return this.class}},Q=h.vnode;h.vnode=function(n){n.$$typeof=z;var t=n.type,e=n.props;if("function"==typeof t)(K.enumerable="className"in e)&&(e.class=e.className),Object.defineProperty(e,"className",K);else if(t){var r={};for(var u in e){var o=e[u];"className"===u&&(r.class=o,K.enumerable=!0),"defaultValue"===u&&"value"in e&&null==e.value?u="value":"download"===u&&!0===o?o="":/ondoubleclick/i.test(u)?u="ondblclick":/^onchange(textarea|input)/i.test(u+t)&&!B.test(e.type)?u="oninput":/^on(Ani|Tra|Tou|BeforeInp)/.test(u)?u=u.toLowerCase():V.test(u)?u=u.replace(/[A-Z0-9]/,"-$&").toLowerCase():null===o&&(o=void 0),r[u]=o}Object.defineProperty(r,"className",K),"select"==t&&r.multiple&&Array.isArray(r.value)&&(r.value=v(e.children).forEach(function(n){n.props.selected=-1!=r.value.indexOf(n.props.value)})),n.props=r}Q&&Q(n)};var X=h.__r;h.__r=function(n){X&&X(n),J=n.__c};var nn={ReactCurrentDispatcher:{current:{readContext:function(n){return J.__n[n.__c].props.value}}}},tn="16.8.0";function en(n){return s.bind(null,n)}function rn(n){return!!n&&n.$$typeof===z}function un(n){return rn(n)?y.apply(null,arguments):n}function on(n){return!!n.__k&&(m(null,n),!0)}function cn(n){return n&&(n.base||1===n.nodeType&&n)||null}var fn=function(n,t){return n(t)},ln=d;export default{useState:n,useReducer:t,useEffect:e,useLayoutEffect:r,useRef:u,useImperativeHandle:o,useMemo:i,useCallback:c,useContext:f,useDebugValue:l,version:"16.8.0",Children:O,render:H,hydrate:Z,unmountComponentAtNode:on,createPortal:P,createElement:s,createContext:E,createFactory:en,cloneElement:un,createRef:_,Fragment:d,isValidElement:rn,findDOMNode:cn,Component:a,PureComponent:C,memo:g,forwardRef:N,unstable_batchedUpdates:fn,StrictMode:d,Suspense:F,SuspenseList:D,lazy:j,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:nn};export{tn as version,O as Children,H as render,Z as hydrate,on as unmountComponentAtNode,P as createPortal,en as createFactory,un as cloneElement,rn as isValidElement,cn as findDOMNode,C as PureComponent,g as memo,N as forwardRef,fn as unstable_batchedUpdates,ln as StrictMode,F as Suspense,D as SuspenseList,j as lazy,nn as __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED};
 //# sourceMappingURL=compat.module.js.map
diff --git a/node_modules/preact/compat/dist/compat.module.js b/node_modules/preact/compat/dist/compat.module.js
index 1b0477f..1c1b784 100644
--- a/node_modules/preact/compat/dist/compat.module.js
+++ b/node_modules/preact/compat/dist/compat.module.js
@@ -1,2 +1,2 @@
-import{useState as n,useReducer as t,useEffect as e,useLayoutEffect as r,useRef as o,useImperativeHandle as u,useMemo as i,useCallback as f,useContext as c,useDebugValue as a}from"preact/hooks";export*from"preact/hooks";import{Component as l,createElement as s,options as v,toChildArray as h,Fragment as d,hydrate as p,render as m,__u as _,cloneElement as y,createRef as b,createContext as E}from"preact";export{createElement,createContext,createRef,Fragment,Component}from"preact";function S(n,t){for(var e in t)n[e]=t[e];return n}function C(n,t){for(var e in n)if("__source"!==e&&!(e in t))return!0;for(var r in t)if("__source"!==r&&n[r]!==t[r])return!0;return!1}function R(n){this.props=n}function w(n,t){function e(n){var e=this.props.ref,r=e==n.ref;return!r&&e&&(e.call?e(null):e.current=null),t?!t(this.props,n)||!r:C(this.props,n)}function r(t){return this.shouldComponentUpdate=e,s(n,t)}return r.displayName="Memo("+(n.displayName||n.name)+")",r.prototype.isReactComponent=!0,r.__f=!0,r}(R.prototype=new l).isPureReactComponent=!0,R.prototype.shouldComponentUpdate=function(n,t){return C(this.props,n)||C(this.state,t)};var x=v.__b;v.__b=function(n){n.type&&n.type.__f&&n.ref&&(n.props.ref=n.ref,n.ref=null),x&&x(n)};var g="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.forward_ref")||3911;function A(n){function t(t,e){var r=S({},t);return delete r.ref,n(r,(e=t.ref||e)&&("object"!=typeof e||"current"in e)?e:null)}return t.$$typeof=g,t.render=t,t.prototype.isReactComponent=t.__f=!0,t.displayName="ForwardRef("+(n.displayName||n.name)+")",t}var N=function(n,t){return n?h(h(n).map(t)):null},U={map:N,forEach:N,count:function(n){return n?h(n).length:0},only:function(n){var t=h(n);if(1!==t.length)throw"Children.only";return t[0]},toArray:h},F=v.__e;function k(n){return n&&((n=S({},n)).__c=null,n.__k=n.__k&&n.__k.map(k)),n}function L(n){return n&&(n.__v=null,n.__k=n.__k&&n.__k.map(L)),n}function O(){this.__u=0,this.t=null,this.__b=null}function M(n){var t=n.__.__c;return t&&t.o&&t.o(n)}function D(n){var t,e,r;function o(o){if(t||(t=n()).then(function(n){e=n.default||n},function(n){r=n}),r)throw r;if(!e)throw t;return s(e,o)}return o.displayName="Lazy",o.__f=!0,o}function T(){this.u=null,this.i=null}v.__e=function(n,t,e){if(n.then)for(var r,o=t;o=o.__;)if((r=o.__c)&&r.__c)return null==t.__e&&(t.__e=e.__e,t.__k=e.__k),r.__c(n,t.__c);F(n,t,e)},(O.prototype=new l).__c=function(n,t){var e=this;null==e.t&&(e.t=[]),e.t.push(t);var r=M(e.__v),o=!1,u=function(){o||(o=!0,t.componentWillUnmount=t.__c,r?r(i):i())};t.__c=t.componentWillUnmount,t.componentWillUnmount=function(){u(),t.__c&&t.__c()};var i=function(){var n;if(!--e.__u)for(e.__v.__k[0]=L(e.state.o),e.setState({o:e.__b=null});n=e.t.pop();)n.forceUpdate()};e.__u++||e.setState({o:e.__b=e.__v.__k[0]}),n.then(u,u)},O.prototype.componentWillUnmount=function(){this.t=[]},O.prototype.render=function(n,t){return this.__b&&(this.__v.__k&&(this.__v.__k[0]=k(this.__b)),this.__b=null),[s(d,null,t.o?null:n.children),t.o&&n.fallback]};var W=function(n,t,e){if(++e[1]===e[0]&&n.i.delete(t),n.props.revealOrder&&("t"!==n.props.revealOrder[0]||!n.i.size))for(e=n.u;e;){for(;e.length>3;)e.pop()();if(e[1]<e[0])break;n.u=e=e[2]}};function I(n){return this.getChildContext=function(){return n.context},n.children}function P(n){var t=this,e=n.l,r=s(I,{context:t.context},n.__v);t.componentWillUnmount=function(){var n=t.s.parentNode;n&&n.removeChild(t.s),_(t.v)},t.l&&t.l!==e&&(t.componentWillUnmount(),t.h=!1),n.__v?t.h?(e.__k=t.__k,m(r,e),t.__k=e.__k):(t.s=document.createTextNode(""),t.__k=e.__k,p("",e),e.appendChild(t.s),t.h=!0,t.l=e,m(r,e,t.s),e.__k=t.__k,t.__k=t.s.__k):t.h&&t.componentWillUnmount(),t.v=r}function j(n,t){return s(P,{__v:n,l:t})}(T.prototype=new l).o=function(n){var t=this,e=M(t.__v),r=t.i.get(n);return r[0]++,function(o){var u=function(){t.props.revealOrder?(r.push(o),W(t,n,r)):o()};e?e(u):u()}},T.prototype.render=function(n){this.u=null,this.i=new Map;var t=h(n.children);n.revealOrder&&"b"===n.revealOrder[0]&&t.reverse();for(var e=t.length;e--;)this.i.set(t[e],this.u=[1,0,this.u]);return n.children},T.prototype.componentDidUpdate=T.prototype.componentDidMount=function(){var n=this;this.i.forEach(function(t,e){W(n,e,t)})};var z=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;l.prototype.isReactComponent={};var H="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103;function V(n,t,e){if(null==t.__k)for(;t.firstChild;)t.removeChild(t.firstChild);return m(n,t),"function"==typeof e&&e(),n?n.__c:null}function Z(n,t,e){return p(n,t),"function"==typeof e&&e(),n?n.__c:null}var B=v.event;function Y(n,t){n["UNSAFE_"+t]&&!n[t]&&Object.defineProperty(n,t,{get:function(){return this["UNSAFE_"+t]},set:function(n){this["UNSAFE_"+t]=n}})}v.event=function(n){B&&(n=B(n)),n.persist=function(){};var t=!1,e=!1,r=n.stopPropagation;n.stopPropagation=function(){r.call(n),t=!0};var o=n.preventDefault;return n.preventDefault=function(){o.call(n),e=!0},n.isPropagationStopped=function(){return t},n.isDefaultPrevented=function(){return e},n.nativeEvent=n};var $,q={configurable:!0,get:function(){return this.class}},G=v.vnode;v.vnode=function(n){n.$$typeof=H;var t=n.type,e=n.props;if(t){var r;if(e.class!=e.className&&(q.enumerable="className"in e,null!=e.className&&(e.class=e.className),Object.defineProperty(e,"className",q)),"function"!=typeof t)for(r in e.defaultValue&&void 0!==e.value&&(e.value||0===e.value||(e.value=e.defaultValue),e.defaultValue=void 0),"select"===t&&e.multiple&&Array.isArray(e.value)&&(h(e.children).forEach(function(n){-1!=e.value.indexOf(n.props.value)&&(n.props.selected=!0)}),e.value=void 0),!0===e.download&&(e.download=""),e){var o=z.test(r);o&&(n.props[r.replace(/[A-Z0-9]/,"-$&").toLowerCase()]=e[r]),(o||null===e[r])&&(e[r]=void 0)}else t.prototype&&!t.prototype.p&&(t.prototype.p=!0,Y(t.prototype,"componentWillMount"),Y(t.prototype,"componentWillReceiveProps"),Y(t.prototype,"componentWillUpdate"));!function(t){var e=n.type,r=n.props;if(r&&"string"==typeof e){var o={};for(var u in r)/^on(Ani|Tra|Tou)/.test(u)&&(r[u.toLowerCase()]=r[u],delete r[u]),o[u.toLowerCase()]=u;if(o.ondoubleclick&&(r.ondblclick=r[o.ondoubleclick],delete r[o.ondoubleclick]),o.onbeforeinput&&(r.onbeforeinput=r[o.onbeforeinput],delete r[o.onbeforeinput]),o.onchange&&("textarea"===e||"input"===e.toLowerCase()&&!/^fil|che|ra/i.test(r.type))){var i=o.oninput||"oninput";r[i]||(r[i]=r[o.onchange],delete r[o.onchange])}}}()}G&&G(n)};var J=v.__r;v.__r=function(n){J&&J(n),$=n.__c};var K={ReactCurrentDispatcher:{current:{readContext:function(n){return $.__n[n.__c].props.value}}}},Q="16.8.0";function X(n){return s.bind(null,n)}function nn(n){return!!n&&n.$$typeof===H}function tn(n){return nn(n)?y.apply(null,arguments):n}function en(n){return!!n.__k&&(m(null,n),!0)}function rn(n){return n&&(n.base||1===n.nodeType&&n)||null}var on=function(n,t){return n(t)},un=d;export default{useState:n,useReducer:t,useEffect:e,useLayoutEffect:r,useRef:o,useImperativeHandle:u,useMemo:i,useCallback:f,useContext:c,useDebugValue:a,version:"16.8.0",Children:U,render:V,hydrate:Z,unmountComponentAtNode:en,createPortal:j,createElement:s,createContext:E,createFactory:X,cloneElement:tn,createRef:b,Fragment:d,isValidElement:nn,findDOMNode:rn,Component:l,PureComponent:R,memo:w,forwardRef:A,unstable_batchedUpdates:on,StrictMode:d,Suspense:O,SuspenseList:T,lazy:D,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:K};export{Q as version,U as Children,V as render,Z as hydrate,en as unmountComponentAtNode,j as createPortal,X as createFactory,tn as cloneElement,nn as isValidElement,rn as findDOMNode,R as PureComponent,w as memo,A as forwardRef,on as unstable_batchedUpdates,un as StrictMode,O as Suspense,T as SuspenseList,D as lazy,K as __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED};
+import{useState as n,useReducer as t,useEffect as e,useLayoutEffect as r,useRef as u,useImperativeHandle as o,useMemo as i,useCallback as c,useContext as f,useDebugValue as l}from"preact/hooks";export*from"preact/hooks";import{Component as a,createElement as s,options as h,toChildArray as v,Fragment as d,hydrate as p,render as m,__u as b,cloneElement as y,createRef as _,createContext as E}from"preact";export{createElement,createContext,createRef,Fragment,Component}from"preact";function S(n,t){for(var e in t)n[e]=t[e];return n}function w(n,t){for(var e in n)if("__source"!==e&&!(e in t))return!0;for(var r in t)if("__source"!==r&&n[r]!==t[r])return!0;return!1}function C(n){this.props=n}function g(n,t){function e(n){var e=this.props.ref,r=e==n.ref;return!r&&e&&(e.call?e(null):e.current=null),t?!t(this.props,n)||!r:w(this.props,n)}function r(t){return this.shouldComponentUpdate=e,s(n,t)}return r.displayName="Memo("+(n.displayName||n.name)+")",r.prototype.isReactComponent=!0,r.__f=!0,r}(C.prototype=new a).isPureReactComponent=!0,C.prototype.shouldComponentUpdate=function(n,t){return w(this.props,n)||w(this.state,t)};var R=h.__b;h.__b=function(n){n.type&&n.type.__f&&n.ref&&(n.props.ref=n.ref,n.ref=null),R&&R(n)};var x="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.forward_ref")||3911;function N(n){function t(t,e){var r=S({},t);return delete r.ref,n(r,(e=t.ref||e)&&("object"!=typeof e||"current"in e)?e:null)}return t.$$typeof=x,t.render=t,t.prototype.isReactComponent=t.__f=!0,t.displayName="ForwardRef("+(n.displayName||n.name)+")",t}var k=function(n,t){return null==n?null:v(v(n).map(t))},O={map:k,forEach:k,count:function(n){return n?v(n).length:0},only:function(n){var t=v(n);if(1!==t.length)throw"Children.only";return t[0]},toArray:v},A=h.__e;function L(n){return n&&((n=S({},n)).__c=null,n.__k=n.__k&&n.__k.map(L)),n}function U(n){return n&&(n.__v=null,n.__k=n.__k&&n.__k.map(U)),n}function F(){this.__u=0,this.t=null,this.__b=null}function M(n){var t=n.__.__c;return t&&t.u&&t.u(n)}function j(n){var t,e,r;function u(u){if(t||(t=n()).then(function(n){e=n.default||n},function(n){r=n}),r)throw r;if(!e)throw t;return s(e,u)}return u.displayName="Lazy",u.__f=!0,u}function D(){this.o=null,this.i=null}h.__e=function(n,t,e){if(n.then)for(var r,u=t;u=u.__;)if((r=u.__c)&&r.__c)return null==t.__e&&(t.__e=e.__e,t.__k=e.__k),r.__c(n,t.__c);A(n,t,e)},(F.prototype=new a).__c=function(n,t){var e=this;null==e.t&&(e.t=[]),e.t.push(t);var r=M(e.__v),u=!1,o=function(){u||(u=!0,t.componentWillUnmount=t.__c,r?r(i):i())};t.__c=t.componentWillUnmount,t.componentWillUnmount=function(){o(),t.__c&&t.__c()};var i=function(){var n;if(!--e.__u)for(e.__v.__k[0]=U(e.state.u),e.setState({u:e.__b=null});n=e.t.pop();)n.forceUpdate()};e.__u++||e.setState({u:e.__b=e.__v.__k[0]}),n.then(o,o)},F.prototype.componentWillUnmount=function(){this.t=[]},F.prototype.render=function(n,t){return this.__b&&(this.__v.__k&&(this.__v.__k[0]=L(this.__b)),this.__b=null),[s(d,null,t.u?null:n.children),t.u&&n.fallback]};var I=function(n,t,e){if(++e[1]===e[0]&&n.i.delete(t),n.props.revealOrder&&("t"!==n.props.revealOrder[0]||!n.i.size))for(e=n.o;e;){for(;e.length>3;)e.pop()();if(e[1]<e[0])break;n.o=e=e[2]}};function T(n){return this.getChildContext=function(){return n.context},n.children}function W(n){var t=this,e=n.l,r=s(T,{context:t.context},n.__v);t.componentWillUnmount=function(){var n=t.s.parentNode;n&&n.removeChild(t.s),b(t.h)},t.l&&t.l!==e&&(t.componentWillUnmount(),t.v=!1),n.__v?t.v?(e.__k=t.__k,m(r,e),t.__k=e.__k):(t.s=document.createTextNode(""),t.__k=e.__k,p("",e),e.appendChild(t.s),t.v=!0,t.l=e,m(r,e,t.s),e.__k=t.__k,t.__k=t.s.__k):t.v&&t.componentWillUnmount(),t.h=r}function P(n,t){return s(W,{__v:n,l:t})}(D.prototype=new a).u=function(n){var t=this,e=M(t.__v),r=t.i.get(n);return r[0]++,function(u){var o=function(){t.props.revealOrder?(r.push(u),I(t,n,r)):u()};e?e(o):o()}},D.prototype.render=function(n){this.o=null,this.i=new Map;var t=v(n.children);n.revealOrder&&"b"===n.revealOrder[0]&&t.reverse();for(var e=t.length;e--;)this.i.set(t[e],this.o=[1,0,this.o]);return n.children},D.prototype.componentDidUpdate=D.prototype.componentDidMount=function(){var n=this;this.i.forEach(function(t,e){I(n,e,t)})};var z="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103,V=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,B="undefined"!=typeof Symbol?/fil|che|rad/i:/fil|che|ra/i;function H(n,t,e){return null==t.__k&&(t.textContent=""),m(n,t),"function"==typeof e&&e(),n?n.__c:null}function Z(n,t,e){return p(n,t),"function"==typeof e&&e(),n?n.__c:null}a.prototype.isReactComponent={},["componentWillMount","componentWillReceiveProps","componentWillUpdate"].forEach(function(n){Object.defineProperty(a.prototype,n,{configurable:!0,get:function(){return this["UNSAFE_"+n]},set:function(t){Object.defineProperty(this,n,{configurable:!0,writable:!0,value:t})}})});var Y=h.event;function $(){}function q(){return this.cancelBubble}function G(){return this.defaultPrevented}h.event=function(n){return Y&&(n=Y(n)),n.persist=$,n.isPropagationStopped=q,n.isDefaultPrevented=G,n.nativeEvent=n};var J,K={configurable:!0,get:function(){return this.class}},Q=h.vnode;h.vnode=function(n){n.$$typeof=z;var t=n.type,e=n.props;if("function"==typeof t)(K.enumerable="className"in e)&&(e.class=e.className),Object.defineProperty(e,"className",K);else if(t){var r={};for(var u in e){var o=e[u];"className"===u&&(r.class=o,K.enumerable=!0),"defaultValue"===u&&"value"in e&&null==e.value?u="value":"download"===u&&!0===o?o="":/ondoubleclick/i.test(u)?u="ondblclick":/^onchange(textarea|input)/i.test(u+t)&&!B.test(e.type)?u="oninput":/^on(Ani|Tra|Tou|BeforeInp)/.test(u)?u=u.toLowerCase():V.test(u)?u=u.replace(/[A-Z0-9]/,"-$&").toLowerCase():null===o&&(o=void 0),r[u]=o}Object.defineProperty(r,"className",K),"select"==t&&r.multiple&&Array.isArray(r.value)&&(r.value=v(e.children).forEach(function(n){n.props.selected=-1!=r.value.indexOf(n.props.value)})),n.props=r}Q&&Q(n)};var X=h.__r;h.__r=function(n){X&&X(n),J=n.__c};var nn={ReactCurrentDispatcher:{current:{readContext:function(n){return J.__n[n.__c].props.value}}}},tn="16.8.0";function en(n){return s.bind(null,n)}function rn(n){return!!n&&n.$$typeof===z}function un(n){return rn(n)?y.apply(null,arguments):n}function on(n){return!!n.__k&&(m(null,n),!0)}function cn(n){return n&&(n.base||1===n.nodeType&&n)||null}var fn=function(n,t){return n(t)},ln=d;export default{useState:n,useReducer:t,useEffect:e,useLayoutEffect:r,useRef:u,useImperativeHandle:o,useMemo:i,useCallback:c,useContext:f,useDebugValue:l,version:"16.8.0",Children:O,render:H,hydrate:Z,unmountComponentAtNode:on,createPortal:P,createElement:s,createContext:E,createFactory:en,cloneElement:un,createRef:_,Fragment:d,isValidElement:rn,findDOMNode:cn,Component:a,PureComponent:C,memo:g,forwardRef:N,unstable_batchedUpdates:fn,StrictMode:d,Suspense:F,SuspenseList:D,lazy:j,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:nn};export{tn as version,O as Children,H as render,Z as hydrate,on as unmountComponentAtNode,P as createPortal,en as createFactory,un as cloneElement,rn as isValidElement,cn as findDOMNode,C as PureComponent,g as memo,N as forwardRef,fn as unstable_batchedUpdates,ln as StrictMode,F as Suspense,D as SuspenseList,j as lazy,nn as __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED};
 //# sourceMappingURL=compat.module.js.map
diff --git a/node_modules/preact/compat/dist/compat.module.js.map b/node_modules/preact/compat/dist/compat.module.js.map
index 6addea1..f67c6d3 100644
--- a/node_modules/preact/compat/dist/compat.module.js.map
+++ b/node_modules/preact/compat/dist/compat.module.js.map
@@ -1 +1 @@
-{"version":3,"file":"compat.module.js","sources":["../src/util.js","../src/PureComponent.js","../src/memo.js","../src/forwardRef.js","../src/Children.js","../src/suspense.js","../src/suspense-list.js","../src/portals.js","../src/render.js","../src/events.js","../src/index.js"],"sourcesContent":["/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Check if two objects have a different shape\n * @param {object} a\n * @param {object} b\n * @returns {boolean}\n */\nexport function shallowDiffers(a, b) {\n\tfor (let i in a) if (i !== '__source' && !(i in b)) return true;\n\tfor (let i in b) if (i !== '__source' && a[i] !== b[i]) return true;\n\treturn false;\n}\n","import { Component } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Component class with a predefined `shouldComponentUpdate` implementation\n */\nexport function PureComponent(p) {\n\tthis.props = p;\n}\nPureComponent.prototype = new Component();\n// Some third-party libraries check if this property is present\nPureComponent.prototype.isPureReactComponent = true;\nPureComponent.prototype.shouldComponentUpdate = function(props, state) {\n\treturn shallowDiffers(this.props, props) || shallowDiffers(this.state, state);\n};\n","import { createElement } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Memoize a component, so that it only updates when the props actually have\n * changed. This was previously known as `React.pure`.\n * @param {import('./internal').FunctionalComponent} c functional component\n * @param {(prev: object, next: object) => boolean} [comparer] Custom equality function\n * @returns {import('./internal').FunctionalComponent}\n */\nexport function memo(c, comparer) {\n\tfunction shouldUpdate(nextProps) {\n\t\tlet ref = this.props.ref;\n\t\tlet updateRef = ref == nextProps.ref;\n\t\tif (!updateRef && ref) {\n\t\t\tref.call ? ref(null) : (ref.current = null);\n\t\t}\n\n\t\tif (!comparer) {\n\t\t\treturn shallowDiffers(this.props, nextProps);\n\t\t}\n\n\t\treturn !comparer(this.props, nextProps) || !updateRef;\n\t}\n\n\tfunction Memoed(props) {\n\t\tthis.shouldComponentUpdate = shouldUpdate;\n\t\treturn createElement(c, props);\n\t}\n\tMemoed.displayName = 'Memo(' + (c.displayName || c.name) + ')';\n\tMemoed.prototype.isReactComponent = true;\n\tMemoed._forwarded = true;\n\treturn Memoed;\n}\n","import { options } from 'preact';\nimport { assign } from './util';\n\nlet oldDiffHook = options._diff;\noptions._diff = vnode => {\n\tif (vnode.type && vnode.type._forwarded && vnode.ref) {\n\t\tvnode.props.ref = vnode.ref;\n\t\tvnode.ref = null;\n\t}\n\tif (oldDiffHook) oldDiffHook(vnode);\n};\n\nexport const REACT_FORWARD_SYMBOL =\n\t(typeof Symbol != 'undefined' &&\n\t\tSymbol.for &&\n\t\tSymbol.for('react.forward_ref')) ||\n\t0xf47;\n\n/**\n * Pass ref down to a child. This is mainly used in libraries with HOCs that\n * wrap components. Using `forwardRef` there is an easy way to get a reference\n * of the wrapped component instead of one of the wrapper itself.\n * @param {import('./index').ForwardFn} fn\n * @returns {import('./internal').FunctionalComponent}\n */\nexport function forwardRef(fn) {\n\t// We always have ref in props.ref, except for\n\t// mobx-react. It will call this function directly\n\t// and always pass ref as the second argument.\n\tfunction Forwarded(props, ref) {\n\t\tlet clone = assign({}, props);\n\t\tdelete clone.ref;\n\t\tref = props.ref || ref;\n\t\treturn fn(\n\t\t\tclone,\n\t\t\t!ref || (typeof ref === 'object' && !('current' in ref)) ? null : ref\n\t\t);\n\t}\n\n\t// mobx-react checks for this being present\n\tForwarded.$$typeof = REACT_FORWARD_SYMBOL;\n\t// mobx-react heavily relies on implementation details.\n\t// It expects an object here with a `render` property,\n\t// and prototype.render will fail. Without this\n\t// mobx-react throws.\n\tForwarded.render = Forwarded;\n\n\tForwarded.prototype.isReactComponent = Forwarded._forwarded = true;\n\tForwarded.displayName = 'ForwardRef(' + (fn.displayName || fn.name) + ')';\n\treturn Forwarded;\n}\n","import { toChildArray } from 'preact';\n\nconst mapFn = (children, fn) => {\n\tif (!children) return null;\n\treturn toChildArray(toChildArray(children).map(fn));\n};\n\n// This API is completely unnecessary for Preact, so it's basically passthrough.\nexport const Children = {\n\tmap: mapFn,\n\tforEach: mapFn,\n\tcount(children) {\n\t\treturn children ? toChildArray(children).length : 0;\n\t},\n\tonly(children) {\n\t\tconst normalized = toChildArray(children);\n\t\tif (normalized.length !== 1) throw 'Children.only';\n\t\treturn normalized[0];\n\t},\n\ttoArray: toChildArray\n};\n","import { Component, createElement, options, Fragment } from 'preact';\nimport { assign } from './util';\n\nconst oldCatchError = options._catchError;\noptions._catchError = function(error, newVNode, oldVNode) {\n\tif (error.then) {\n\t\t/** @type {import('./internal').Component} */\n\t\tlet component;\n\t\tlet vnode = newVNode;\n\n\t\tfor (; (vnode = vnode._parent); ) {\n\t\t\tif ((component = vnode._component) && component._childDidSuspend) {\n\t\t\t\tif (newVNode._dom == null) {\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t}\n\t\t\t\t// Don't call oldCatchError if we found a Suspense\n\t\t\t\treturn component._childDidSuspend(error, newVNode._component);\n\t\t\t}\n\t\t}\n\t}\n\toldCatchError(error, newVNode, oldVNode);\n};\n\nfunction detachedClone(vnode) {\n\tif (vnode) {\n\t\tvnode = assign({}, vnode);\n\t\tvnode._component = null;\n\t\tvnode._children = vnode._children && vnode._children.map(detachedClone);\n\t}\n\treturn vnode;\n}\n\nfunction removeOriginal(vnode) {\n\tif (vnode) {\n\t\tvnode._original = null;\n\t\tvnode._children = vnode._children && vnode._children.map(removeOriginal);\n\t}\n\treturn vnode;\n}\n\n// having custom inheritance instead of a class here saves a lot of bytes\nexport function Suspense() {\n\t// we do not call super here to golf some bytes...\n\tthis._pendingSuspensionCount = 0;\n\tthis._suspenders = null;\n\tthis._detachOnNextRender = null;\n}\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspense.prototype = new Component();\n\n/**\n * @param {Promise} promise The thrown promise\n * @param {Component<any, any>} suspendingComponent The suspending component\n */\nSuspense.prototype._childDidSuspend = function(promise, suspendingComponent) {\n\t/** @type {import('./internal').SuspenseComponent} */\n\tconst c = this;\n\n\tif (c._suspenders == null) {\n\t\tc._suspenders = [];\n\t}\n\tc._suspenders.push(suspendingComponent);\n\n\tconst resolve = suspended(c._vnode);\n\n\tlet resolved = false;\n\tconst onResolved = () => {\n\t\tif (resolved) return;\n\n\t\tresolved = true;\n\t\tsuspendingComponent.componentWillUnmount =\n\t\t\tsuspendingComponent._suspendedComponentWillUnmount;\n\n\t\tif (resolve) {\n\t\t\tresolve(onSuspensionComplete);\n\t\t} else {\n\t\t\tonSuspensionComplete();\n\t\t}\n\t};\n\n\tsuspendingComponent._suspendedComponentWillUnmount =\n\t\tsuspendingComponent.componentWillUnmount;\n\tsuspendingComponent.componentWillUnmount = () => {\n\t\tonResolved();\n\n\t\tif (suspendingComponent._suspendedComponentWillUnmount) {\n\t\t\tsuspendingComponent._suspendedComponentWillUnmount();\n\t\t}\n\t};\n\n\tconst onSuspensionComplete = () => {\n\t\tif (!--c._pendingSuspensionCount) {\n\t\t\tc._vnode._children[0] = removeOriginal(c.state._suspended);\n\t\t\tc.setState({ _suspended: (c._detachOnNextRender = null) });\n\n\t\t\tlet suspended;\n\t\t\twhile ((suspended = c._suspenders.pop())) {\n\t\t\t\tsuspended.forceUpdate();\n\t\t\t}\n\t\t}\n\t};\n\n\tif (!c._pendingSuspensionCount++) {\n\t\tc.setState({ _suspended: (c._detachOnNextRender = c._vnode._children[0]) });\n\t}\n\tpromise.then(onResolved, onResolved);\n};\n\nSuspense.prototype.componentWillUnmount = function() {\n\tthis._suspenders = [];\n};\n\nSuspense.prototype.render = function(props, state) {\n\tif (this._detachOnNextRender) {\n\t\t// When the Suspense's _vnode was created by a call to createVNode\n\t\t// (i.e. due to a setState further up in the tree)\n\t\t// it's _children prop is null, in this case we \"forget\" about the parked vnodes to detach\n\t\tif (this._vnode._children)\n\t\t\tthis._vnode._children[0] = detachedClone(this._detachOnNextRender);\n\t\tthis._detachOnNextRender = null;\n\t}\n\n\treturn [\n\t\tcreateElement(Fragment, null, state._suspended ? null : props.children),\n\t\tstate._suspended && props.fallback\n\t];\n};\n\n/**\n * Checks and calls the parent component's _suspended method, passing in the\n * suspended vnode. This is a way for a parent (e.g. SuspenseList) to get notified\n * that one of its children/descendants suspended.\n *\n * The parent MAY return a callback. The callback will get called when the\n * suspension resolves, notifying the parent of the fact.\n * Moreover, the callback gets function `unsuspend` as a parameter. The resolved\n * child descendant will not actually get unsuspended until `unsuspend` gets called.\n * This is a way for the parent to delay unsuspending.\n *\n * If the parent does not return a callback then the resolved vnode\n * gets unsuspended immediately when it resolves.\n *\n * @param {import('../src/internal').VNode} vnode\n * @returns {((unsuspend: () => void) => void)?}\n */\nexport function suspended(vnode) {\n\tlet component = vnode._parent._component;\n\treturn component && component._suspended && component._suspended(vnode);\n}\n\nexport function lazy(loader) {\n\tlet prom;\n\tlet component;\n\tlet error;\n\n\tfunction Lazy(props) {\n\t\tif (!prom) {\n\t\t\tprom = loader();\n\t\t\tprom.then(\n\t\t\t\texports => {\n\t\t\t\t\tcomponent = exports.default || exports;\n\t\t\t\t},\n\t\t\t\te => {\n\t\t\t\t\terror = e;\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tif (!component) {\n\t\t\tthrow prom;\n\t\t}\n\n\t\treturn createElement(component, props);\n\t}\n\n\tLazy.displayName = 'Lazy';\n\tLazy._forwarded = true;\n\treturn Lazy;\n}\n","import { Component, toChildArray } from 'preact';\nimport { suspended } from './suspense.js';\n\n// Indexes to linked list nodes (nodes are stored as arrays to save bytes).\nconst SUSPENDED_COUNT = 0;\nconst RESOLVED_COUNT = 1;\nconst NEXT_NODE = 2;\n\n// Having custom inheritance instead of a class here saves a lot of bytes.\nexport function SuspenseList() {\n\tthis._next = null;\n\tthis._map = null;\n}\n\n// Mark one of child's earlier suspensions as resolved.\n// Some pending callbacks may become callable due to this\n// (e.g. the last suspended descendant gets resolved when\n// revealOrder === 'together'). Process those callbacks as well.\nconst resolve = (list, child, node) => {\n\tif (++node[RESOLVED_COUNT] === node[SUSPENDED_COUNT]) {\n\t\t// The number a child (or any of its descendants) has been suspended\n\t\t// matches the number of times it's been resolved. Therefore we\n\t\t// mark the child as completely resolved by deleting it from ._map.\n\t\t// This is used to figure out when *all* children have been completely\n\t\t// resolved when revealOrder is 'together'.\n\t\tlist._map.delete(child);\n\t}\n\n\t// If revealOrder is falsy then we can do an early exit, as the\n\t// callbacks won't get queued in the node anyway.\n\t// If revealOrder is 'together' then also do an early exit\n\t// if all suspended descendants have not yet been resolved.\n\tif (\n\t\t!list.props.revealOrder ||\n\t\t(list.props.revealOrder[0] === 't' && list._map.size)\n\t) {\n\t\treturn;\n\t}\n\n\t// Walk the currently suspended children in order, calling their\n\t// stored callbacks on the way. Stop if we encounter a child that\n\t// has not been completely resolved yet.\n\tnode = list._next;\n\twhile (node) {\n\t\twhile (node.length > 3) {\n\t\t\tnode.pop()();\n\t\t}\n\t\tif (node[RESOLVED_COUNT] < node[SUSPENDED_COUNT]) {\n\t\t\tbreak;\n\t\t}\n\t\tlist._next = node = node[NEXT_NODE];\n\t}\n};\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspenseList.prototype = new Component();\n\nSuspenseList.prototype._suspended = function(child) {\n\tconst list = this;\n\tconst delegated = suspended(list._vnode);\n\n\tlet node = list._map.get(child);\n\tnode[SUSPENDED_COUNT]++;\n\n\treturn unsuspend => {\n\t\tconst wrappedUnsuspend = () => {\n\t\t\tif (!list.props.revealOrder) {\n\t\t\t\t// Special case the undefined (falsy) revealOrder, as there\n\t\t\t\t// is no need to coordinate a specific order or unsuspends.\n\t\t\t\tunsuspend();\n\t\t\t} else {\n\t\t\t\tnode.push(unsuspend);\n\t\t\t\tresolve(list, child, node);\n\t\t\t}\n\t\t};\n\t\tif (delegated) {\n\t\t\tdelegated(wrappedUnsuspend);\n\t\t} else {\n\t\t\twrappedUnsuspend();\n\t\t}\n\t};\n};\n\nSuspenseList.prototype.render = function(props) {\n\tthis._next = null;\n\tthis._map = new Map();\n\n\tconst children = toChildArray(props.children);\n\tif (props.revealOrder && props.revealOrder[0] === 'b') {\n\t\t// If order === 'backwards' (or, well, anything starting with a 'b')\n\t\t// then flip the child list around so that the last child will be\n\t\t// the first in the linked list.\n\t\tchildren.reverse();\n\t}\n\t// Build the linked list. Iterate through the children in reverse order\n\t// so that `_next` points to the first linked list node to be resolved.\n\tfor (let i = children.length; i--; ) {\n\t\t// Create a new linked list node as an array of form:\n\t\t// \t[suspended_count, resolved_count, next_node]\n\t\t// where suspended_count and resolved_count are numeric counters for\n\t\t// keeping track how many times a node has been suspended and resolved.\n\t\t//\n\t\t// Note that suspended_count starts from 1 instead of 0, so we can block\n\t\t// processing callbacks until componentDidMount has been called. In a sense\n\t\t// node is suspended at least until componentDidMount gets called!\n\t\t//\n\t\t// Pending callbacks are added to the end of the node:\n\t\t// \t[suspended_count, resolved_count, next_node, callback_0, callback_1, ...]\n\t\tthis._map.set(children[i], (this._next = [1, 0, this._next]));\n\t}\n\treturn props.children;\n};\n\nSuspenseList.prototype.componentDidUpdate = SuspenseList.prototype.componentDidMount = function() {\n\t// Iterate through all children after mounting for two reasons:\n\t// 1. As each node[SUSPENDED_COUNT] starts from 1, this iteration increases\n\t//    each node[RELEASED_COUNT] by 1, therefore balancing the counters.\n\t//    The nodes can now be completely consumed from the linked list.\n\t// 2. Handle nodes that might have gotten resolved between render and\n\t//    componentDidMount.\n\tthis._map.forEach((node, child) => {\n\t\tresolve(this, child, node);\n\t});\n};\n","import { createElement, hydrate, render, __u as _unmount } from 'preact';\n\nfunction ContextProvider(props) {\n\tthis.getChildContext = () => props.context;\n\treturn props.children;\n}\n\n/**\n * Portal component\n * @param {object | null | undefined} props\n *\n * TODO: this could use the \"fake root node\" trick from the partial hydration demo\n */\nfunction Portal(props) {\n\tconst _this = this;\n\tlet container = props._container;\n\tlet wrap = createElement(\n\t\tContextProvider,\n\t\t{ context: _this.context },\n\t\tprops._vnode\n\t);\n\n\t_this.componentWillUnmount = function() {\n\t\tlet parent = _this._temp.parentNode;\n\t\tif (parent) parent.removeChild(_this._temp);\n\t\t_unmount(_this._wrap);\n\t};\n\n\t// When we change container we should clear our old container and\n\t// indicate a new mount.\n\tif (_this._container && _this._container !== container) {\n\t\t_this.componentWillUnmount();\n\t\t// if (_this._temp.parentNode) _this._container.removeChild(_this._temp);\n\t\t// _unmount(_this._wrap);\n\t\t_this._hasMounted = false;\n\t}\n\n\t// When props.vnode is undefined/false/null we are dealing with some kind of\n\t// conditional vnode. This should not trigger a render.\n\tif (props._vnode) {\n\t\tif (!_this._hasMounted) {\n\t\t\t// Create a placeholder that we can use to insert into.\n\t\t\t_this._temp = document.createTextNode('');\n\t\t\t// temporarily store the current children of the container to restore them after render\n\t\t\t_this._children = container._children;\n\t\t\t// Hydrate existing nodes to keep the dom intact, when rendering\n\t\t\t// wrap into the container.\n\t\t\thydrate('', container);\n\t\t\t// Append to the container (this matches React's behavior)\n\t\t\tcontainer.appendChild(_this._temp);\n\t\t\t// At this point we have mounted and should set our container.\n\t\t\t_this._hasMounted = true;\n\t\t\t_this._container = container;\n\t\t\t// Render our wrapping element into temp.\n\t\t\trender(wrap, container, _this._temp);\n\t\t\t// restore the previous children of the container\n\t\t\tcontainer._children = _this._children;\n\t\t\t// store the children of the new vnode to be used in subsequent re-renders\n\t\t\t_this._children = _this._temp._children;\n\t\t} else {\n\t\t\t// When we have mounted and the vnode is present it means the\n\t\t\t// props have changed or a parent is triggering a rerender.\n\t\t\t// This implies we only need to call render. But we need to keep\n\t\t\t// the old tree around, otherwise will treat the vnodes as new and\n\t\t\t// will wrongly call `componentDidMount` on them\n\t\t\tcontainer._children = _this._children;\n\t\t\trender(wrap, container);\n\t\t\t_this._children = container._children;\n\t\t}\n\t}\n\t// When we come from a conditional render, on a mounted\n\t// portal we should clear the DOM.\n\telse if (_this._hasMounted) {\n\t\t_this.componentWillUnmount();\n\t\t// if (_this._temp.parentNode) _this._container.removeChild(_this._temp);\n\t\t// _unmount(_this._wrap);\n\t}\n\t// Set the wrapping element for future unmounting.\n\t_this._wrap = wrap;\n}\n\n/**\n * Create a `Portal` to continue rendering the vnode tree at a different DOM node\n * @param {import('./internal').VNode} vnode The vnode to render\n * @param {import('./internal').PreactElement} container The DOM node to continue rendering in to.\n */\nexport function createPortal(vnode, container) {\n\treturn createElement(Portal, { _vnode: vnode, _container: container });\n}\n","import {\n\trender as preactRender,\n\thydrate as preactHydrate,\n\toptions,\n\ttoChildArray,\n\tComponent\n} from 'preact';\nimport { applyEventNormalization } from './events';\n\nconst CAMEL_PROPS = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;\n\n// Some libraries like `react-virtualized` explicitly check for this.\nComponent.prototype.isReactComponent = {};\n\nexport const REACT_ELEMENT_TYPE =\n\t(typeof Symbol != 'undefined' && Symbol.for && Symbol.for('react.element')) ||\n\t0xeac7;\n\n/**\n * Proxy render() since React returns a Component reference.\n * @param {import('./internal').VNode} vnode VNode tree to render\n * @param {import('./internal').PreactElement} parent DOM node to render vnode tree into\n * @param {() => void} [callback] Optional callback that will be called after rendering\n * @returns {import('./internal').Component | null} The root component reference or null\n */\nexport function render(vnode, parent, callback) {\n\t// React destroys any existing DOM nodes, see #1727\n\t// ...but only on the first render, see #1828\n\tif (parent._children == null) {\n\t\twhile (parent.firstChild) {\n\t\t\tparent.removeChild(parent.firstChild);\n\t\t}\n\t}\n\n\tpreactRender(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nexport function hydrate(vnode, parent, callback) {\n\tpreactHydrate(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nlet oldEventHook = options.event;\noptions.event = e => {\n\tif (oldEventHook) e = oldEventHook(e);\n\te.persist = () => {};\n\tlet stoppedPropagating = false,\n\t\tdefaultPrevented = false;\n\n\tconst origStopPropagation = e.stopPropagation;\n\te.stopPropagation = () => {\n\t\torigStopPropagation.call(e);\n\t\tstoppedPropagating = true;\n\t};\n\n\tconst origPreventDefault = e.preventDefault;\n\te.preventDefault = () => {\n\t\torigPreventDefault.call(e);\n\t\tdefaultPrevented = true;\n\t};\n\n\te.isPropagationStopped = () => stoppedPropagating;\n\te.isDefaultPrevented = () => defaultPrevented;\n\treturn (e.nativeEvent = e);\n};\n\n// Patch in `UNSAFE_*` lifecycle hooks\nfunction setSafeDescriptor(proto, key) {\n\tif (proto['UNSAFE_' + key] && !proto[key]) {\n\t\tObject.defineProperty(proto, key, {\n\t\t\tget() {\n\t\t\t\treturn this['UNSAFE_' + key];\n\t\t\t},\n\t\t\t// This `set` is only used if a user sets a lifecycle like cWU\n\t\t\t// after setting a lifecycle like UNSAFE_cWU. I doubt anyone\n\t\t\t// actually does this in practice so not testing it\n\t\t\t/* istanbul ignore next */\n\t\t\tset(v) {\n\t\t\t\tthis['UNSAFE_' + key] = v;\n\t\t\t}\n\t\t});\n\t}\n}\n\nlet classNameDescriptor = {\n\tconfigurable: true,\n\tget() {\n\t\treturn this.class;\n\t}\n};\n\nlet oldVNodeHook = options.vnode;\noptions.vnode = vnode => {\n\tvnode.$$typeof = REACT_ELEMENT_TYPE;\n\n\tlet type = vnode.type;\n\tlet props = vnode.props;\n\n\tif (type) {\n\t\t// Alias `class` prop to `className` if available\n\t\tif (props.class != props.className) {\n\t\t\tclassNameDescriptor.enumerable = 'className' in props;\n\t\t\tif (props.className != null) props.class = props.className;\n\t\t\tObject.defineProperty(props, 'className', classNameDescriptor);\n\t\t}\n\n\t\t// Apply DOM VNode compat\n\t\tif (typeof type != 'function') {\n\t\t\t// Apply defaultValue to value\n\t\t\tif (props.defaultValue && props.value !== undefined) {\n\t\t\t\tif (!props.value && props.value !== 0) {\n\t\t\t\t\tprops.value = props.defaultValue;\n\t\t\t\t}\n\t\t\t\tprops.defaultValue = undefined;\n\t\t\t}\n\n\t\t\t// Add support for array select values: <select value={[]} />\n\t\t\tif (type === 'select' && props.multiple && Array.isArray(props.value)) {\n\t\t\t\ttoChildArray(props.children).forEach(child => {\n\t\t\t\t\tif (props.value.indexOf(child.props.value) != -1) {\n\t\t\t\t\t\tchild.props.selected = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tprops.value = undefined;\n\t\t\t}\n\n\t\t\t// Calling `setAttribute` with a truthy value will lead to it being\n\t\t\t// passed as a stringified value, e.g. `download=\"true\"`. React\n\t\t\t// converts it to an empty string instead, otherwise the attribute\n\t\t\t// value will be used as the file name and the file will be called\n\t\t\t// \"true\" upon downloading it.\n\t\t\tif (props.download === true) {\n\t\t\t\tprops.download = '';\n\t\t\t}\n\n\t\t\t// Normalize DOM vnode properties.\n\t\t\tlet i;\n\t\t\tfor (i in props) {\n\t\t\t\tlet shouldSanitize = CAMEL_PROPS.test(i);\n\t\t\t\tif (shouldSanitize)\n\t\t\t\t\tvnode.props[i.replace(/[A-Z0-9]/, '-$&').toLowerCase()] = props[i];\n\t\t\t\tif (shouldSanitize || props[i] === null) props[i] = undefined;\n\t\t\t}\n\t\t}\n\t\t// Component base class compat\n\t\t// We can't just patch the base component class, because components that use\n\t\t// inheritance and are transpiled down to ES5 will overwrite our patched\n\t\t// getters and setters. See #1941\n\t\telse if (type.prototype && !type.prototype._patchedLifecycles) {\n\t\t\ttype.prototype._patchedLifecycles = true;\n\t\t\tsetSafeDescriptor(type.prototype, 'componentWillMount');\n\t\t\tsetSafeDescriptor(type.prototype, 'componentWillReceiveProps');\n\t\t\tsetSafeDescriptor(type.prototype, 'componentWillUpdate');\n\t\t}\n\n\t\t// Events\n\t\tapplyEventNormalization(vnode);\n\t}\n\n\tif (oldVNodeHook) oldVNodeHook(vnode);\n};\n\n// Only needed for react-relay\nlet currentComponent;\nconst oldBeforeRender = options._render;\noptions._render = function(vnode) {\n\tif (oldBeforeRender) {\n\t\toldBeforeRender(vnode);\n\t}\n\tcurrentComponent = vnode._component;\n};\n\n// This is a very very private internal function for React it\n// is used to sort-of do runtime dependency injection. So far\n// only `react-relay` makes use of it. It uses it to read the\n// context value.\nexport const __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = {\n\tReactCurrentDispatcher: {\n\t\tcurrent: {\n\t\t\treadContext(context) {\n\t\t\t\treturn currentComponent._globalContext[context._id].props.value;\n\t\t\t}\n\t\t}\n\t}\n};\n","/**\n * Normalize event handlers like react does. Most famously it uses `onChange` for any input element.\n * @param {import('./internal').VNode} vnode The vnode to normalize events on\n */\nexport function applyEventNormalization({ type, props }) {\n\tif (!props || typeof type != 'string') return;\n\tlet newProps = {};\n\n\tfor (let i in props) {\n\t\tif (/^on(Ani|Tra|Tou)/.test(i)) {\n\t\t\tprops[i.toLowerCase()] = props[i];\n\t\t\tdelete props[i];\n\t\t}\n\t\tnewProps[i.toLowerCase()] = i;\n\t}\n\tif (newProps.ondoubleclick) {\n\t\tprops.ondblclick = props[newProps.ondoubleclick];\n\t\tdelete props[newProps.ondoubleclick];\n\t}\n\tif (newProps.onbeforeinput) {\n\t\tprops.onbeforeinput = props[newProps.onbeforeinput];\n\t\tdelete props[newProps.onbeforeinput];\n\t}\n\t// for *textual inputs* (incl textarea), normalize `onChange` -> `onInput`:\n\tif (\n\t\tnewProps.onchange &&\n\t\t(type === 'textarea' ||\n\t\t\t(type.toLowerCase() === 'input' && !/^fil|che|ra/i.test(props.type)))\n\t) {\n\t\tlet normalized = newProps.oninput || 'oninput';\n\t\tif (!props[normalized]) {\n\t\t\tprops[normalized] = props[newProps.onchange];\n\t\t\tdelete props[newProps.onchange];\n\t\t}\n\t}\n}\n","import {\n\tcreateElement,\n\trender as preactRender,\n\tcloneElement as preactCloneElement,\n\tcreateRef,\n\tComponent,\n\tcreateContext,\n\tFragment\n} from 'preact';\nimport {\n\tuseState,\n\tuseReducer,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseRef,\n\tuseImperativeHandle,\n\tuseMemo,\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue\n} from 'preact/hooks';\nimport { PureComponent } from './PureComponent';\nimport { memo } from './memo';\nimport { forwardRef } from './forwardRef';\nimport { Children } from './Children';\nimport { Suspense, lazy } from './suspense';\nimport { SuspenseList } from './suspense-list';\nimport { createPortal } from './portals';\nimport {\n\thydrate,\n\trender,\n\tREACT_ELEMENT_TYPE,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n} from './render';\n\nconst version = '16.8.0'; // trick libraries to think we are react\n\n/**\n * Legacy version of createElement.\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component constructor\n */\nfunction createFactory(type) {\n\treturn createElement.bind(null, type);\n}\n\n/**\n * Check if the passed element is a valid (p)react node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isValidElement(element) {\n\treturn !!element && element.$$typeof === REACT_ELEMENT_TYPE;\n}\n\n/**\n * Wrap `cloneElement` to abort if the passed element is not a valid element and apply\n * all vnode normalizations.\n * @param {import('./internal').VNode} element The vnode to clone\n * @param {object} props Props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Optional component children\n */\nfunction cloneElement(element) {\n\tif (!isValidElement(element)) return element;\n\treturn preactCloneElement.apply(null, arguments);\n}\n\n/**\n * Remove a component tree from the DOM, including state and event handlers.\n * @param {import('./internal').PreactElement} container\n * @returns {boolean}\n */\nfunction unmountComponentAtNode(container) {\n\tif (container._children) {\n\t\tpreactRender(null, container);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**\n * Get the matching DOM node for a component\n * @param {import('./internal').Component} component\n * @returns {import('./internal').PreactElement | null}\n */\nfunction findDOMNode(component) {\n\treturn (\n\t\t(component &&\n\t\t\t(component.base || (component.nodeType === 1 && component))) ||\n\t\tnull\n\t);\n}\n\n/**\n * Deprecated way to control batched rendering inside the reconciler, but we\n * already schedule in batches inside our rendering code\n * @template Arg\n * @param {(arg: Arg) => void} callback function that triggers the updated\n * @param {Arg} [arg] Optional argument that can be passed to the callback\n */\n// eslint-disable-next-line camelcase\nconst unstable_batchedUpdates = (callback, arg) => callback(arg);\n\n/**\n * Strict Mode is not implemented in Preact, so we provide a stand-in for it\n * that just renders its children without imposing any restrictions.\n */\nconst StrictMode = Fragment;\n\nexport * from 'preact/hooks';\nexport {\n\tversion,\n\tChildren,\n\trender,\n\thydrate,\n\tunmountComponentAtNode,\n\tcreatePortal,\n\tcreateElement,\n\tcreateContext,\n\tcreateFactory,\n\tcloneElement,\n\tcreateRef,\n\tFragment,\n\tisValidElement,\n\tfindDOMNode,\n\tComponent,\n\tPureComponent,\n\tmemo,\n\tforwardRef,\n\t// eslint-disable-next-line camelcase\n\tunstable_batchedUpdates,\n\tStrictMode,\n\tSuspense,\n\tSuspenseList,\n\tlazy,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n\n// React copies the named exports to the default one.\nexport default {\n\tuseState,\n\tuseReducer,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseRef,\n\tuseImperativeHandle,\n\tuseMemo,\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue,\n\tversion,\n\tChildren,\n\trender,\n\thydrate,\n\tunmountComponentAtNode,\n\tcreatePortal,\n\tcreateElement,\n\tcreateContext,\n\tcreateFactory,\n\tcloneElement,\n\tcreateRef,\n\tFragment,\n\tisValidElement,\n\tfindDOMNode,\n\tComponent,\n\tPureComponent,\n\tmemo,\n\tforwardRef,\n\tunstable_batchedUpdates,\n\tStrictMode,\n\tSuspense,\n\tSuspenseList,\n\tlazy,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n"],"names":["assign","obj","props","i","shallowDiffers","a","b","PureComponent","p","memo","c","comparer","shouldUpdate","nextProps","ref","this","updateRef","call","current","Memoed","shouldComponentUpdate","createElement","displayName","name","prototype","isReactComponent","Component","isPureReactComponent","state","oldDiffHook","options","vnode","type","REACT_FORWARD_SYMBOL","Symbol","for","forwardRef","fn","Forwarded","clone","$$typeof","render","mapFn","children","toChildArray","map","Children","forEach","count","length","only","normalized","toArray","oldCatchError","detachedClone","removeOriginal","Suspense","_suspenders","suspended","component","_suspended","lazy","loader","prom","error","Lazy","then","exports","default","e","SuspenseList","_next","_map","newVNode","oldVNode","promise","suspendingComponent","push","resolve","resolved","onResolved","componentWillUnmount","onSuspensionComplete","setState","pop","forceUpdate","Fragment","fallback","list","child","node","delete","revealOrder","size","ContextProvider","getChildContext","context","Portal","_this","container","_container","wrap","parent","_temp","parentNode","removeChild","_unmount","_wrap","_hasMounted","document","createTextNode","hydrate","appendChild","createPortal","delegated","get","unsuspend","wrappedUnsuspend","Map","reverse","set","componentDidUpdate","componentDidMount","CAMEL_PROPS","REACT_ELEMENT_TYPE","callback","firstChild","preactRender","preactHydrate","oldEventHook","event","setSafeDescriptor","proto","key","Object","defineProperty","v","persist","stoppedPropagating","defaultPrevented","origStopPropagation","stopPropagation","origPreventDefault","preventDefault","isPropagationStopped","isDefaultPrevented","nativeEvent","currentComponent","classNameDescriptor","configurable","class","oldVNodeHook","className","enumerable","defaultValue","undefined","value","multiple","Array","isArray","indexOf","selected","download","shouldSanitize","test","replace","toLowerCase","_patchedLifecycles","newProps","ondoubleclick","ondblclick","onbeforeinput","onchange","oninput","applyEventNormalization","oldBeforeRender","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentDispatcher","readContext","version","createFactory","bind","isValidElement","element","cloneElement","preactCloneElement","apply","arguments","unmountComponentAtNode","findDOMNode","base","nodeType","unstable_batchedUpdates","arg","StrictMode","useState","useReducer","useEffect","useLayoutEffect","useRef","useImperativeHandle","useMemo","useCallback","useContext","useDebugValue","createContext","createRef"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"compat.module.js","sources":["../src/util.js","../src/PureComponent.js","../src/memo.js","../src/forwardRef.js","../src/Children.js","../src/suspense.js","../src/suspense-list.js","../src/portals.js","../src/render.js","../src/index.js"],"sourcesContent":["/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Check if two objects have a different shape\n * @param {object} a\n * @param {object} b\n * @returns {boolean}\n */\nexport function shallowDiffers(a, b) {\n\tfor (let i in a) if (i !== '__source' && !(i in b)) return true;\n\tfor (let i in b) if (i !== '__source' && a[i] !== b[i]) return true;\n\treturn false;\n}\n","import { Component } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Component class with a predefined `shouldComponentUpdate` implementation\n */\nexport function PureComponent(p) {\n\tthis.props = p;\n}\nPureComponent.prototype = new Component();\n// Some third-party libraries check if this property is present\nPureComponent.prototype.isPureReactComponent = true;\nPureComponent.prototype.shouldComponentUpdate = function(props, state) {\n\treturn shallowDiffers(this.props, props) || shallowDiffers(this.state, state);\n};\n","import { createElement } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Memoize a component, so that it only updates when the props actually have\n * changed. This was previously known as `React.pure`.\n * @param {import('./internal').FunctionalComponent} c functional component\n * @param {(prev: object, next: object) => boolean} [comparer] Custom equality function\n * @returns {import('./internal').FunctionalComponent}\n */\nexport function memo(c, comparer) {\n\tfunction shouldUpdate(nextProps) {\n\t\tlet ref = this.props.ref;\n\t\tlet updateRef = ref == nextProps.ref;\n\t\tif (!updateRef && ref) {\n\t\t\tref.call ? ref(null) : (ref.current = null);\n\t\t}\n\n\t\tif (!comparer) {\n\t\t\treturn shallowDiffers(this.props, nextProps);\n\t\t}\n\n\t\treturn !comparer(this.props, nextProps) || !updateRef;\n\t}\n\n\tfunction Memoed(props) {\n\t\tthis.shouldComponentUpdate = shouldUpdate;\n\t\treturn createElement(c, props);\n\t}\n\tMemoed.displayName = 'Memo(' + (c.displayName || c.name) + ')';\n\tMemoed.prototype.isReactComponent = true;\n\tMemoed._forwarded = true;\n\treturn Memoed;\n}\n","import { options } from 'preact';\nimport { assign } from './util';\n\nlet oldDiffHook = options._diff;\noptions._diff = vnode => {\n\tif (vnode.type && vnode.type._forwarded && vnode.ref) {\n\t\tvnode.props.ref = vnode.ref;\n\t\tvnode.ref = null;\n\t}\n\tif (oldDiffHook) oldDiffHook(vnode);\n};\n\nexport const REACT_FORWARD_SYMBOL =\n\t(typeof Symbol != 'undefined' &&\n\t\tSymbol.for &&\n\t\tSymbol.for('react.forward_ref')) ||\n\t0xf47;\n\n/**\n * Pass ref down to a child. This is mainly used in libraries with HOCs that\n * wrap components. Using `forwardRef` there is an easy way to get a reference\n * of the wrapped component instead of one of the wrapper itself.\n * @param {import('./index').ForwardFn} fn\n * @returns {import('./internal').FunctionalComponent}\n */\nexport function forwardRef(fn) {\n\t// We always have ref in props.ref, except for\n\t// mobx-react. It will call this function directly\n\t// and always pass ref as the second argument.\n\tfunction Forwarded(props, ref) {\n\t\tlet clone = assign({}, props);\n\t\tdelete clone.ref;\n\t\tref = props.ref || ref;\n\t\treturn fn(\n\t\t\tclone,\n\t\t\t!ref || (typeof ref === 'object' && !('current' in ref)) ? null : ref\n\t\t);\n\t}\n\n\t// mobx-react checks for this being present\n\tForwarded.$$typeof = REACT_FORWARD_SYMBOL;\n\t// mobx-react heavily relies on implementation details.\n\t// It expects an object here with a `render` property,\n\t// and prototype.render will fail. Without this\n\t// mobx-react throws.\n\tForwarded.render = Forwarded;\n\n\tForwarded.prototype.isReactComponent = Forwarded._forwarded = true;\n\tForwarded.displayName = 'ForwardRef(' + (fn.displayName || fn.name) + ')';\n\treturn Forwarded;\n}\n","import { toChildArray } from 'preact';\n\nconst mapFn = (children, fn) => {\n\tif (children == null) return null;\n\treturn toChildArray(toChildArray(children).map(fn));\n};\n\n// This API is completely unnecessary for Preact, so it's basically passthrough.\nexport const Children = {\n\tmap: mapFn,\n\tforEach: mapFn,\n\tcount(children) {\n\t\treturn children ? toChildArray(children).length : 0;\n\t},\n\tonly(children) {\n\t\tconst normalized = toChildArray(children);\n\t\tif (normalized.length !== 1) throw 'Children.only';\n\t\treturn normalized[0];\n\t},\n\ttoArray: toChildArray\n};\n","import { Component, createElement, options, Fragment } from 'preact';\nimport { assign } from './util';\n\nconst oldCatchError = options._catchError;\noptions._catchError = function(error, newVNode, oldVNode) {\n\tif (error.then) {\n\t\t/** @type {import('./internal').Component} */\n\t\tlet component;\n\t\tlet vnode = newVNode;\n\n\t\tfor (; (vnode = vnode._parent); ) {\n\t\t\tif ((component = vnode._component) && component._childDidSuspend) {\n\t\t\t\tif (newVNode._dom == null) {\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t}\n\t\t\t\t// Don't call oldCatchError if we found a Suspense\n\t\t\t\treturn component._childDidSuspend(error, newVNode._component);\n\t\t\t}\n\t\t}\n\t}\n\toldCatchError(error, newVNode, oldVNode);\n};\n\nfunction detachedClone(vnode) {\n\tif (vnode) {\n\t\tvnode = assign({}, vnode);\n\t\tvnode._component = null;\n\t\tvnode._children = vnode._children && vnode._children.map(detachedClone);\n\t}\n\treturn vnode;\n}\n\nfunction removeOriginal(vnode) {\n\tif (vnode) {\n\t\tvnode._original = null;\n\t\tvnode._children = vnode._children && vnode._children.map(removeOriginal);\n\t}\n\treturn vnode;\n}\n\n// having custom inheritance instead of a class here saves a lot of bytes\nexport function Suspense() {\n\t// we do not call super here to golf some bytes...\n\tthis._pendingSuspensionCount = 0;\n\tthis._suspenders = null;\n\tthis._detachOnNextRender = null;\n}\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspense.prototype = new Component();\n\n/**\n * @param {Promise} promise The thrown promise\n * @param {Component<any, any>} suspendingComponent The suspending component\n */\nSuspense.prototype._childDidSuspend = function(promise, suspendingComponent) {\n\t/** @type {import('./internal').SuspenseComponent} */\n\tconst c = this;\n\n\tif (c._suspenders == null) {\n\t\tc._suspenders = [];\n\t}\n\tc._suspenders.push(suspendingComponent);\n\n\tconst resolve = suspended(c._vnode);\n\n\tlet resolved = false;\n\tconst onResolved = () => {\n\t\tif (resolved) return;\n\n\t\tresolved = true;\n\t\tsuspendingComponent.componentWillUnmount =\n\t\t\tsuspendingComponent._suspendedComponentWillUnmount;\n\n\t\tif (resolve) {\n\t\t\tresolve(onSuspensionComplete);\n\t\t} else {\n\t\t\tonSuspensionComplete();\n\t\t}\n\t};\n\n\tsuspendingComponent._suspendedComponentWillUnmount =\n\t\tsuspendingComponent.componentWillUnmount;\n\tsuspendingComponent.componentWillUnmount = () => {\n\t\tonResolved();\n\n\t\tif (suspendingComponent._suspendedComponentWillUnmount) {\n\t\t\tsuspendingComponent._suspendedComponentWillUnmount();\n\t\t}\n\t};\n\n\tconst onSuspensionComplete = () => {\n\t\tif (!--c._pendingSuspensionCount) {\n\t\t\tc._vnode._children[0] = removeOriginal(c.state._suspended);\n\t\t\tc.setState({ _suspended: (c._detachOnNextRender = null) });\n\n\t\t\tlet suspended;\n\t\t\twhile ((suspended = c._suspenders.pop())) {\n\t\t\t\tsuspended.forceUpdate();\n\t\t\t}\n\t\t}\n\t};\n\n\tif (!c._pendingSuspensionCount++) {\n\t\tc.setState({ _suspended: (c._detachOnNextRender = c._vnode._children[0]) });\n\t}\n\tpromise.then(onResolved, onResolved);\n};\n\nSuspense.prototype.componentWillUnmount = function() {\n\tthis._suspenders = [];\n};\n\nSuspense.prototype.render = function(props, state) {\n\tif (this._detachOnNextRender) {\n\t\t// When the Suspense's _vnode was created by a call to createVNode\n\t\t// (i.e. due to a setState further up in the tree)\n\t\t// it's _children prop is null, in this case we \"forget\" about the parked vnodes to detach\n\t\tif (this._vnode._children)\n\t\t\tthis._vnode._children[0] = detachedClone(this._detachOnNextRender);\n\t\tthis._detachOnNextRender = null;\n\t}\n\n\treturn [\n\t\tcreateElement(Fragment, null, state._suspended ? null : props.children),\n\t\tstate._suspended && props.fallback\n\t];\n};\n\n/**\n * Checks and calls the parent component's _suspended method, passing in the\n * suspended vnode. This is a way for a parent (e.g. SuspenseList) to get notified\n * that one of its children/descendants suspended.\n *\n * The parent MAY return a callback. The callback will get called when the\n * suspension resolves, notifying the parent of the fact.\n * Moreover, the callback gets function `unsuspend` as a parameter. The resolved\n * child descendant will not actually get unsuspended until `unsuspend` gets called.\n * This is a way for the parent to delay unsuspending.\n *\n * If the parent does not return a callback then the resolved vnode\n * gets unsuspended immediately when it resolves.\n *\n * @param {import('../src/internal').VNode} vnode\n * @returns {((unsuspend: () => void) => void)?}\n */\nexport function suspended(vnode) {\n\tlet component = vnode._parent._component;\n\treturn component && component._suspended && component._suspended(vnode);\n}\n\nexport function lazy(loader) {\n\tlet prom;\n\tlet component;\n\tlet error;\n\n\tfunction Lazy(props) {\n\t\tif (!prom) {\n\t\t\tprom = loader();\n\t\t\tprom.then(\n\t\t\t\texports => {\n\t\t\t\t\tcomponent = exports.default || exports;\n\t\t\t\t},\n\t\t\t\te => {\n\t\t\t\t\terror = e;\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tif (!component) {\n\t\t\tthrow prom;\n\t\t}\n\n\t\treturn createElement(component, props);\n\t}\n\n\tLazy.displayName = 'Lazy';\n\tLazy._forwarded = true;\n\treturn Lazy;\n}\n","import { Component, toChildArray } from 'preact';\nimport { suspended } from './suspense.js';\n\n// Indexes to linked list nodes (nodes are stored as arrays to save bytes).\nconst SUSPENDED_COUNT = 0;\nconst RESOLVED_COUNT = 1;\nconst NEXT_NODE = 2;\n\n// Having custom inheritance instead of a class here saves a lot of bytes.\nexport function SuspenseList() {\n\tthis._next = null;\n\tthis._map = null;\n}\n\n// Mark one of child's earlier suspensions as resolved.\n// Some pending callbacks may become callable due to this\n// (e.g. the last suspended descendant gets resolved when\n// revealOrder === 'together'). Process those callbacks as well.\nconst resolve = (list, child, node) => {\n\tif (++node[RESOLVED_COUNT] === node[SUSPENDED_COUNT]) {\n\t\t// The number a child (or any of its descendants) has been suspended\n\t\t// matches the number of times it's been resolved. Therefore we\n\t\t// mark the child as completely resolved by deleting it from ._map.\n\t\t// This is used to figure out when *all* children have been completely\n\t\t// resolved when revealOrder is 'together'.\n\t\tlist._map.delete(child);\n\t}\n\n\t// If revealOrder is falsy then we can do an early exit, as the\n\t// callbacks won't get queued in the node anyway.\n\t// If revealOrder is 'together' then also do an early exit\n\t// if all suspended descendants have not yet been resolved.\n\tif (\n\t\t!list.props.revealOrder ||\n\t\t(list.props.revealOrder[0] === 't' && list._map.size)\n\t) {\n\t\treturn;\n\t}\n\n\t// Walk the currently suspended children in order, calling their\n\t// stored callbacks on the way. Stop if we encounter a child that\n\t// has not been completely resolved yet.\n\tnode = list._next;\n\twhile (node) {\n\t\twhile (node.length > 3) {\n\t\t\tnode.pop()();\n\t\t}\n\t\tif (node[RESOLVED_COUNT] < node[SUSPENDED_COUNT]) {\n\t\t\tbreak;\n\t\t}\n\t\tlist._next = node = node[NEXT_NODE];\n\t}\n};\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspenseList.prototype = new Component();\n\nSuspenseList.prototype._suspended = function(child) {\n\tconst list = this;\n\tconst delegated = suspended(list._vnode);\n\n\tlet node = list._map.get(child);\n\tnode[SUSPENDED_COUNT]++;\n\n\treturn unsuspend => {\n\t\tconst wrappedUnsuspend = () => {\n\t\t\tif (!list.props.revealOrder) {\n\t\t\t\t// Special case the undefined (falsy) revealOrder, as there\n\t\t\t\t// is no need to coordinate a specific order or unsuspends.\n\t\t\t\tunsuspend();\n\t\t\t} else {\n\t\t\t\tnode.push(unsuspend);\n\t\t\t\tresolve(list, child, node);\n\t\t\t}\n\t\t};\n\t\tif (delegated) {\n\t\t\tdelegated(wrappedUnsuspend);\n\t\t} else {\n\t\t\twrappedUnsuspend();\n\t\t}\n\t};\n};\n\nSuspenseList.prototype.render = function(props) {\n\tthis._next = null;\n\tthis._map = new Map();\n\n\tconst children = toChildArray(props.children);\n\tif (props.revealOrder && props.revealOrder[0] === 'b') {\n\t\t// If order === 'backwards' (or, well, anything starting with a 'b')\n\t\t// then flip the child list around so that the last child will be\n\t\t// the first in the linked list.\n\t\tchildren.reverse();\n\t}\n\t// Build the linked list. Iterate through the children in reverse order\n\t// so that `_next` points to the first linked list node to be resolved.\n\tfor (let i = children.length; i--; ) {\n\t\t// Create a new linked list node as an array of form:\n\t\t// \t[suspended_count, resolved_count, next_node]\n\t\t// where suspended_count and resolved_count are numeric counters for\n\t\t// keeping track how many times a node has been suspended and resolved.\n\t\t//\n\t\t// Note that suspended_count starts from 1 instead of 0, so we can block\n\t\t// processing callbacks until componentDidMount has been called. In a sense\n\t\t// node is suspended at least until componentDidMount gets called!\n\t\t//\n\t\t// Pending callbacks are added to the end of the node:\n\t\t// \t[suspended_count, resolved_count, next_node, callback_0, callback_1, ...]\n\t\tthis._map.set(children[i], (this._next = [1, 0, this._next]));\n\t}\n\treturn props.children;\n};\n\nSuspenseList.prototype.componentDidUpdate = SuspenseList.prototype.componentDidMount = function() {\n\t// Iterate through all children after mounting for two reasons:\n\t// 1. As each node[SUSPENDED_COUNT] starts from 1, this iteration increases\n\t//    each node[RELEASED_COUNT] by 1, therefore balancing the counters.\n\t//    The nodes can now be completely consumed from the linked list.\n\t// 2. Handle nodes that might have gotten resolved between render and\n\t//    componentDidMount.\n\tthis._map.forEach((node, child) => {\n\t\tresolve(this, child, node);\n\t});\n};\n","import { createElement, hydrate, render, __u as _unmount } from 'preact';\n\nfunction ContextProvider(props) {\n\tthis.getChildContext = () => props.context;\n\treturn props.children;\n}\n\n/**\n * Portal component\n * @param {object | null | undefined} props\n *\n * TODO: this could use the \"fake root node\" trick from the partial hydration demo\n */\nfunction Portal(props) {\n\tconst _this = this;\n\tlet container = props._container;\n\tlet wrap = createElement(\n\t\tContextProvider,\n\t\t{ context: _this.context },\n\t\tprops._vnode\n\t);\n\n\t_this.componentWillUnmount = function() {\n\t\tlet parent = _this._temp.parentNode;\n\t\tif (parent) parent.removeChild(_this._temp);\n\t\t_unmount(_this._wrap);\n\t};\n\n\t// When we change container we should clear our old container and\n\t// indicate a new mount.\n\tif (_this._container && _this._container !== container) {\n\t\t_this.componentWillUnmount();\n\t\t// if (_this._temp.parentNode) _this._container.removeChild(_this._temp);\n\t\t// _unmount(_this._wrap);\n\t\t_this._hasMounted = false;\n\t}\n\n\t// When props.vnode is undefined/false/null we are dealing with some kind of\n\t// conditional vnode. This should not trigger a render.\n\tif (props._vnode) {\n\t\tif (!_this._hasMounted) {\n\t\t\t// Create a placeholder that we can use to insert into.\n\t\t\t_this._temp = document.createTextNode('');\n\t\t\t// temporarily store the current children of the container to restore them after render\n\t\t\t_this._children = container._children;\n\t\t\t// Hydrate existing nodes to keep the dom intact, when rendering\n\t\t\t// wrap into the container.\n\t\t\thydrate('', container);\n\t\t\t// Append to the container (this matches React's behavior)\n\t\t\tcontainer.appendChild(_this._temp);\n\t\t\t// At this point we have mounted and should set our container.\n\t\t\t_this._hasMounted = true;\n\t\t\t_this._container = container;\n\t\t\t// Render our wrapping element into temp.\n\t\t\trender(wrap, container, _this._temp);\n\t\t\t// restore the previous children of the container\n\t\t\tcontainer._children = _this._children;\n\t\t\t// store the children of the new vnode to be used in subsequent re-renders\n\t\t\t_this._children = _this._temp._children;\n\t\t} else {\n\t\t\t// When we have mounted and the vnode is present it means the\n\t\t\t// props have changed or a parent is triggering a rerender.\n\t\t\t// This implies we only need to call render. But we need to keep\n\t\t\t// the old tree around, otherwise will treat the vnodes as new and\n\t\t\t// will wrongly call `componentDidMount` on them\n\t\t\tcontainer._children = _this._children;\n\t\t\trender(wrap, container);\n\t\t\t_this._children = container._children;\n\t\t}\n\t}\n\t// When we come from a conditional render, on a mounted\n\t// portal we should clear the DOM.\n\telse if (_this._hasMounted) {\n\t\t_this.componentWillUnmount();\n\t\t// if (_this._temp.parentNode) _this._container.removeChild(_this._temp);\n\t\t// _unmount(_this._wrap);\n\t}\n\t// Set the wrapping element for future unmounting.\n\t_this._wrap = wrap;\n}\n\n/**\n * Create a `Portal` to continue rendering the vnode tree at a different DOM node\n * @param {import('./internal').VNode} vnode The vnode to render\n * @param {import('./internal').PreactElement} container The DOM node to continue rendering in to.\n */\nexport function createPortal(vnode, container) {\n\treturn createElement(Portal, { _vnode: vnode, _container: container });\n}\n","import {\n\trender as preactRender,\n\thydrate as preactHydrate,\n\toptions,\n\ttoChildArray,\n\tComponent\n} from 'preact';\n\nexport const REACT_ELEMENT_TYPE =\n\t(typeof Symbol != 'undefined' && Symbol.for && Symbol.for('react.element')) ||\n\t0xeac7;\n\nconst CAMEL_PROPS = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;\n\n// Input types for which onchange should not be converted to oninput.\n// type=\"file|checkbox|radio\", plus \"range\" in IE11.\n// (IE11 doesn't support Symbol, which we use here to turn `rad` into `ra` which matches \"range\")\nconst ONCHANGE_INPUT_TYPES =\n\ttypeof Symbol != 'undefined' ? /fil|che|rad/i : /fil|che|ra/i;\n\n// Some libraries like `react-virtualized` explicitly check for this.\nComponent.prototype.isReactComponent = {};\n\n// `UNSAFE_*` lifecycle hooks\n// Preact only ever invokes the unprefixed methods.\n// Here we provide a base \"fallback\" implementation that calls any defined UNSAFE_ prefixed method.\n// - If a component defines its own `componentDidMount()` (including via defineProperty), use that.\n// - If a component defines `UNSAFE_componentDidMount()`, `componentDidMount` is the alias getter/setter.\n// - If anything assigns to an `UNSAFE_*` property, the assignment is forwarded to the unprefixed property.\n// See https://github.com/preactjs/preact/issues/1941\n[\n\t'componentWillMount',\n\t'componentWillReceiveProps',\n\t'componentWillUpdate'\n].forEach(key => {\n\tObject.defineProperty(Component.prototype, key, {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn this['UNSAFE_' + key];\n\t\t},\n\t\tset(v) {\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: v\n\t\t\t});\n\t\t}\n\t});\n});\n\n/**\n * Proxy render() since React returns a Component reference.\n * @param {import('./internal').VNode} vnode VNode tree to render\n * @param {import('./internal').PreactElement} parent DOM node to render vnode tree into\n * @param {() => void} [callback] Optional callback that will be called after rendering\n * @returns {import('./internal').Component | null} The root component reference or null\n */\nexport function render(vnode, parent, callback) {\n\t// React destroys any existing DOM nodes, see #1727\n\t// ...but only on the first render, see #1828\n\tif (parent._children == null) {\n\t\tparent.textContent = '';\n\t}\n\n\tpreactRender(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nexport function hydrate(vnode, parent, callback) {\n\tpreactHydrate(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nlet oldEventHook = options.event;\noptions.event = e => {\n\tif (oldEventHook) e = oldEventHook(e);\n\te.persist = empty;\n\te.isPropagationStopped = isPropagationStopped;\n\te.isDefaultPrevented = isDefaultPrevented;\n\treturn (e.nativeEvent = e);\n};\n\nfunction empty() {}\n\nfunction isPropagationStopped() {\n\treturn this.cancelBubble;\n}\n\nfunction isDefaultPrevented() {\n\treturn this.defaultPrevented;\n}\n\nlet classNameDescriptor = {\n\tconfigurable: true,\n\tget() {\n\t\treturn this.class;\n\t}\n};\n\nlet oldVNodeHook = options.vnode;\noptions.vnode = vnode => {\n\tvnode.$$typeof = REACT_ELEMENT_TYPE;\n\n\tlet type = vnode.type;\n\tlet props = vnode.props;\n\n\tconst isComponent = typeof type == 'function';\n\tif (isComponent) {\n\t\tif ((classNameDescriptor.enumerable = 'className' in props)) {\n\t\t\tprops.class = props.className;\n\t\t}\n\t\tObject.defineProperty(props, 'className', classNameDescriptor);\n\t} else if (type) {\n\t\tlet normalizedProps = {};\n\n\t\tfor (let i in props) {\n\t\t\tlet value = props[i];\n\n\t\t\t// Alias `class` prop to `className` if available\n\t\t\tif (i === 'className') {\n\t\t\t\tnormalizedProps.class = value;\n\t\t\t\tclassNameDescriptor.enumerable = true;\n\t\t\t}\n\n\t\t\tif (i === 'defaultValue' && 'value' in props && props.value == null) {\n\t\t\t\t// `defaultValue` is treated as a fallback `value` when a value prop is present but null/undefined.\n\t\t\t\t// `defaultValue` for Elements with no value prop is the same as the DOM defaultValue property.\n\t\t\t\ti = 'value';\n\t\t\t} else if (i === 'download' && value === true) {\n\t\t\t\t// Calling `setAttribute` with a truthy value will lead to it being\n\t\t\t\t// passed as a stringified value, e.g. `download=\"true\"`. React\n\t\t\t\t// converts it to an empty string instead, otherwise the attribute\n\t\t\t\t// value will be used as the file name and the file will be called\n\t\t\t\t// \"true\" upon downloading it.\n\t\t\t\tvalue = '';\n\t\t\t} else if (/ondoubleclick/i.test(i)) {\n\t\t\t\ti = 'ondblclick';\n\t\t\t} else if (\n\t\t\t\t/^onchange(textarea|input)/i.test(i + type) &&\n\t\t\t\t!ONCHANGE_INPUT_TYPES.test(props.type)\n\t\t\t) {\n\t\t\t\ti = 'oninput';\n\t\t\t} else if (/^on(Ani|Tra|Tou|BeforeInp)/.test(i)) {\n\t\t\t\ti = i.toLowerCase();\n\t\t\t} else if (CAMEL_PROPS.test(i)) {\n\t\t\t\ti = i.replace(/[A-Z0-9]/, '-$&').toLowerCase();\n\t\t\t} else if (value === null) {\n\t\t\t\tvalue = undefined;\n\t\t\t}\n\n\t\t\tnormalizedProps[i] = value;\n\t\t}\n\n\t\tObject.defineProperty(normalizedProps, 'className', classNameDescriptor);\n\n\t\t// Add support for array select values: <select multiple value={[]} />\n\t\tif (\n\t\t\ttype == 'select' &&\n\t\t\tnormalizedProps.multiple &&\n\t\t\tArray.isArray(normalizedProps.value)\n\t\t) {\n\t\t\t// forEach() always returns undefined, which we abuse here to unset the value prop.\n\t\t\tnormalizedProps.value = toChildArray(props.children).forEach(child => {\n\t\t\t\tchild.props.selected =\n\t\t\t\t\tnormalizedProps.value.indexOf(child.props.value) != -1;\n\t\t\t});\n\t\t}\n\n\t\tvnode.props = normalizedProps;\n\t}\n\n\tif (oldVNodeHook) oldVNodeHook(vnode);\n};\n\n// Only needed for react-relay\nlet currentComponent;\nconst oldBeforeRender = options._render;\noptions._render = function(vnode) {\n\tif (oldBeforeRender) {\n\t\toldBeforeRender(vnode);\n\t}\n\tcurrentComponent = vnode._component;\n};\n\n// This is a very very private internal function for React it\n// is used to sort-of do runtime dependency injection. So far\n// only `react-relay` makes use of it. It uses it to read the\n// context value.\nexport const __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = {\n\tReactCurrentDispatcher: {\n\t\tcurrent: {\n\t\t\treadContext(context) {\n\t\t\t\treturn currentComponent._globalContext[context._id].props.value;\n\t\t\t}\n\t\t}\n\t}\n};\n","import {\n\tcreateElement,\n\trender as preactRender,\n\tcloneElement as preactCloneElement,\n\tcreateRef,\n\tComponent,\n\tcreateContext,\n\tFragment\n} from 'preact';\nimport {\n\tuseState,\n\tuseReducer,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseRef,\n\tuseImperativeHandle,\n\tuseMemo,\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue\n} from 'preact/hooks';\nimport { PureComponent } from './PureComponent';\nimport { memo } from './memo';\nimport { forwardRef } from './forwardRef';\nimport { Children } from './Children';\nimport { Suspense, lazy } from './suspense';\nimport { SuspenseList } from './suspense-list';\nimport { createPortal } from './portals';\nimport {\n\thydrate,\n\trender,\n\tREACT_ELEMENT_TYPE,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n} from './render';\n\nconst version = '16.8.0'; // trick libraries to think we are react\n\n/**\n * Legacy version of createElement.\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component constructor\n */\nfunction createFactory(type) {\n\treturn createElement.bind(null, type);\n}\n\n/**\n * Check if the passed element is a valid (p)react node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isValidElement(element) {\n\treturn !!element && element.$$typeof === REACT_ELEMENT_TYPE;\n}\n\n/**\n * Wrap `cloneElement` to abort if the passed element is not a valid element and apply\n * all vnode normalizations.\n * @param {import('./internal').VNode} element The vnode to clone\n * @param {object} props Props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Optional component children\n */\nfunction cloneElement(element) {\n\tif (!isValidElement(element)) return element;\n\treturn preactCloneElement.apply(null, arguments);\n}\n\n/**\n * Remove a component tree from the DOM, including state and event handlers.\n * @param {import('./internal').PreactElement} container\n * @returns {boolean}\n */\nfunction unmountComponentAtNode(container) {\n\tif (container._children) {\n\t\tpreactRender(null, container);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**\n * Get the matching DOM node for a component\n * @param {import('./internal').Component} component\n * @returns {import('./internal').PreactElement | null}\n */\nfunction findDOMNode(component) {\n\treturn (\n\t\t(component &&\n\t\t\t(component.base || (component.nodeType === 1 && component))) ||\n\t\tnull\n\t);\n}\n\n/**\n * Deprecated way to control batched rendering inside the reconciler, but we\n * already schedule in batches inside our rendering code\n * @template Arg\n * @param {(arg: Arg) => void} callback function that triggers the updated\n * @param {Arg} [arg] Optional argument that can be passed to the callback\n */\n// eslint-disable-next-line camelcase\nconst unstable_batchedUpdates = (callback, arg) => callback(arg);\n\n/**\n * Strict Mode is not implemented in Preact, so we provide a stand-in for it\n * that just renders its children without imposing any restrictions.\n */\nconst StrictMode = Fragment;\n\nexport * from 'preact/hooks';\nexport {\n\tversion,\n\tChildren,\n\trender,\n\thydrate,\n\tunmountComponentAtNode,\n\tcreatePortal,\n\tcreateElement,\n\tcreateContext,\n\tcreateFactory,\n\tcloneElement,\n\tcreateRef,\n\tFragment,\n\tisValidElement,\n\tfindDOMNode,\n\tComponent,\n\tPureComponent,\n\tmemo,\n\tforwardRef,\n\t// eslint-disable-next-line camelcase\n\tunstable_batchedUpdates,\n\tStrictMode,\n\tSuspense,\n\tSuspenseList,\n\tlazy,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n\n// React copies the named exports to the default one.\nexport default {\n\tuseState,\n\tuseReducer,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseRef,\n\tuseImperativeHandle,\n\tuseMemo,\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue,\n\tversion,\n\tChildren,\n\trender,\n\thydrate,\n\tunmountComponentAtNode,\n\tcreatePortal,\n\tcreateElement,\n\tcreateContext,\n\tcreateFactory,\n\tcloneElement,\n\tcreateRef,\n\tFragment,\n\tisValidElement,\n\tfindDOMNode,\n\tComponent,\n\tPureComponent,\n\tmemo,\n\tforwardRef,\n\tunstable_batchedUpdates,\n\tStrictMode,\n\tSuspense,\n\tSuspenseList,\n\tlazy,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n"],"names":["assign","obj","props","i","shallowDiffers","a","b","PureComponent","p","memo","c","comparer","shouldUpdate","nextProps","ref","this","updateRef","call","current","Memoed","shouldComponentUpdate","createElement","displayName","name","prototype","isReactComponent","Component","isPureReactComponent","state","oldDiffHook","options","vnode","type","REACT_FORWARD_SYMBOL","Symbol","for","forwardRef","fn","Forwarded","clone","$$typeof","render","mapFn","children","toChildArray","map","Children","forEach","count","length","only","normalized","toArray","oldCatchError","detachedClone","removeOriginal","Suspense","_suspenders","suspended","component","_suspended","lazy","loader","prom","error","Lazy","then","exports","default","e","SuspenseList","_next","_map","newVNode","oldVNode","promise","suspendingComponent","push","resolve","resolved","onResolved","componentWillUnmount","onSuspensionComplete","setState","pop","forceUpdate","Fragment","fallback","list","child","node","delete","revealOrder","size","ContextProvider","getChildContext","context","Portal","_this","container","_container","wrap","parent","_temp","parentNode","removeChild","_unmount","_wrap","_hasMounted","document","createTextNode","hydrate","appendChild","createPortal","delegated","get","unsuspend","wrappedUnsuspend","Map","reverse","set","componentDidUpdate","componentDidMount","REACT_ELEMENT_TYPE","CAMEL_PROPS","ONCHANGE_INPUT_TYPES","callback","textContent","preactRender","preactHydrate","key","Object","defineProperty","configurable","v","writable","value","oldEventHook","event","empty","isPropagationStopped","cancelBubble","isDefaultPrevented","defaultPrevented","persist","nativeEvent","currentComponent","classNameDescriptor","class","oldVNodeHook","enumerable","className","normalizedProps","test","toLowerCase","replace","undefined","multiple","Array","isArray","selected","indexOf","oldBeforeRender","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentDispatcher","readContext","version","createFactory","bind","isValidElement","element","cloneElement","preactCloneElement","apply","arguments","unmountComponentAtNode","findDOMNode","base","nodeType","unstable_batchedUpdates","arg","StrictMode","useState","useReducer","useEffect","useLayoutEffect","useRef","useImperativeHandle","useMemo","useCallback","useContext","useDebugValue","createContext","createRef"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/preact/compat/dist/compat.umd.js b/node_modules/preact/compat/dist/compat.umd.js
index 6f12988..63b837d 100644
--- a/node_modules/preact/compat/dist/compat.umd.js
+++ b/node_modules/preact/compat/dist/compat.umd.js
@@ -1,2 +1,2 @@
-!function(n,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("preact/hooks"),require("preact")):"function"==typeof define&&define.amd?define(["exports","preact/hooks","preact"],t):t(n.preactCompat={},n.preactHooks,n.preact)}(this,function(n,t,e){function r(n,t){for(var e in t)n[e]=t[e];return n}function u(n,t){for(var e in n)if("__source"!==e&&!(e in t))return!0;for(var r in t)if("__source"!==r&&n[r]!==t[r])return!0;return!1}function i(n){this.props=n}function o(n,t){function r(n){var e=this.props.ref,r=e==n.ref;return!r&&e&&(e.call?e(null):e.current=null),t?!t(this.props,n)||!r:u(this.props,n)}function i(t){return this.shouldComponentUpdate=r,e.createElement(n,t)}return i.displayName="Memo("+(n.displayName||n.name)+")",i.prototype.isReactComponent=!0,i.__f=!0,i}(i.prototype=new e.Component).isPureReactComponent=!0,i.prototype.shouldComponentUpdate=function(n,t){return u(this.props,n)||u(this.state,t)};var f=e.options.__b;e.options.__b=function(n){n.type&&n.type.__f&&n.ref&&(n.props.ref=n.ref,n.ref=null),f&&f(n)};var c="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.forward_ref")||3911;function l(n){function t(t,e){var u=r({},t);return delete u.ref,n(u,(e=t.ref||e)&&("object"!=typeof e||"current"in e)?e:null)}return t.$$typeof=c,t.render=t,t.prototype.isReactComponent=t.__f=!0,t.displayName="ForwardRef("+(n.displayName||n.name)+")",t}var a=function(n,t){return n?e.toChildArray(e.toChildArray(n).map(t)):null},s={map:a,forEach:a,count:function(n){return n?e.toChildArray(n).length:0},only:function(n){var t=e.toChildArray(n);if(1!==t.length)throw"Children.only";return t[0]},toArray:e.toChildArray},v=e.options.__e;function h(n){return n&&((n=r({},n)).__c=null,n.__k=n.__k&&n.__k.map(h)),n}function d(n){return n&&(n.__v=null,n.__k=n.__k&&n.__k.map(d)),n}function p(){this.__u=0,this.t=null,this.__b=null}function m(n){var t=n.__.__c;return t&&t.u&&t.u(n)}function y(n){var t,r,u;function i(i){if(t||(t=n()).then(function(n){r=n.default||n},function(n){u=n}),u)throw u;if(!r)throw t;return e.createElement(r,i)}return i.displayName="Lazy",i.__f=!0,i}function _(){this.i=null,this.o=null}e.options.__e=function(n,t,e){if(n.then)for(var r,u=t;u=u.__;)if((r=u.__c)&&r.__c)return null==t.__e&&(t.__e=e.__e,t.__k=e.__k),r.__c(n,t.__c);v(n,t,e)},(p.prototype=new e.Component).__c=function(n,t){var e=this;null==e.t&&(e.t=[]),e.t.push(t);var r=m(e.__v),u=!1,i=function(){u||(u=!0,t.componentWillUnmount=t.__c,r?r(o):o())};t.__c=t.componentWillUnmount,t.componentWillUnmount=function(){i(),t.__c&&t.__c()};var o=function(){var n;if(!--e.__u)for(e.__v.__k[0]=d(e.state.u),e.setState({u:e.__b=null});n=e.t.pop();)n.forceUpdate()};e.__u++||e.setState({u:e.__b=e.__v.__k[0]}),n.then(i,i)},p.prototype.componentWillUnmount=function(){this.t=[]},p.prototype.render=function(n,t){return this.__b&&(this.__v.__k&&(this.__v.__k[0]=h(this.__b)),this.__b=null),[e.createElement(e.Fragment,null,t.u?null:n.children),t.u&&n.fallback]};var b=function(n,t,e){if(++e[1]===e[0]&&n.o.delete(t),n.props.revealOrder&&("t"!==n.props.revealOrder[0]||!n.o.size))for(e=n.i;e;){for(;e.length>3;)e.pop()();if(e[1]<e[0])break;n.i=e=e[2]}};function S(n){return this.getChildContext=function(){return n.context},n.children}function E(n){var t=this,r=n.l,u=e.createElement(S,{context:t.context},n.__v);t.componentWillUnmount=function(){var n=t.s.parentNode;n&&n.removeChild(t.s),e.__u(t.v)},t.l&&t.l!==r&&(t.componentWillUnmount(),t.h=!1),n.__v?t.h?(r.__k=t.__k,e.render(u,r),t.__k=r.__k):(t.s=document.createTextNode(""),t.__k=r.__k,e.hydrate("",r),r.appendChild(t.s),t.h=!0,t.l=r,e.render(u,r,t.s),r.__k=t.__k,t.__k=t.s.__k):t.h&&t.componentWillUnmount(),t.v=u}function w(n,t){return e.createElement(E,{__v:n,l:t})}(_.prototype=new e.Component).u=function(n){var t=this,e=m(t.__v),r=t.o.get(n);return r[0]++,function(u){var i=function(){t.props.revealOrder?(r.push(u),b(t,n,r)):u()};e?e(i):i()}},_.prototype.render=function(n){this.i=null,this.o=new Map;var t=e.toChildArray(n.children);n.revealOrder&&"b"===n.revealOrder[0]&&t.reverse();for(var r=t.length;r--;)this.o.set(t[r],this.i=[1,0,this.i]);return n.children},_.prototype.componentDidUpdate=_.prototype.componentDidMount=function(){var n=this;this.o.forEach(function(t,e){b(n,e,t)})};var C=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;e.Component.prototype.isReactComponent={};var R="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103;function g(n,t,r){if(null==t.__k)for(;t.firstChild;)t.removeChild(t.firstChild);return e.render(n,t),"function"==typeof r&&r(),n?n.__c:null}function x(n,t,r){return e.hydrate(n,t),"function"==typeof r&&r(),n?n.__c:null}var A=e.options.event;function N(n,t){n["UNSAFE_"+t]&&!n[t]&&Object.defineProperty(n,t,{get:function(){return this["UNSAFE_"+t]},set:function(n){this["UNSAFE_"+t]=n}})}e.options.event=function(n){A&&(n=A(n)),n.persist=function(){};var t=!1,e=!1,r=n.stopPropagation;n.stopPropagation=function(){r.call(n),t=!0};var u=n.preventDefault;return n.preventDefault=function(){u.call(n),e=!0},n.isPropagationStopped=function(){return t},n.isDefaultPrevented=function(){return e},n.nativeEvent=n};var U,O={configurable:!0,get:function(){return this.class}},k=e.options.vnode;e.options.vnode=function(n){n.$$typeof=R;var t=n.type,r=n.props;if(t){var u;if(r.class!=r.className&&(O.enumerable="className"in r,null!=r.className&&(r.class=r.className),Object.defineProperty(r,"className",O)),"function"!=typeof t)for(u in r.defaultValue&&void 0!==r.value&&(r.value||0===r.value||(r.value=r.defaultValue),r.defaultValue=void 0),"select"===t&&r.multiple&&Array.isArray(r.value)&&(e.toChildArray(r.children).forEach(function(n){-1!=r.value.indexOf(n.props.value)&&(n.props.selected=!0)}),r.value=void 0),!0===r.download&&(r.download=""),r){var i=C.test(u);i&&(n.props[u.replace(/[A-Z0-9]/,"-$&").toLowerCase()]=r[u]),(i||null===r[u])&&(r[u]=void 0)}else t.prototype&&!t.prototype.p&&(t.prototype.p=!0,N(t.prototype,"componentWillMount"),N(t.prototype,"componentWillReceiveProps"),N(t.prototype,"componentWillUpdate"));!function(t){var e=n.type,r=n.props;if(r&&"string"==typeof e){var u={};for(var i in r)/^on(Ani|Tra|Tou)/.test(i)&&(r[i.toLowerCase()]=r[i],delete r[i]),u[i.toLowerCase()]=i;if(u.ondoubleclick&&(r.ondblclick=r[u.ondoubleclick],delete r[u.ondoubleclick]),u.onbeforeinput&&(r.onbeforeinput=r[u.onbeforeinput],delete r[u.onbeforeinput]),u.onchange&&("textarea"===e||"input"===e.toLowerCase()&&!/^fil|che|ra/i.test(r.type))){var o=u.oninput||"oninput";r[o]||(r[o]=r[u.onchange],delete r[u.onchange])}}}()}k&&k(n)};var F=e.options.__r;e.options.__r=function(n){F&&F(n),U=n.__c};var L={ReactCurrentDispatcher:{current:{readContext:function(n){return U.__n[n.__c].props.value}}}};function M(n){return e.createElement.bind(null,n)}function j(n){return!!n&&n.$$typeof===R}function D(n){return j(n)?e.cloneElement.apply(null,arguments):n}function T(n){return!!n.__k&&(e.render(null,n),!0)}function W(n){return n&&(n.base||1===n.nodeType&&n)||null}var I=function(n,t){return n(t)},P=e.Fragment,z={useState:t.useState,useReducer:t.useReducer,useEffect:t.useEffect,useLayoutEffect:t.useLayoutEffect,useRef:t.useRef,useImperativeHandle:t.useImperativeHandle,useMemo:t.useMemo,useCallback:t.useCallback,useContext:t.useContext,useDebugValue:t.useDebugValue,version:"16.8.0",Children:s,render:g,hydrate:x,unmountComponentAtNode:T,createPortal:w,createElement:e.createElement,createContext:e.createContext,createFactory:M,cloneElement:D,createRef:e.createRef,Fragment:e.Fragment,isValidElement:j,findDOMNode:W,Component:e.Component,PureComponent:i,memo:o,forwardRef:l,unstable_batchedUpdates:I,StrictMode:P,Suspense:p,SuspenseList:_,lazy:y,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:L};Object.keys(t).forEach(function(e){n[e]=t[e]}),n.createElement=e.createElement,n.createContext=e.createContext,n.createRef=e.createRef,n.Fragment=e.Fragment,n.Component=e.Component,n.version="16.8.0",n.Children=s,n.render=g,n.hydrate=x,n.unmountComponentAtNode=T,n.createPortal=w,n.createFactory=M,n.cloneElement=D,n.isValidElement=j,n.findDOMNode=W,n.PureComponent=i,n.memo=o,n.forwardRef=l,n.unstable_batchedUpdates=I,n.StrictMode=P,n.Suspense=p,n.SuspenseList=_,n.lazy=y,n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=L,n.default=z});
+!function(n,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("preact/hooks"),require("preact")):"function"==typeof define&&define.amd?define(["exports","preact/hooks","preact"],t):t(n.preactCompat={},n.preactHooks,n.preact)}(this,function(n,t,e){function r(n,t){for(var e in t)n[e]=t[e];return n}function u(n,t){for(var e in n)if("__source"!==e&&!(e in t))return!0;for(var r in t)if("__source"!==r&&n[r]!==t[r])return!0;return!1}function i(n){this.props=n}function o(n,t){function r(n){var e=this.props.ref,r=e==n.ref;return!r&&e&&(e.call?e(null):e.current=null),t?!t(this.props,n)||!r:u(this.props,n)}function i(t){return this.shouldComponentUpdate=r,e.createElement(n,t)}return i.displayName="Memo("+(n.displayName||n.name)+")",i.prototype.isReactComponent=!0,i.__f=!0,i}(i.prototype=new e.Component).isPureReactComponent=!0,i.prototype.shouldComponentUpdate=function(n,t){return u(this.props,n)||u(this.state,t)};var c=e.options.__b;e.options.__b=function(n){n.type&&n.type.__f&&n.ref&&(n.props.ref=n.ref,n.ref=null),c&&c(n)};var f="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.forward_ref")||3911;function l(n){function t(t,e){var u=r({},t);return delete u.ref,n(u,(e=t.ref||e)&&("object"!=typeof e||"current"in e)?e:null)}return t.$$typeof=f,t.render=t,t.prototype.isReactComponent=t.__f=!0,t.displayName="ForwardRef("+(n.displayName||n.name)+")",t}var a=function(n,t){return null==n?null:e.toChildArray(e.toChildArray(n).map(t))},s={map:a,forEach:a,count:function(n){return n?e.toChildArray(n).length:0},only:function(n){var t=e.toChildArray(n);if(1!==t.length)throw"Children.only";return t[0]},toArray:e.toChildArray},h=e.options.__e;function d(n){return n&&((n=r({},n)).__c=null,n.__k=n.__k&&n.__k.map(d)),n}function v(n){return n&&(n.__v=null,n.__k=n.__k&&n.__k.map(v)),n}function p(){this.__u=0,this.t=null,this.__b=null}function m(n){var t=n.__.__c;return t&&t.u&&t.u(n)}function b(n){var t,r,u;function i(i){if(t||(t=n()).then(function(n){r=n.default||n},function(n){u=n}),u)throw u;if(!r)throw t;return e.createElement(r,i)}return i.displayName="Lazy",i.__f=!0,i}function y(){this.i=null,this.o=null}e.options.__e=function(n,t,e){if(n.then)for(var r,u=t;u=u.__;)if((r=u.__c)&&r.__c)return null==t.__e&&(t.__e=e.__e,t.__k=e.__k),r.__c(n,t.__c);h(n,t,e)},(p.prototype=new e.Component).__c=function(n,t){var e=this;null==e.t&&(e.t=[]),e.t.push(t);var r=m(e.__v),u=!1,i=function(){u||(u=!0,t.componentWillUnmount=t.__c,r?r(o):o())};t.__c=t.componentWillUnmount,t.componentWillUnmount=function(){i(),t.__c&&t.__c()};var o=function(){var n;if(!--e.__u)for(e.__v.__k[0]=v(e.state.u),e.setState({u:e.__b=null});n=e.t.pop();)n.forceUpdate()};e.__u++||e.setState({u:e.__b=e.__v.__k[0]}),n.then(i,i)},p.prototype.componentWillUnmount=function(){this.t=[]},p.prototype.render=function(n,t){return this.__b&&(this.__v.__k&&(this.__v.__k[0]=d(this.__b)),this.__b=null),[e.createElement(e.Fragment,null,t.u?null:n.children),t.u&&n.fallback]};var _=function(n,t,e){if(++e[1]===e[0]&&n.o.delete(t),n.props.revealOrder&&("t"!==n.props.revealOrder[0]||!n.o.size))for(e=n.i;e;){for(;e.length>3;)e.pop()();if(e[1]<e[0])break;n.i=e=e[2]}};function S(n){return this.getChildContext=function(){return n.context},n.children}function w(n){var t=this,r=n.l,u=e.createElement(S,{context:t.context},n.__v);t.componentWillUnmount=function(){var n=t.s.parentNode;n&&n.removeChild(t.s),e.__u(t.h)},t.l&&t.l!==r&&(t.componentWillUnmount(),t.v=!1),n.__v?t.v?(r.__k=t.__k,e.render(u,r),t.__k=r.__k):(t.s=document.createTextNode(""),t.__k=r.__k,e.hydrate("",r),r.appendChild(t.s),t.v=!0,t.l=r,e.render(u,r,t.s),r.__k=t.__k,t.__k=t.s.__k):t.v&&t.componentWillUnmount(),t.h=u}function E(n,t){return e.createElement(w,{__v:n,l:t})}(y.prototype=new e.Component).u=function(n){var t=this,e=m(t.__v),r=t.o.get(n);return r[0]++,function(u){var i=function(){t.props.revealOrder?(r.push(u),_(t,n,r)):u()};e?e(i):i()}},y.prototype.render=function(n){this.i=null,this.o=new Map;var t=e.toChildArray(n.children);n.revealOrder&&"b"===n.revealOrder[0]&&t.reverse();for(var r=t.length;r--;)this.o.set(t[r],this.i=[1,0,this.i]);return n.children},y.prototype.componentDidUpdate=y.prototype.componentDidMount=function(){var n=this;this.o.forEach(function(t,e){_(n,e,t)})};var g="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103,C=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,R="undefined"!=typeof Symbol?/fil|che|rad/i:/fil|che|ra/i;function x(n,t,r){return null==t.__k&&(t.textContent=""),e.render(n,t),"function"==typeof r&&r(),n?n.__c:null}function N(n,t,r){return e.hydrate(n,t),"function"==typeof r&&r(),n?n.__c:null}e.Component.prototype.isReactComponent={},["componentWillMount","componentWillReceiveProps","componentWillUpdate"].forEach(function(n){Object.defineProperty(e.Component.prototype,n,{configurable:!0,get:function(){return this["UNSAFE_"+n]},set:function(t){Object.defineProperty(this,n,{configurable:!0,writable:!0,value:t})}})});var O=e.options.event;function k(){}function A(){return this.cancelBubble}function j(){return this.defaultPrevented}e.options.event=function(n){return O&&(n=O(n)),n.persist=k,n.isPropagationStopped=A,n.isDefaultPrevented=j,n.nativeEvent=n};var L,U={configurable:!0,get:function(){return this.class}},M=e.options.vnode;e.options.vnode=function(n){n.$$typeof=g;var t=n.type,r=n.props;if("function"==typeof t)(U.enumerable="className"in r)&&(r.class=r.className),Object.defineProperty(r,"className",U);else if(t){var u={};for(var i in r){var o=r[i];"className"===i&&(u.class=o,U.enumerable=!0),"defaultValue"===i&&"value"in r&&null==r.value?i="value":"download"===i&&!0===o?o="":/ondoubleclick/i.test(i)?i="ondblclick":/^onchange(textarea|input)/i.test(i+t)&&!R.test(r.type)?i="oninput":/^on(Ani|Tra|Tou|BeforeInp)/.test(i)?i=i.toLowerCase():C.test(i)?i=i.replace(/[A-Z0-9]/,"-$&").toLowerCase():null===o&&(o=void 0),u[i]=o}Object.defineProperty(u,"className",U),"select"==t&&u.multiple&&Array.isArray(u.value)&&(u.value=e.toChildArray(r.children).forEach(function(n){n.props.selected=-1!=u.value.indexOf(n.props.value)})),n.props=u}M&&M(n)};var D=e.options.__r;e.options.__r=function(n){D&&D(n),L=n.__c};var F={ReactCurrentDispatcher:{current:{readContext:function(n){return L.__n[n.__c].props.value}}}};function I(n){return e.createElement.bind(null,n)}function T(n){return!!n&&n.$$typeof===g}function W(n){return T(n)?e.cloneElement.apply(null,arguments):n}function P(n){return!!n.__k&&(e.render(null,n),!0)}function z(n){return n&&(n.base||1===n.nodeType&&n)||null}var V=function(n,t){return n(t)},q=e.Fragment,B={useState:t.useState,useReducer:t.useReducer,useEffect:t.useEffect,useLayoutEffect:t.useLayoutEffect,useRef:t.useRef,useImperativeHandle:t.useImperativeHandle,useMemo:t.useMemo,useCallback:t.useCallback,useContext:t.useContext,useDebugValue:t.useDebugValue,version:"16.8.0",Children:s,render:x,hydrate:N,unmountComponentAtNode:P,createPortal:E,createElement:e.createElement,createContext:e.createContext,createFactory:I,cloneElement:W,createRef:e.createRef,Fragment:e.Fragment,isValidElement:T,findDOMNode:z,Component:e.Component,PureComponent:i,memo:o,forwardRef:l,unstable_batchedUpdates:V,StrictMode:q,Suspense:p,SuspenseList:y,lazy:b,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:F};Object.keys(t).forEach(function(e){n[e]=t[e]}),n.createElement=e.createElement,n.createContext=e.createContext,n.createRef=e.createRef,n.Fragment=e.Fragment,n.Component=e.Component,n.version="16.8.0",n.Children=s,n.render=x,n.hydrate=N,n.unmountComponentAtNode=P,n.createPortal=E,n.createFactory=I,n.cloneElement=W,n.isValidElement=T,n.findDOMNode=z,n.PureComponent=i,n.memo=o,n.forwardRef=l,n.unstable_batchedUpdates=V,n.StrictMode=q,n.Suspense=p,n.SuspenseList=y,n.lazy=b,n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=F,n.default=B});
 //# sourceMappingURL=compat.umd.js.map
diff --git a/node_modules/preact/compat/dist/compat.umd.js.map b/node_modules/preact/compat/dist/compat.umd.js.map
index 19834aa..4dda06d 100644
--- a/node_modules/preact/compat/dist/compat.umd.js.map
+++ b/node_modules/preact/compat/dist/compat.umd.js.map
@@ -1 +1 @@
-{"version":3,"file":"compat.umd.js","sources":["../src/util.js","../src/PureComponent.js","../src/memo.js","../src/forwardRef.js","../src/Children.js","../src/suspense.js","../src/suspense-list.js","../src/portals.js","../src/render.js","../src/events.js","../src/index.js"],"sourcesContent":["/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Check if two objects have a different shape\n * @param {object} a\n * @param {object} b\n * @returns {boolean}\n */\nexport function shallowDiffers(a, b) {\n\tfor (let i in a) if (i !== '__source' && !(i in b)) return true;\n\tfor (let i in b) if (i !== '__source' && a[i] !== b[i]) return true;\n\treturn false;\n}\n","import { Component } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Component class with a predefined `shouldComponentUpdate` implementation\n */\nexport function PureComponent(p) {\n\tthis.props = p;\n}\nPureComponent.prototype = new Component();\n// Some third-party libraries check if this property is present\nPureComponent.prototype.isPureReactComponent = true;\nPureComponent.prototype.shouldComponentUpdate = function(props, state) {\n\treturn shallowDiffers(this.props, props) || shallowDiffers(this.state, state);\n};\n","import { createElement } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Memoize a component, so that it only updates when the props actually have\n * changed. This was previously known as `React.pure`.\n * @param {import('./internal').FunctionalComponent} c functional component\n * @param {(prev: object, next: object) => boolean} [comparer] Custom equality function\n * @returns {import('./internal').FunctionalComponent}\n */\nexport function memo(c, comparer) {\n\tfunction shouldUpdate(nextProps) {\n\t\tlet ref = this.props.ref;\n\t\tlet updateRef = ref == nextProps.ref;\n\t\tif (!updateRef && ref) {\n\t\t\tref.call ? ref(null) : (ref.current = null);\n\t\t}\n\n\t\tif (!comparer) {\n\t\t\treturn shallowDiffers(this.props, nextProps);\n\t\t}\n\n\t\treturn !comparer(this.props, nextProps) || !updateRef;\n\t}\n\n\tfunction Memoed(props) {\n\t\tthis.shouldComponentUpdate = shouldUpdate;\n\t\treturn createElement(c, props);\n\t}\n\tMemoed.displayName = 'Memo(' + (c.displayName || c.name) + ')';\n\tMemoed.prototype.isReactComponent = true;\n\tMemoed._forwarded = true;\n\treturn Memoed;\n}\n","import { options } from 'preact';\nimport { assign } from './util';\n\nlet oldDiffHook = options._diff;\noptions._diff = vnode => {\n\tif (vnode.type && vnode.type._forwarded && vnode.ref) {\n\t\tvnode.props.ref = vnode.ref;\n\t\tvnode.ref = null;\n\t}\n\tif (oldDiffHook) oldDiffHook(vnode);\n};\n\nexport const REACT_FORWARD_SYMBOL =\n\t(typeof Symbol != 'undefined' &&\n\t\tSymbol.for &&\n\t\tSymbol.for('react.forward_ref')) ||\n\t0xf47;\n\n/**\n * Pass ref down to a child. This is mainly used in libraries with HOCs that\n * wrap components. Using `forwardRef` there is an easy way to get a reference\n * of the wrapped component instead of one of the wrapper itself.\n * @param {import('./index').ForwardFn} fn\n * @returns {import('./internal').FunctionalComponent}\n */\nexport function forwardRef(fn) {\n\t// We always have ref in props.ref, except for\n\t// mobx-react. It will call this function directly\n\t// and always pass ref as the second argument.\n\tfunction Forwarded(props, ref) {\n\t\tlet clone = assign({}, props);\n\t\tdelete clone.ref;\n\t\tref = props.ref || ref;\n\t\treturn fn(\n\t\t\tclone,\n\t\t\t!ref || (typeof ref === 'object' && !('current' in ref)) ? null : ref\n\t\t);\n\t}\n\n\t// mobx-react checks for this being present\n\tForwarded.$$typeof = REACT_FORWARD_SYMBOL;\n\t// mobx-react heavily relies on implementation details.\n\t// It expects an object here with a `render` property,\n\t// and prototype.render will fail. Without this\n\t// mobx-react throws.\n\tForwarded.render = Forwarded;\n\n\tForwarded.prototype.isReactComponent = Forwarded._forwarded = true;\n\tForwarded.displayName = 'ForwardRef(' + (fn.displayName || fn.name) + ')';\n\treturn Forwarded;\n}\n","import { toChildArray } from 'preact';\n\nconst mapFn = (children, fn) => {\n\tif (!children) return null;\n\treturn toChildArray(toChildArray(children).map(fn));\n};\n\n// This API is completely unnecessary for Preact, so it's basically passthrough.\nexport const Children = {\n\tmap: mapFn,\n\tforEach: mapFn,\n\tcount(children) {\n\t\treturn children ? toChildArray(children).length : 0;\n\t},\n\tonly(children) {\n\t\tconst normalized = toChildArray(children);\n\t\tif (normalized.length !== 1) throw 'Children.only';\n\t\treturn normalized[0];\n\t},\n\ttoArray: toChildArray\n};\n","import { Component, createElement, options, Fragment } from 'preact';\nimport { assign } from './util';\n\nconst oldCatchError = options._catchError;\noptions._catchError = function(error, newVNode, oldVNode) {\n\tif (error.then) {\n\t\t/** @type {import('./internal').Component} */\n\t\tlet component;\n\t\tlet vnode = newVNode;\n\n\t\tfor (; (vnode = vnode._parent); ) {\n\t\t\tif ((component = vnode._component) && component._childDidSuspend) {\n\t\t\t\tif (newVNode._dom == null) {\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t}\n\t\t\t\t// Don't call oldCatchError if we found a Suspense\n\t\t\t\treturn component._childDidSuspend(error, newVNode._component);\n\t\t\t}\n\t\t}\n\t}\n\toldCatchError(error, newVNode, oldVNode);\n};\n\nfunction detachedClone(vnode) {\n\tif (vnode) {\n\t\tvnode = assign({}, vnode);\n\t\tvnode._component = null;\n\t\tvnode._children = vnode._children && vnode._children.map(detachedClone);\n\t}\n\treturn vnode;\n}\n\nfunction removeOriginal(vnode) {\n\tif (vnode) {\n\t\tvnode._original = null;\n\t\tvnode._children = vnode._children && vnode._children.map(removeOriginal);\n\t}\n\treturn vnode;\n}\n\n// having custom inheritance instead of a class here saves a lot of bytes\nexport function Suspense() {\n\t// we do not call super here to golf some bytes...\n\tthis._pendingSuspensionCount = 0;\n\tthis._suspenders = null;\n\tthis._detachOnNextRender = null;\n}\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspense.prototype = new Component();\n\n/**\n * @param {Promise} promise The thrown promise\n * @param {Component<any, any>} suspendingComponent The suspending component\n */\nSuspense.prototype._childDidSuspend = function(promise, suspendingComponent) {\n\t/** @type {import('./internal').SuspenseComponent} */\n\tconst c = this;\n\n\tif (c._suspenders == null) {\n\t\tc._suspenders = [];\n\t}\n\tc._suspenders.push(suspendingComponent);\n\n\tconst resolve = suspended(c._vnode);\n\n\tlet resolved = false;\n\tconst onResolved = () => {\n\t\tif (resolved) return;\n\n\t\tresolved = true;\n\t\tsuspendingComponent.componentWillUnmount =\n\t\t\tsuspendingComponent._suspendedComponentWillUnmount;\n\n\t\tif (resolve) {\n\t\t\tresolve(onSuspensionComplete);\n\t\t} else {\n\t\t\tonSuspensionComplete();\n\t\t}\n\t};\n\n\tsuspendingComponent._suspendedComponentWillUnmount =\n\t\tsuspendingComponent.componentWillUnmount;\n\tsuspendingComponent.componentWillUnmount = () => {\n\t\tonResolved();\n\n\t\tif (suspendingComponent._suspendedComponentWillUnmount) {\n\t\t\tsuspendingComponent._suspendedComponentWillUnmount();\n\t\t}\n\t};\n\n\tconst onSuspensionComplete = () => {\n\t\tif (!--c._pendingSuspensionCount) {\n\t\t\tc._vnode._children[0] = removeOriginal(c.state._suspended);\n\t\t\tc.setState({ _suspended: (c._detachOnNextRender = null) });\n\n\t\t\tlet suspended;\n\t\t\twhile ((suspended = c._suspenders.pop())) {\n\t\t\t\tsuspended.forceUpdate();\n\t\t\t}\n\t\t}\n\t};\n\n\tif (!c._pendingSuspensionCount++) {\n\t\tc.setState({ _suspended: (c._detachOnNextRender = c._vnode._children[0]) });\n\t}\n\tpromise.then(onResolved, onResolved);\n};\n\nSuspense.prototype.componentWillUnmount = function() {\n\tthis._suspenders = [];\n};\n\nSuspense.prototype.render = function(props, state) {\n\tif (this._detachOnNextRender) {\n\t\t// When the Suspense's _vnode was created by a call to createVNode\n\t\t// (i.e. due to a setState further up in the tree)\n\t\t// it's _children prop is null, in this case we \"forget\" about the parked vnodes to detach\n\t\tif (this._vnode._children)\n\t\t\tthis._vnode._children[0] = detachedClone(this._detachOnNextRender);\n\t\tthis._detachOnNextRender = null;\n\t}\n\n\treturn [\n\t\tcreateElement(Fragment, null, state._suspended ? null : props.children),\n\t\tstate._suspended && props.fallback\n\t];\n};\n\n/**\n * Checks and calls the parent component's _suspended method, passing in the\n * suspended vnode. This is a way for a parent (e.g. SuspenseList) to get notified\n * that one of its children/descendants suspended.\n *\n * The parent MAY return a callback. The callback will get called when the\n * suspension resolves, notifying the parent of the fact.\n * Moreover, the callback gets function `unsuspend` as a parameter. The resolved\n * child descendant will not actually get unsuspended until `unsuspend` gets called.\n * This is a way for the parent to delay unsuspending.\n *\n * If the parent does not return a callback then the resolved vnode\n * gets unsuspended immediately when it resolves.\n *\n * @param {import('../src/internal').VNode} vnode\n * @returns {((unsuspend: () => void) => void)?}\n */\nexport function suspended(vnode) {\n\tlet component = vnode._parent._component;\n\treturn component && component._suspended && component._suspended(vnode);\n}\n\nexport function lazy(loader) {\n\tlet prom;\n\tlet component;\n\tlet error;\n\n\tfunction Lazy(props) {\n\t\tif (!prom) {\n\t\t\tprom = loader();\n\t\t\tprom.then(\n\t\t\t\texports => {\n\t\t\t\t\tcomponent = exports.default || exports;\n\t\t\t\t},\n\t\t\t\te => {\n\t\t\t\t\terror = e;\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tif (!component) {\n\t\t\tthrow prom;\n\t\t}\n\n\t\treturn createElement(component, props);\n\t}\n\n\tLazy.displayName = 'Lazy';\n\tLazy._forwarded = true;\n\treturn Lazy;\n}\n","import { Component, toChildArray } from 'preact';\nimport { suspended } from './suspense.js';\n\n// Indexes to linked list nodes (nodes are stored as arrays to save bytes).\nconst SUSPENDED_COUNT = 0;\nconst RESOLVED_COUNT = 1;\nconst NEXT_NODE = 2;\n\n// Having custom inheritance instead of a class here saves a lot of bytes.\nexport function SuspenseList() {\n\tthis._next = null;\n\tthis._map = null;\n}\n\n// Mark one of child's earlier suspensions as resolved.\n// Some pending callbacks may become callable due to this\n// (e.g. the last suspended descendant gets resolved when\n// revealOrder === 'together'). Process those callbacks as well.\nconst resolve = (list, child, node) => {\n\tif (++node[RESOLVED_COUNT] === node[SUSPENDED_COUNT]) {\n\t\t// The number a child (or any of its descendants) has been suspended\n\t\t// matches the number of times it's been resolved. Therefore we\n\t\t// mark the child as completely resolved by deleting it from ._map.\n\t\t// This is used to figure out when *all* children have been completely\n\t\t// resolved when revealOrder is 'together'.\n\t\tlist._map.delete(child);\n\t}\n\n\t// If revealOrder is falsy then we can do an early exit, as the\n\t// callbacks won't get queued in the node anyway.\n\t// If revealOrder is 'together' then also do an early exit\n\t// if all suspended descendants have not yet been resolved.\n\tif (\n\t\t!list.props.revealOrder ||\n\t\t(list.props.revealOrder[0] === 't' && list._map.size)\n\t) {\n\t\treturn;\n\t}\n\n\t// Walk the currently suspended children in order, calling their\n\t// stored callbacks on the way. Stop if we encounter a child that\n\t// has not been completely resolved yet.\n\tnode = list._next;\n\twhile (node) {\n\t\twhile (node.length > 3) {\n\t\t\tnode.pop()();\n\t\t}\n\t\tif (node[RESOLVED_COUNT] < node[SUSPENDED_COUNT]) {\n\t\t\tbreak;\n\t\t}\n\t\tlist._next = node = node[NEXT_NODE];\n\t}\n};\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspenseList.prototype = new Component();\n\nSuspenseList.prototype._suspended = function(child) {\n\tconst list = this;\n\tconst delegated = suspended(list._vnode);\n\n\tlet node = list._map.get(child);\n\tnode[SUSPENDED_COUNT]++;\n\n\treturn unsuspend => {\n\t\tconst wrappedUnsuspend = () => {\n\t\t\tif (!list.props.revealOrder) {\n\t\t\t\t// Special case the undefined (falsy) revealOrder, as there\n\t\t\t\t// is no need to coordinate a specific order or unsuspends.\n\t\t\t\tunsuspend();\n\t\t\t} else {\n\t\t\t\tnode.push(unsuspend);\n\t\t\t\tresolve(list, child, node);\n\t\t\t}\n\t\t};\n\t\tif (delegated) {\n\t\t\tdelegated(wrappedUnsuspend);\n\t\t} else {\n\t\t\twrappedUnsuspend();\n\t\t}\n\t};\n};\n\nSuspenseList.prototype.render = function(props) {\n\tthis._next = null;\n\tthis._map = new Map();\n\n\tconst children = toChildArray(props.children);\n\tif (props.revealOrder && props.revealOrder[0] === 'b') {\n\t\t// If order === 'backwards' (or, well, anything starting with a 'b')\n\t\t// then flip the child list around so that the last child will be\n\t\t// the first in the linked list.\n\t\tchildren.reverse();\n\t}\n\t// Build the linked list. Iterate through the children in reverse order\n\t// so that `_next` points to the first linked list node to be resolved.\n\tfor (let i = children.length; i--; ) {\n\t\t// Create a new linked list node as an array of form:\n\t\t// \t[suspended_count, resolved_count, next_node]\n\t\t// where suspended_count and resolved_count are numeric counters for\n\t\t// keeping track how many times a node has been suspended and resolved.\n\t\t//\n\t\t// Note that suspended_count starts from 1 instead of 0, so we can block\n\t\t// processing callbacks until componentDidMount has been called. In a sense\n\t\t// node is suspended at least until componentDidMount gets called!\n\t\t//\n\t\t// Pending callbacks are added to the end of the node:\n\t\t// \t[suspended_count, resolved_count, next_node, callback_0, callback_1, ...]\n\t\tthis._map.set(children[i], (this._next = [1, 0, this._next]));\n\t}\n\treturn props.children;\n};\n\nSuspenseList.prototype.componentDidUpdate = SuspenseList.prototype.componentDidMount = function() {\n\t// Iterate through all children after mounting for two reasons:\n\t// 1. As each node[SUSPENDED_COUNT] starts from 1, this iteration increases\n\t//    each node[RELEASED_COUNT] by 1, therefore balancing the counters.\n\t//    The nodes can now be completely consumed from the linked list.\n\t// 2. Handle nodes that might have gotten resolved between render and\n\t//    componentDidMount.\n\tthis._map.forEach((node, child) => {\n\t\tresolve(this, child, node);\n\t});\n};\n","import { createElement, hydrate, render, __u as _unmount } from 'preact';\n\nfunction ContextProvider(props) {\n\tthis.getChildContext = () => props.context;\n\treturn props.children;\n}\n\n/**\n * Portal component\n * @param {object | null | undefined} props\n *\n * TODO: this could use the \"fake root node\" trick from the partial hydration demo\n */\nfunction Portal(props) {\n\tconst _this = this;\n\tlet container = props._container;\n\tlet wrap = createElement(\n\t\tContextProvider,\n\t\t{ context: _this.context },\n\t\tprops._vnode\n\t);\n\n\t_this.componentWillUnmount = function() {\n\t\tlet parent = _this._temp.parentNode;\n\t\tif (parent) parent.removeChild(_this._temp);\n\t\t_unmount(_this._wrap);\n\t};\n\n\t// When we change container we should clear our old container and\n\t// indicate a new mount.\n\tif (_this._container && _this._container !== container) {\n\t\t_this.componentWillUnmount();\n\t\t// if (_this._temp.parentNode) _this._container.removeChild(_this._temp);\n\t\t// _unmount(_this._wrap);\n\t\t_this._hasMounted = false;\n\t}\n\n\t// When props.vnode is undefined/false/null we are dealing with some kind of\n\t// conditional vnode. This should not trigger a render.\n\tif (props._vnode) {\n\t\tif (!_this._hasMounted) {\n\t\t\t// Create a placeholder that we can use to insert into.\n\t\t\t_this._temp = document.createTextNode('');\n\t\t\t// temporarily store the current children of the container to restore them after render\n\t\t\t_this._children = container._children;\n\t\t\t// Hydrate existing nodes to keep the dom intact, when rendering\n\t\t\t// wrap into the container.\n\t\t\thydrate('', container);\n\t\t\t// Append to the container (this matches React's behavior)\n\t\t\tcontainer.appendChild(_this._temp);\n\t\t\t// At this point we have mounted and should set our container.\n\t\t\t_this._hasMounted = true;\n\t\t\t_this._container = container;\n\t\t\t// Render our wrapping element into temp.\n\t\t\trender(wrap, container, _this._temp);\n\t\t\t// restore the previous children of the container\n\t\t\tcontainer._children = _this._children;\n\t\t\t// store the children of the new vnode to be used in subsequent re-renders\n\t\t\t_this._children = _this._temp._children;\n\t\t} else {\n\t\t\t// When we have mounted and the vnode is present it means the\n\t\t\t// props have changed or a parent is triggering a rerender.\n\t\t\t// This implies we only need to call render. But we need to keep\n\t\t\t// the old tree around, otherwise will treat the vnodes as new and\n\t\t\t// will wrongly call `componentDidMount` on them\n\t\t\tcontainer._children = _this._children;\n\t\t\trender(wrap, container);\n\t\t\t_this._children = container._children;\n\t\t}\n\t}\n\t// When we come from a conditional render, on a mounted\n\t// portal we should clear the DOM.\n\telse if (_this._hasMounted) {\n\t\t_this.componentWillUnmount();\n\t\t// if (_this._temp.parentNode) _this._container.removeChild(_this._temp);\n\t\t// _unmount(_this._wrap);\n\t}\n\t// Set the wrapping element for future unmounting.\n\t_this._wrap = wrap;\n}\n\n/**\n * Create a `Portal` to continue rendering the vnode tree at a different DOM node\n * @param {import('./internal').VNode} vnode The vnode to render\n * @param {import('./internal').PreactElement} container The DOM node to continue rendering in to.\n */\nexport function createPortal(vnode, container) {\n\treturn createElement(Portal, { _vnode: vnode, _container: container });\n}\n","import {\n\trender as preactRender,\n\thydrate as preactHydrate,\n\toptions,\n\ttoChildArray,\n\tComponent\n} from 'preact';\nimport { applyEventNormalization } from './events';\n\nconst CAMEL_PROPS = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;\n\n// Some libraries like `react-virtualized` explicitly check for this.\nComponent.prototype.isReactComponent = {};\n\nexport const REACT_ELEMENT_TYPE =\n\t(typeof Symbol != 'undefined' && Symbol.for && Symbol.for('react.element')) ||\n\t0xeac7;\n\n/**\n * Proxy render() since React returns a Component reference.\n * @param {import('./internal').VNode} vnode VNode tree to render\n * @param {import('./internal').PreactElement} parent DOM node to render vnode tree into\n * @param {() => void} [callback] Optional callback that will be called after rendering\n * @returns {import('./internal').Component | null} The root component reference or null\n */\nexport function render(vnode, parent, callback) {\n\t// React destroys any existing DOM nodes, see #1727\n\t// ...but only on the first render, see #1828\n\tif (parent._children == null) {\n\t\twhile (parent.firstChild) {\n\t\t\tparent.removeChild(parent.firstChild);\n\t\t}\n\t}\n\n\tpreactRender(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nexport function hydrate(vnode, parent, callback) {\n\tpreactHydrate(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nlet oldEventHook = options.event;\noptions.event = e => {\n\tif (oldEventHook) e = oldEventHook(e);\n\te.persist = () => {};\n\tlet stoppedPropagating = false,\n\t\tdefaultPrevented = false;\n\n\tconst origStopPropagation = e.stopPropagation;\n\te.stopPropagation = () => {\n\t\torigStopPropagation.call(e);\n\t\tstoppedPropagating = true;\n\t};\n\n\tconst origPreventDefault = e.preventDefault;\n\te.preventDefault = () => {\n\t\torigPreventDefault.call(e);\n\t\tdefaultPrevented = true;\n\t};\n\n\te.isPropagationStopped = () => stoppedPropagating;\n\te.isDefaultPrevented = () => defaultPrevented;\n\treturn (e.nativeEvent = e);\n};\n\n// Patch in `UNSAFE_*` lifecycle hooks\nfunction setSafeDescriptor(proto, key) {\n\tif (proto['UNSAFE_' + key] && !proto[key]) {\n\t\tObject.defineProperty(proto, key, {\n\t\t\tget() {\n\t\t\t\treturn this['UNSAFE_' + key];\n\t\t\t},\n\t\t\t// This `set` is only used if a user sets a lifecycle like cWU\n\t\t\t// after setting a lifecycle like UNSAFE_cWU. I doubt anyone\n\t\t\t// actually does this in practice so not testing it\n\t\t\t/* istanbul ignore next */\n\t\t\tset(v) {\n\t\t\t\tthis['UNSAFE_' + key] = v;\n\t\t\t}\n\t\t});\n\t}\n}\n\nlet classNameDescriptor = {\n\tconfigurable: true,\n\tget() {\n\t\treturn this.class;\n\t}\n};\n\nlet oldVNodeHook = options.vnode;\noptions.vnode = vnode => {\n\tvnode.$$typeof = REACT_ELEMENT_TYPE;\n\n\tlet type = vnode.type;\n\tlet props = vnode.props;\n\n\tif (type) {\n\t\t// Alias `class` prop to `className` if available\n\t\tif (props.class != props.className) {\n\t\t\tclassNameDescriptor.enumerable = 'className' in props;\n\t\t\tif (props.className != null) props.class = props.className;\n\t\t\tObject.defineProperty(props, 'className', classNameDescriptor);\n\t\t}\n\n\t\t// Apply DOM VNode compat\n\t\tif (typeof type != 'function') {\n\t\t\t// Apply defaultValue to value\n\t\t\tif (props.defaultValue && props.value !== undefined) {\n\t\t\t\tif (!props.value && props.value !== 0) {\n\t\t\t\t\tprops.value = props.defaultValue;\n\t\t\t\t}\n\t\t\t\tprops.defaultValue = undefined;\n\t\t\t}\n\n\t\t\t// Add support for array select values: <select value={[]} />\n\t\t\tif (type === 'select' && props.multiple && Array.isArray(props.value)) {\n\t\t\t\ttoChildArray(props.children).forEach(child => {\n\t\t\t\t\tif (props.value.indexOf(child.props.value) != -1) {\n\t\t\t\t\t\tchild.props.selected = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tprops.value = undefined;\n\t\t\t}\n\n\t\t\t// Calling `setAttribute` with a truthy value will lead to it being\n\t\t\t// passed as a stringified value, e.g. `download=\"true\"`. React\n\t\t\t// converts it to an empty string instead, otherwise the attribute\n\t\t\t// value will be used as the file name and the file will be called\n\t\t\t// \"true\" upon downloading it.\n\t\t\tif (props.download === true) {\n\t\t\t\tprops.download = '';\n\t\t\t}\n\n\t\t\t// Normalize DOM vnode properties.\n\t\t\tlet i;\n\t\t\tfor (i in props) {\n\t\t\t\tlet shouldSanitize = CAMEL_PROPS.test(i);\n\t\t\t\tif (shouldSanitize)\n\t\t\t\t\tvnode.props[i.replace(/[A-Z0-9]/, '-$&').toLowerCase()] = props[i];\n\t\t\t\tif (shouldSanitize || props[i] === null) props[i] = undefined;\n\t\t\t}\n\t\t}\n\t\t// Component base class compat\n\t\t// We can't just patch the base component class, because components that use\n\t\t// inheritance and are transpiled down to ES5 will overwrite our patched\n\t\t// getters and setters. See #1941\n\t\telse if (type.prototype && !type.prototype._patchedLifecycles) {\n\t\t\ttype.prototype._patchedLifecycles = true;\n\t\t\tsetSafeDescriptor(type.prototype, 'componentWillMount');\n\t\t\tsetSafeDescriptor(type.prototype, 'componentWillReceiveProps');\n\t\t\tsetSafeDescriptor(type.prototype, 'componentWillUpdate');\n\t\t}\n\n\t\t// Events\n\t\tapplyEventNormalization(vnode);\n\t}\n\n\tif (oldVNodeHook) oldVNodeHook(vnode);\n};\n\n// Only needed for react-relay\nlet currentComponent;\nconst oldBeforeRender = options._render;\noptions._render = function(vnode) {\n\tif (oldBeforeRender) {\n\t\toldBeforeRender(vnode);\n\t}\n\tcurrentComponent = vnode._component;\n};\n\n// This is a very very private internal function for React it\n// is used to sort-of do runtime dependency injection. So far\n// only `react-relay` makes use of it. It uses it to read the\n// context value.\nexport const __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = {\n\tReactCurrentDispatcher: {\n\t\tcurrent: {\n\t\t\treadContext(context) {\n\t\t\t\treturn currentComponent._globalContext[context._id].props.value;\n\t\t\t}\n\t\t}\n\t}\n};\n","/**\n * Normalize event handlers like react does. Most famously it uses `onChange` for any input element.\n * @param {import('./internal').VNode} vnode The vnode to normalize events on\n */\nexport function applyEventNormalization({ type, props }) {\n\tif (!props || typeof type != 'string') return;\n\tlet newProps = {};\n\n\tfor (let i in props) {\n\t\tif (/^on(Ani|Tra|Tou)/.test(i)) {\n\t\t\tprops[i.toLowerCase()] = props[i];\n\t\t\tdelete props[i];\n\t\t}\n\t\tnewProps[i.toLowerCase()] = i;\n\t}\n\tif (newProps.ondoubleclick) {\n\t\tprops.ondblclick = props[newProps.ondoubleclick];\n\t\tdelete props[newProps.ondoubleclick];\n\t}\n\tif (newProps.onbeforeinput) {\n\t\tprops.onbeforeinput = props[newProps.onbeforeinput];\n\t\tdelete props[newProps.onbeforeinput];\n\t}\n\t// for *textual inputs* (incl textarea), normalize `onChange` -> `onInput`:\n\tif (\n\t\tnewProps.onchange &&\n\t\t(type === 'textarea' ||\n\t\t\t(type.toLowerCase() === 'input' && !/^fil|che|ra/i.test(props.type)))\n\t) {\n\t\tlet normalized = newProps.oninput || 'oninput';\n\t\tif (!props[normalized]) {\n\t\t\tprops[normalized] = props[newProps.onchange];\n\t\t\tdelete props[newProps.onchange];\n\t\t}\n\t}\n}\n","import {\n\tcreateElement,\n\trender as preactRender,\n\tcloneElement as preactCloneElement,\n\tcreateRef,\n\tComponent,\n\tcreateContext,\n\tFragment\n} from 'preact';\nimport {\n\tuseState,\n\tuseReducer,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseRef,\n\tuseImperativeHandle,\n\tuseMemo,\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue\n} from 'preact/hooks';\nimport { PureComponent } from './PureComponent';\nimport { memo } from './memo';\nimport { forwardRef } from './forwardRef';\nimport { Children } from './Children';\nimport { Suspense, lazy } from './suspense';\nimport { SuspenseList } from './suspense-list';\nimport { createPortal } from './portals';\nimport {\n\thydrate,\n\trender,\n\tREACT_ELEMENT_TYPE,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n} from './render';\n\nconst version = '16.8.0'; // trick libraries to think we are react\n\n/**\n * Legacy version of createElement.\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component constructor\n */\nfunction createFactory(type) {\n\treturn createElement.bind(null, type);\n}\n\n/**\n * Check if the passed element is a valid (p)react node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isValidElement(element) {\n\treturn !!element && element.$$typeof === REACT_ELEMENT_TYPE;\n}\n\n/**\n * Wrap `cloneElement` to abort if the passed element is not a valid element and apply\n * all vnode normalizations.\n * @param {import('./internal').VNode} element The vnode to clone\n * @param {object} props Props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Optional component children\n */\nfunction cloneElement(element) {\n\tif (!isValidElement(element)) return element;\n\treturn preactCloneElement.apply(null, arguments);\n}\n\n/**\n * Remove a component tree from the DOM, including state and event handlers.\n * @param {import('./internal').PreactElement} container\n * @returns {boolean}\n */\nfunction unmountComponentAtNode(container) {\n\tif (container._children) {\n\t\tpreactRender(null, container);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**\n * Get the matching DOM node for a component\n * @param {import('./internal').Component} component\n * @returns {import('./internal').PreactElement | null}\n */\nfunction findDOMNode(component) {\n\treturn (\n\t\t(component &&\n\t\t\t(component.base || (component.nodeType === 1 && component))) ||\n\t\tnull\n\t);\n}\n\n/**\n * Deprecated way to control batched rendering inside the reconciler, but we\n * already schedule in batches inside our rendering code\n * @template Arg\n * @param {(arg: Arg) => void} callback function that triggers the updated\n * @param {Arg} [arg] Optional argument that can be passed to the callback\n */\n// eslint-disable-next-line camelcase\nconst unstable_batchedUpdates = (callback, arg) => callback(arg);\n\n/**\n * Strict Mode is not implemented in Preact, so we provide a stand-in for it\n * that just renders its children without imposing any restrictions.\n */\nconst StrictMode = Fragment;\n\nexport * from 'preact/hooks';\nexport {\n\tversion,\n\tChildren,\n\trender,\n\thydrate,\n\tunmountComponentAtNode,\n\tcreatePortal,\n\tcreateElement,\n\tcreateContext,\n\tcreateFactory,\n\tcloneElement,\n\tcreateRef,\n\tFragment,\n\tisValidElement,\n\tfindDOMNode,\n\tComponent,\n\tPureComponent,\n\tmemo,\n\tforwardRef,\n\t// eslint-disable-next-line camelcase\n\tunstable_batchedUpdates,\n\tStrictMode,\n\tSuspense,\n\tSuspenseList,\n\tlazy,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n\n// React copies the named exports to the default one.\nexport default {\n\tuseState,\n\tuseReducer,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseRef,\n\tuseImperativeHandle,\n\tuseMemo,\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue,\n\tversion,\n\tChildren,\n\trender,\n\thydrate,\n\tunmountComponentAtNode,\n\tcreatePortal,\n\tcreateElement,\n\tcreateContext,\n\tcreateFactory,\n\tcloneElement,\n\tcreateRef,\n\tFragment,\n\tisValidElement,\n\tfindDOMNode,\n\tComponent,\n\tPureComponent,\n\tmemo,\n\tforwardRef,\n\tunstable_batchedUpdates,\n\tStrictMode,\n\tSuspense,\n\tSuspenseList,\n\tlazy,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n"],"names":["assign","obj","props","i","shallowDiffers","a","b","PureComponent","p","memo","c","comparer","shouldUpdate","nextProps","ref","this","updateRef","call","current","Memoed","shouldComponentUpdate","createElement","displayName","name","prototype","isReactComponent","Component","isPureReactComponent","state","oldDiffHook","options","vnode","type","REACT_FORWARD_SYMBOL","Symbol","for","forwardRef","fn","Forwarded","clone","$$typeof","render","mapFn","children","toChildArray","map","Children","forEach","count","length","only","normalized","toArray","oldCatchError","detachedClone","removeOriginal","Suspense","_suspenders","suspended","component","_suspended","lazy","loader","prom","error","Lazy","then","exports","default","e","SuspenseList","_next","_map","newVNode","oldVNode","promise","suspendingComponent","push","resolve","resolved","onResolved","componentWillUnmount","onSuspensionComplete","setState","pop","forceUpdate","Fragment","fallback","list","child","node","delete","revealOrder","size","ContextProvider","getChildContext","context","Portal","_this","container","_container","wrap","parent","_temp","parentNode","removeChild","_unmount","_wrap","_hasMounted","document","createTextNode","hydrate","appendChild","createPortal","delegated","get","unsuspend","wrappedUnsuspend","Map","reverse","set","componentDidUpdate","componentDidMount","CAMEL_PROPS","REACT_ELEMENT_TYPE","callback","firstChild","preactRender","preactHydrate","oldEventHook","event","setSafeDescriptor","proto","key","Object","defineProperty","v","persist","stoppedPropagating","defaultPrevented","origStopPropagation","stopPropagation","origPreventDefault","preventDefault","isPropagationStopped","isDefaultPrevented","nativeEvent","currentComponent","classNameDescriptor","configurable","class","oldVNodeHook","className","enumerable","defaultValue","undefined","value","multiple","Array","isArray","indexOf","selected","download","shouldSanitize","test","replace","toLowerCase","_patchedLifecycles","newProps","ondoubleclick","ondblclick","onbeforeinput","onchange","oninput","applyEventNormalization","oldBeforeRender","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentDispatcher","readContext","createFactory","bind","isValidElement","element","cloneElement","preactCloneElement","apply","arguments","unmountComponentAtNode","findDOMNode","base","nodeType","unstable_batchedUpdates","arg","StrictMode","useState","useReducer","useEffect","useLayoutEffect","useRef","useImperativeHandle","useMemo","useCallback","useContext","useDebugValue","version","createContext","createRef"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"compat.umd.js","sources":["../src/util.js","../src/PureComponent.js","../src/memo.js","../src/forwardRef.js","../src/Children.js","../src/suspense.js","../src/suspense-list.js","../src/portals.js","../src/render.js","../src/index.js"],"sourcesContent":["/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Check if two objects have a different shape\n * @param {object} a\n * @param {object} b\n * @returns {boolean}\n */\nexport function shallowDiffers(a, b) {\n\tfor (let i in a) if (i !== '__source' && !(i in b)) return true;\n\tfor (let i in b) if (i !== '__source' && a[i] !== b[i]) return true;\n\treturn false;\n}\n","import { Component } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Component class with a predefined `shouldComponentUpdate` implementation\n */\nexport function PureComponent(p) {\n\tthis.props = p;\n}\nPureComponent.prototype = new Component();\n// Some third-party libraries check if this property is present\nPureComponent.prototype.isPureReactComponent = true;\nPureComponent.prototype.shouldComponentUpdate = function(props, state) {\n\treturn shallowDiffers(this.props, props) || shallowDiffers(this.state, state);\n};\n","import { createElement } from 'preact';\nimport { shallowDiffers } from './util';\n\n/**\n * Memoize a component, so that it only updates when the props actually have\n * changed. This was previously known as `React.pure`.\n * @param {import('./internal').FunctionalComponent} c functional component\n * @param {(prev: object, next: object) => boolean} [comparer] Custom equality function\n * @returns {import('./internal').FunctionalComponent}\n */\nexport function memo(c, comparer) {\n\tfunction shouldUpdate(nextProps) {\n\t\tlet ref = this.props.ref;\n\t\tlet updateRef = ref == nextProps.ref;\n\t\tif (!updateRef && ref) {\n\t\t\tref.call ? ref(null) : (ref.current = null);\n\t\t}\n\n\t\tif (!comparer) {\n\t\t\treturn shallowDiffers(this.props, nextProps);\n\t\t}\n\n\t\treturn !comparer(this.props, nextProps) || !updateRef;\n\t}\n\n\tfunction Memoed(props) {\n\t\tthis.shouldComponentUpdate = shouldUpdate;\n\t\treturn createElement(c, props);\n\t}\n\tMemoed.displayName = 'Memo(' + (c.displayName || c.name) + ')';\n\tMemoed.prototype.isReactComponent = true;\n\tMemoed._forwarded = true;\n\treturn Memoed;\n}\n","import { options } from 'preact';\nimport { assign } from './util';\n\nlet oldDiffHook = options._diff;\noptions._diff = vnode => {\n\tif (vnode.type && vnode.type._forwarded && vnode.ref) {\n\t\tvnode.props.ref = vnode.ref;\n\t\tvnode.ref = null;\n\t}\n\tif (oldDiffHook) oldDiffHook(vnode);\n};\n\nexport const REACT_FORWARD_SYMBOL =\n\t(typeof Symbol != 'undefined' &&\n\t\tSymbol.for &&\n\t\tSymbol.for('react.forward_ref')) ||\n\t0xf47;\n\n/**\n * Pass ref down to a child. This is mainly used in libraries with HOCs that\n * wrap components. Using `forwardRef` there is an easy way to get a reference\n * of the wrapped component instead of one of the wrapper itself.\n * @param {import('./index').ForwardFn} fn\n * @returns {import('./internal').FunctionalComponent}\n */\nexport function forwardRef(fn) {\n\t// We always have ref in props.ref, except for\n\t// mobx-react. It will call this function directly\n\t// and always pass ref as the second argument.\n\tfunction Forwarded(props, ref) {\n\t\tlet clone = assign({}, props);\n\t\tdelete clone.ref;\n\t\tref = props.ref || ref;\n\t\treturn fn(\n\t\t\tclone,\n\t\t\t!ref || (typeof ref === 'object' && !('current' in ref)) ? null : ref\n\t\t);\n\t}\n\n\t// mobx-react checks for this being present\n\tForwarded.$$typeof = REACT_FORWARD_SYMBOL;\n\t// mobx-react heavily relies on implementation details.\n\t// It expects an object here with a `render` property,\n\t// and prototype.render will fail. Without this\n\t// mobx-react throws.\n\tForwarded.render = Forwarded;\n\n\tForwarded.prototype.isReactComponent = Forwarded._forwarded = true;\n\tForwarded.displayName = 'ForwardRef(' + (fn.displayName || fn.name) + ')';\n\treturn Forwarded;\n}\n","import { toChildArray } from 'preact';\n\nconst mapFn = (children, fn) => {\n\tif (children == null) return null;\n\treturn toChildArray(toChildArray(children).map(fn));\n};\n\n// This API is completely unnecessary for Preact, so it's basically passthrough.\nexport const Children = {\n\tmap: mapFn,\n\tforEach: mapFn,\n\tcount(children) {\n\t\treturn children ? toChildArray(children).length : 0;\n\t},\n\tonly(children) {\n\t\tconst normalized = toChildArray(children);\n\t\tif (normalized.length !== 1) throw 'Children.only';\n\t\treturn normalized[0];\n\t},\n\ttoArray: toChildArray\n};\n","import { Component, createElement, options, Fragment } from 'preact';\nimport { assign } from './util';\n\nconst oldCatchError = options._catchError;\noptions._catchError = function(error, newVNode, oldVNode) {\n\tif (error.then) {\n\t\t/** @type {import('./internal').Component} */\n\t\tlet component;\n\t\tlet vnode = newVNode;\n\n\t\tfor (; (vnode = vnode._parent); ) {\n\t\t\tif ((component = vnode._component) && component._childDidSuspend) {\n\t\t\t\tif (newVNode._dom == null) {\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t}\n\t\t\t\t// Don't call oldCatchError if we found a Suspense\n\t\t\t\treturn component._childDidSuspend(error, newVNode._component);\n\t\t\t}\n\t\t}\n\t}\n\toldCatchError(error, newVNode, oldVNode);\n};\n\nfunction detachedClone(vnode) {\n\tif (vnode) {\n\t\tvnode = assign({}, vnode);\n\t\tvnode._component = null;\n\t\tvnode._children = vnode._children && vnode._children.map(detachedClone);\n\t}\n\treturn vnode;\n}\n\nfunction removeOriginal(vnode) {\n\tif (vnode) {\n\t\tvnode._original = null;\n\t\tvnode._children = vnode._children && vnode._children.map(removeOriginal);\n\t}\n\treturn vnode;\n}\n\n// having custom inheritance instead of a class here saves a lot of bytes\nexport function Suspense() {\n\t// we do not call super here to golf some bytes...\n\tthis._pendingSuspensionCount = 0;\n\tthis._suspenders = null;\n\tthis._detachOnNextRender = null;\n}\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspense.prototype = new Component();\n\n/**\n * @param {Promise} promise The thrown promise\n * @param {Component<any, any>} suspendingComponent The suspending component\n */\nSuspense.prototype._childDidSuspend = function(promise, suspendingComponent) {\n\t/** @type {import('./internal').SuspenseComponent} */\n\tconst c = this;\n\n\tif (c._suspenders == null) {\n\t\tc._suspenders = [];\n\t}\n\tc._suspenders.push(suspendingComponent);\n\n\tconst resolve = suspended(c._vnode);\n\n\tlet resolved = false;\n\tconst onResolved = () => {\n\t\tif (resolved) return;\n\n\t\tresolved = true;\n\t\tsuspendingComponent.componentWillUnmount =\n\t\t\tsuspendingComponent._suspendedComponentWillUnmount;\n\n\t\tif (resolve) {\n\t\t\tresolve(onSuspensionComplete);\n\t\t} else {\n\t\t\tonSuspensionComplete();\n\t\t}\n\t};\n\n\tsuspendingComponent._suspendedComponentWillUnmount =\n\t\tsuspendingComponent.componentWillUnmount;\n\tsuspendingComponent.componentWillUnmount = () => {\n\t\tonResolved();\n\n\t\tif (suspendingComponent._suspendedComponentWillUnmount) {\n\t\t\tsuspendingComponent._suspendedComponentWillUnmount();\n\t\t}\n\t};\n\n\tconst onSuspensionComplete = () => {\n\t\tif (!--c._pendingSuspensionCount) {\n\t\t\tc._vnode._children[0] = removeOriginal(c.state._suspended);\n\t\t\tc.setState({ _suspended: (c._detachOnNextRender = null) });\n\n\t\t\tlet suspended;\n\t\t\twhile ((suspended = c._suspenders.pop())) {\n\t\t\t\tsuspended.forceUpdate();\n\t\t\t}\n\t\t}\n\t};\n\n\tif (!c._pendingSuspensionCount++) {\n\t\tc.setState({ _suspended: (c._detachOnNextRender = c._vnode._children[0]) });\n\t}\n\tpromise.then(onResolved, onResolved);\n};\n\nSuspense.prototype.componentWillUnmount = function() {\n\tthis._suspenders = [];\n};\n\nSuspense.prototype.render = function(props, state) {\n\tif (this._detachOnNextRender) {\n\t\t// When the Suspense's _vnode was created by a call to createVNode\n\t\t// (i.e. due to a setState further up in the tree)\n\t\t// it's _children prop is null, in this case we \"forget\" about the parked vnodes to detach\n\t\tif (this._vnode._children)\n\t\t\tthis._vnode._children[0] = detachedClone(this._detachOnNextRender);\n\t\tthis._detachOnNextRender = null;\n\t}\n\n\treturn [\n\t\tcreateElement(Fragment, null, state._suspended ? null : props.children),\n\t\tstate._suspended && props.fallback\n\t];\n};\n\n/**\n * Checks and calls the parent component's _suspended method, passing in the\n * suspended vnode. This is a way for a parent (e.g. SuspenseList) to get notified\n * that one of its children/descendants suspended.\n *\n * The parent MAY return a callback. The callback will get called when the\n * suspension resolves, notifying the parent of the fact.\n * Moreover, the callback gets function `unsuspend` as a parameter. The resolved\n * child descendant will not actually get unsuspended until `unsuspend` gets called.\n * This is a way for the parent to delay unsuspending.\n *\n * If the parent does not return a callback then the resolved vnode\n * gets unsuspended immediately when it resolves.\n *\n * @param {import('../src/internal').VNode} vnode\n * @returns {((unsuspend: () => void) => void)?}\n */\nexport function suspended(vnode) {\n\tlet component = vnode._parent._component;\n\treturn component && component._suspended && component._suspended(vnode);\n}\n\nexport function lazy(loader) {\n\tlet prom;\n\tlet component;\n\tlet error;\n\n\tfunction Lazy(props) {\n\t\tif (!prom) {\n\t\t\tprom = loader();\n\t\t\tprom.then(\n\t\t\t\texports => {\n\t\t\t\t\tcomponent = exports.default || exports;\n\t\t\t\t},\n\t\t\t\te => {\n\t\t\t\t\terror = e;\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tif (!component) {\n\t\t\tthrow prom;\n\t\t}\n\n\t\treturn createElement(component, props);\n\t}\n\n\tLazy.displayName = 'Lazy';\n\tLazy._forwarded = true;\n\treturn Lazy;\n}\n","import { Component, toChildArray } from 'preact';\nimport { suspended } from './suspense.js';\n\n// Indexes to linked list nodes (nodes are stored as arrays to save bytes).\nconst SUSPENDED_COUNT = 0;\nconst RESOLVED_COUNT = 1;\nconst NEXT_NODE = 2;\n\n// Having custom inheritance instead of a class here saves a lot of bytes.\nexport function SuspenseList() {\n\tthis._next = null;\n\tthis._map = null;\n}\n\n// Mark one of child's earlier suspensions as resolved.\n// Some pending callbacks may become callable due to this\n// (e.g. the last suspended descendant gets resolved when\n// revealOrder === 'together'). Process those callbacks as well.\nconst resolve = (list, child, node) => {\n\tif (++node[RESOLVED_COUNT] === node[SUSPENDED_COUNT]) {\n\t\t// The number a child (or any of its descendants) has been suspended\n\t\t// matches the number of times it's been resolved. Therefore we\n\t\t// mark the child as completely resolved by deleting it from ._map.\n\t\t// This is used to figure out when *all* children have been completely\n\t\t// resolved when revealOrder is 'together'.\n\t\tlist._map.delete(child);\n\t}\n\n\t// If revealOrder is falsy then we can do an early exit, as the\n\t// callbacks won't get queued in the node anyway.\n\t// If revealOrder is 'together' then also do an early exit\n\t// if all suspended descendants have not yet been resolved.\n\tif (\n\t\t!list.props.revealOrder ||\n\t\t(list.props.revealOrder[0] === 't' && list._map.size)\n\t) {\n\t\treturn;\n\t}\n\n\t// Walk the currently suspended children in order, calling their\n\t// stored callbacks on the way. Stop if we encounter a child that\n\t// has not been completely resolved yet.\n\tnode = list._next;\n\twhile (node) {\n\t\twhile (node.length > 3) {\n\t\t\tnode.pop()();\n\t\t}\n\t\tif (node[RESOLVED_COUNT] < node[SUSPENDED_COUNT]) {\n\t\t\tbreak;\n\t\t}\n\t\tlist._next = node = node[NEXT_NODE];\n\t}\n};\n\n// Things we do here to save some bytes but are not proper JS inheritance:\n// - call `new Component()` as the prototype\n// - do not set `Suspense.prototype.constructor` to `Suspense`\nSuspenseList.prototype = new Component();\n\nSuspenseList.prototype._suspended = function(child) {\n\tconst list = this;\n\tconst delegated = suspended(list._vnode);\n\n\tlet node = list._map.get(child);\n\tnode[SUSPENDED_COUNT]++;\n\n\treturn unsuspend => {\n\t\tconst wrappedUnsuspend = () => {\n\t\t\tif (!list.props.revealOrder) {\n\t\t\t\t// Special case the undefined (falsy) revealOrder, as there\n\t\t\t\t// is no need to coordinate a specific order or unsuspends.\n\t\t\t\tunsuspend();\n\t\t\t} else {\n\t\t\t\tnode.push(unsuspend);\n\t\t\t\tresolve(list, child, node);\n\t\t\t}\n\t\t};\n\t\tif (delegated) {\n\t\t\tdelegated(wrappedUnsuspend);\n\t\t} else {\n\t\t\twrappedUnsuspend();\n\t\t}\n\t};\n};\n\nSuspenseList.prototype.render = function(props) {\n\tthis._next = null;\n\tthis._map = new Map();\n\n\tconst children = toChildArray(props.children);\n\tif (props.revealOrder && props.revealOrder[0] === 'b') {\n\t\t// If order === 'backwards' (or, well, anything starting with a 'b')\n\t\t// then flip the child list around so that the last child will be\n\t\t// the first in the linked list.\n\t\tchildren.reverse();\n\t}\n\t// Build the linked list. Iterate through the children in reverse order\n\t// so that `_next` points to the first linked list node to be resolved.\n\tfor (let i = children.length; i--; ) {\n\t\t// Create a new linked list node as an array of form:\n\t\t// \t[suspended_count, resolved_count, next_node]\n\t\t// where suspended_count and resolved_count are numeric counters for\n\t\t// keeping track how many times a node has been suspended and resolved.\n\t\t//\n\t\t// Note that suspended_count starts from 1 instead of 0, so we can block\n\t\t// processing callbacks until componentDidMount has been called. In a sense\n\t\t// node is suspended at least until componentDidMount gets called!\n\t\t//\n\t\t// Pending callbacks are added to the end of the node:\n\t\t// \t[suspended_count, resolved_count, next_node, callback_0, callback_1, ...]\n\t\tthis._map.set(children[i], (this._next = [1, 0, this._next]));\n\t}\n\treturn props.children;\n};\n\nSuspenseList.prototype.componentDidUpdate = SuspenseList.prototype.componentDidMount = function() {\n\t// Iterate through all children after mounting for two reasons:\n\t// 1. As each node[SUSPENDED_COUNT] starts from 1, this iteration increases\n\t//    each node[RELEASED_COUNT] by 1, therefore balancing the counters.\n\t//    The nodes can now be completely consumed from the linked list.\n\t// 2. Handle nodes that might have gotten resolved between render and\n\t//    componentDidMount.\n\tthis._map.forEach((node, child) => {\n\t\tresolve(this, child, node);\n\t});\n};\n","import { createElement, hydrate, render, __u as _unmount } from 'preact';\n\nfunction ContextProvider(props) {\n\tthis.getChildContext = () => props.context;\n\treturn props.children;\n}\n\n/**\n * Portal component\n * @param {object | null | undefined} props\n *\n * TODO: this could use the \"fake root node\" trick from the partial hydration demo\n */\nfunction Portal(props) {\n\tconst _this = this;\n\tlet container = props._container;\n\tlet wrap = createElement(\n\t\tContextProvider,\n\t\t{ context: _this.context },\n\t\tprops._vnode\n\t);\n\n\t_this.componentWillUnmount = function() {\n\t\tlet parent = _this._temp.parentNode;\n\t\tif (parent) parent.removeChild(_this._temp);\n\t\t_unmount(_this._wrap);\n\t};\n\n\t// When we change container we should clear our old container and\n\t// indicate a new mount.\n\tif (_this._container && _this._container !== container) {\n\t\t_this.componentWillUnmount();\n\t\t// if (_this._temp.parentNode) _this._container.removeChild(_this._temp);\n\t\t// _unmount(_this._wrap);\n\t\t_this._hasMounted = false;\n\t}\n\n\t// When props.vnode is undefined/false/null we are dealing with some kind of\n\t// conditional vnode. This should not trigger a render.\n\tif (props._vnode) {\n\t\tif (!_this._hasMounted) {\n\t\t\t// Create a placeholder that we can use to insert into.\n\t\t\t_this._temp = document.createTextNode('');\n\t\t\t// temporarily store the current children of the container to restore them after render\n\t\t\t_this._children = container._children;\n\t\t\t// Hydrate existing nodes to keep the dom intact, when rendering\n\t\t\t// wrap into the container.\n\t\t\thydrate('', container);\n\t\t\t// Append to the container (this matches React's behavior)\n\t\t\tcontainer.appendChild(_this._temp);\n\t\t\t// At this point we have mounted and should set our container.\n\t\t\t_this._hasMounted = true;\n\t\t\t_this._container = container;\n\t\t\t// Render our wrapping element into temp.\n\t\t\trender(wrap, container, _this._temp);\n\t\t\t// restore the previous children of the container\n\t\t\tcontainer._children = _this._children;\n\t\t\t// store the children of the new vnode to be used in subsequent re-renders\n\t\t\t_this._children = _this._temp._children;\n\t\t} else {\n\t\t\t// When we have mounted and the vnode is present it means the\n\t\t\t// props have changed or a parent is triggering a rerender.\n\t\t\t// This implies we only need to call render. But we need to keep\n\t\t\t// the old tree around, otherwise will treat the vnodes as new and\n\t\t\t// will wrongly call `componentDidMount` on them\n\t\t\tcontainer._children = _this._children;\n\t\t\trender(wrap, container);\n\t\t\t_this._children = container._children;\n\t\t}\n\t}\n\t// When we come from a conditional render, on a mounted\n\t// portal we should clear the DOM.\n\telse if (_this._hasMounted) {\n\t\t_this.componentWillUnmount();\n\t\t// if (_this._temp.parentNode) _this._container.removeChild(_this._temp);\n\t\t// _unmount(_this._wrap);\n\t}\n\t// Set the wrapping element for future unmounting.\n\t_this._wrap = wrap;\n}\n\n/**\n * Create a `Portal` to continue rendering the vnode tree at a different DOM node\n * @param {import('./internal').VNode} vnode The vnode to render\n * @param {import('./internal').PreactElement} container The DOM node to continue rendering in to.\n */\nexport function createPortal(vnode, container) {\n\treturn createElement(Portal, { _vnode: vnode, _container: container });\n}\n","import {\n\trender as preactRender,\n\thydrate as preactHydrate,\n\toptions,\n\ttoChildArray,\n\tComponent\n} from 'preact';\n\nexport const REACT_ELEMENT_TYPE =\n\t(typeof Symbol != 'undefined' && Symbol.for && Symbol.for('react.element')) ||\n\t0xeac7;\n\nconst CAMEL_PROPS = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;\n\n// Input types for which onchange should not be converted to oninput.\n// type=\"file|checkbox|radio\", plus \"range\" in IE11.\n// (IE11 doesn't support Symbol, which we use here to turn `rad` into `ra` which matches \"range\")\nconst ONCHANGE_INPUT_TYPES =\n\ttypeof Symbol != 'undefined' ? /fil|che|rad/i : /fil|che|ra/i;\n\n// Some libraries like `react-virtualized` explicitly check for this.\nComponent.prototype.isReactComponent = {};\n\n// `UNSAFE_*` lifecycle hooks\n// Preact only ever invokes the unprefixed methods.\n// Here we provide a base \"fallback\" implementation that calls any defined UNSAFE_ prefixed method.\n// - If a component defines its own `componentDidMount()` (including via defineProperty), use that.\n// - If a component defines `UNSAFE_componentDidMount()`, `componentDidMount` is the alias getter/setter.\n// - If anything assigns to an `UNSAFE_*` property, the assignment is forwarded to the unprefixed property.\n// See https://github.com/preactjs/preact/issues/1941\n[\n\t'componentWillMount',\n\t'componentWillReceiveProps',\n\t'componentWillUpdate'\n].forEach(key => {\n\tObject.defineProperty(Component.prototype, key, {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn this['UNSAFE_' + key];\n\t\t},\n\t\tset(v) {\n\t\t\tObject.defineProperty(this, key, {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: v\n\t\t\t});\n\t\t}\n\t});\n});\n\n/**\n * Proxy render() since React returns a Component reference.\n * @param {import('./internal').VNode} vnode VNode tree to render\n * @param {import('./internal').PreactElement} parent DOM node to render vnode tree into\n * @param {() => void} [callback] Optional callback that will be called after rendering\n * @returns {import('./internal').Component | null} The root component reference or null\n */\nexport function render(vnode, parent, callback) {\n\t// React destroys any existing DOM nodes, see #1727\n\t// ...but only on the first render, see #1828\n\tif (parent._children == null) {\n\t\tparent.textContent = '';\n\t}\n\n\tpreactRender(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nexport function hydrate(vnode, parent, callback) {\n\tpreactHydrate(vnode, parent);\n\tif (typeof callback == 'function') callback();\n\n\treturn vnode ? vnode._component : null;\n}\n\nlet oldEventHook = options.event;\noptions.event = e => {\n\tif (oldEventHook) e = oldEventHook(e);\n\te.persist = empty;\n\te.isPropagationStopped = isPropagationStopped;\n\te.isDefaultPrevented = isDefaultPrevented;\n\treturn (e.nativeEvent = e);\n};\n\nfunction empty() {}\n\nfunction isPropagationStopped() {\n\treturn this.cancelBubble;\n}\n\nfunction isDefaultPrevented() {\n\treturn this.defaultPrevented;\n}\n\nlet classNameDescriptor = {\n\tconfigurable: true,\n\tget() {\n\t\treturn this.class;\n\t}\n};\n\nlet oldVNodeHook = options.vnode;\noptions.vnode = vnode => {\n\tvnode.$$typeof = REACT_ELEMENT_TYPE;\n\n\tlet type = vnode.type;\n\tlet props = vnode.props;\n\n\tconst isComponent = typeof type == 'function';\n\tif (isComponent) {\n\t\tif ((classNameDescriptor.enumerable = 'className' in props)) {\n\t\t\tprops.class = props.className;\n\t\t}\n\t\tObject.defineProperty(props, 'className', classNameDescriptor);\n\t} else if (type) {\n\t\tlet normalizedProps = {};\n\n\t\tfor (let i in props) {\n\t\t\tlet value = props[i];\n\n\t\t\t// Alias `class` prop to `className` if available\n\t\t\tif (i === 'className') {\n\t\t\t\tnormalizedProps.class = value;\n\t\t\t\tclassNameDescriptor.enumerable = true;\n\t\t\t}\n\n\t\t\tif (i === 'defaultValue' && 'value' in props && props.value == null) {\n\t\t\t\t// `defaultValue` is treated as a fallback `value` when a value prop is present but null/undefined.\n\t\t\t\t// `defaultValue` for Elements with no value prop is the same as the DOM defaultValue property.\n\t\t\t\ti = 'value';\n\t\t\t} else if (i === 'download' && value === true) {\n\t\t\t\t// Calling `setAttribute` with a truthy value will lead to it being\n\t\t\t\t// passed as a stringified value, e.g. `download=\"true\"`. React\n\t\t\t\t// converts it to an empty string instead, otherwise the attribute\n\t\t\t\t// value will be used as the file name and the file will be called\n\t\t\t\t// \"true\" upon downloading it.\n\t\t\t\tvalue = '';\n\t\t\t} else if (/ondoubleclick/i.test(i)) {\n\t\t\t\ti = 'ondblclick';\n\t\t\t} else if (\n\t\t\t\t/^onchange(textarea|input)/i.test(i + type) &&\n\t\t\t\t!ONCHANGE_INPUT_TYPES.test(props.type)\n\t\t\t) {\n\t\t\t\ti = 'oninput';\n\t\t\t} else if (/^on(Ani|Tra|Tou|BeforeInp)/.test(i)) {\n\t\t\t\ti = i.toLowerCase();\n\t\t\t} else if (CAMEL_PROPS.test(i)) {\n\t\t\t\ti = i.replace(/[A-Z0-9]/, '-$&').toLowerCase();\n\t\t\t} else if (value === null) {\n\t\t\t\tvalue = undefined;\n\t\t\t}\n\n\t\t\tnormalizedProps[i] = value;\n\t\t}\n\n\t\tObject.defineProperty(normalizedProps, 'className', classNameDescriptor);\n\n\t\t// Add support for array select values: <select multiple value={[]} />\n\t\tif (\n\t\t\ttype == 'select' &&\n\t\t\tnormalizedProps.multiple &&\n\t\t\tArray.isArray(normalizedProps.value)\n\t\t) {\n\t\t\t// forEach() always returns undefined, which we abuse here to unset the value prop.\n\t\t\tnormalizedProps.value = toChildArray(props.children).forEach(child => {\n\t\t\t\tchild.props.selected =\n\t\t\t\t\tnormalizedProps.value.indexOf(child.props.value) != -1;\n\t\t\t});\n\t\t}\n\n\t\tvnode.props = normalizedProps;\n\t}\n\n\tif (oldVNodeHook) oldVNodeHook(vnode);\n};\n\n// Only needed for react-relay\nlet currentComponent;\nconst oldBeforeRender = options._render;\noptions._render = function(vnode) {\n\tif (oldBeforeRender) {\n\t\toldBeforeRender(vnode);\n\t}\n\tcurrentComponent = vnode._component;\n};\n\n// This is a very very private internal function for React it\n// is used to sort-of do runtime dependency injection. So far\n// only `react-relay` makes use of it. It uses it to read the\n// context value.\nexport const __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = {\n\tReactCurrentDispatcher: {\n\t\tcurrent: {\n\t\t\treadContext(context) {\n\t\t\t\treturn currentComponent._globalContext[context._id].props.value;\n\t\t\t}\n\t\t}\n\t}\n};\n","import {\n\tcreateElement,\n\trender as preactRender,\n\tcloneElement as preactCloneElement,\n\tcreateRef,\n\tComponent,\n\tcreateContext,\n\tFragment\n} from 'preact';\nimport {\n\tuseState,\n\tuseReducer,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseRef,\n\tuseImperativeHandle,\n\tuseMemo,\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue\n} from 'preact/hooks';\nimport { PureComponent } from './PureComponent';\nimport { memo } from './memo';\nimport { forwardRef } from './forwardRef';\nimport { Children } from './Children';\nimport { Suspense, lazy } from './suspense';\nimport { SuspenseList } from './suspense-list';\nimport { createPortal } from './portals';\nimport {\n\thydrate,\n\trender,\n\tREACT_ELEMENT_TYPE,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n} from './render';\n\nconst version = '16.8.0'; // trick libraries to think we are react\n\n/**\n * Legacy version of createElement.\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component constructor\n */\nfunction createFactory(type) {\n\treturn createElement.bind(null, type);\n}\n\n/**\n * Check if the passed element is a valid (p)react node.\n * @param {*} element The element to check\n * @returns {boolean}\n */\nfunction isValidElement(element) {\n\treturn !!element && element.$$typeof === REACT_ELEMENT_TYPE;\n}\n\n/**\n * Wrap `cloneElement` to abort if the passed element is not a valid element and apply\n * all vnode normalizations.\n * @param {import('./internal').VNode} element The vnode to clone\n * @param {object} props Props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Optional component children\n */\nfunction cloneElement(element) {\n\tif (!isValidElement(element)) return element;\n\treturn preactCloneElement.apply(null, arguments);\n}\n\n/**\n * Remove a component tree from the DOM, including state and event handlers.\n * @param {import('./internal').PreactElement} container\n * @returns {boolean}\n */\nfunction unmountComponentAtNode(container) {\n\tif (container._children) {\n\t\tpreactRender(null, container);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**\n * Get the matching DOM node for a component\n * @param {import('./internal').Component} component\n * @returns {import('./internal').PreactElement | null}\n */\nfunction findDOMNode(component) {\n\treturn (\n\t\t(component &&\n\t\t\t(component.base || (component.nodeType === 1 && component))) ||\n\t\tnull\n\t);\n}\n\n/**\n * Deprecated way to control batched rendering inside the reconciler, but we\n * already schedule in batches inside our rendering code\n * @template Arg\n * @param {(arg: Arg) => void} callback function that triggers the updated\n * @param {Arg} [arg] Optional argument that can be passed to the callback\n */\n// eslint-disable-next-line camelcase\nconst unstable_batchedUpdates = (callback, arg) => callback(arg);\n\n/**\n * Strict Mode is not implemented in Preact, so we provide a stand-in for it\n * that just renders its children without imposing any restrictions.\n */\nconst StrictMode = Fragment;\n\nexport * from 'preact/hooks';\nexport {\n\tversion,\n\tChildren,\n\trender,\n\thydrate,\n\tunmountComponentAtNode,\n\tcreatePortal,\n\tcreateElement,\n\tcreateContext,\n\tcreateFactory,\n\tcloneElement,\n\tcreateRef,\n\tFragment,\n\tisValidElement,\n\tfindDOMNode,\n\tComponent,\n\tPureComponent,\n\tmemo,\n\tforwardRef,\n\t// eslint-disable-next-line camelcase\n\tunstable_batchedUpdates,\n\tStrictMode,\n\tSuspense,\n\tSuspenseList,\n\tlazy,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n\n// React copies the named exports to the default one.\nexport default {\n\tuseState,\n\tuseReducer,\n\tuseEffect,\n\tuseLayoutEffect,\n\tuseRef,\n\tuseImperativeHandle,\n\tuseMemo,\n\tuseCallback,\n\tuseContext,\n\tuseDebugValue,\n\tversion,\n\tChildren,\n\trender,\n\thydrate,\n\tunmountComponentAtNode,\n\tcreatePortal,\n\tcreateElement,\n\tcreateContext,\n\tcreateFactory,\n\tcloneElement,\n\tcreateRef,\n\tFragment,\n\tisValidElement,\n\tfindDOMNode,\n\tComponent,\n\tPureComponent,\n\tmemo,\n\tforwardRef,\n\tunstable_batchedUpdates,\n\tStrictMode,\n\tSuspense,\n\tSuspenseList,\n\tlazy,\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n};\n"],"names":["assign","obj","props","i","shallowDiffers","a","b","PureComponent","p","memo","c","comparer","shouldUpdate","nextProps","ref","this","updateRef","call","current","Memoed","shouldComponentUpdate","createElement","displayName","name","prototype","isReactComponent","Component","isPureReactComponent","state","oldDiffHook","options","vnode","type","REACT_FORWARD_SYMBOL","Symbol","for","forwardRef","fn","Forwarded","clone","$$typeof","render","mapFn","children","toChildArray","map","Children","forEach","count","length","only","normalized","toArray","oldCatchError","detachedClone","removeOriginal","Suspense","_suspenders","suspended","component","_suspended","lazy","loader","prom","error","Lazy","then","exports","default","e","SuspenseList","_next","_map","newVNode","oldVNode","promise","suspendingComponent","push","resolve","resolved","onResolved","componentWillUnmount","onSuspensionComplete","setState","pop","forceUpdate","Fragment","fallback","list","child","node","delete","revealOrder","size","ContextProvider","getChildContext","context","Portal","_this","container","_container","wrap","parent","_temp","parentNode","removeChild","_unmount","_wrap","_hasMounted","document","createTextNode","hydrate","appendChild","createPortal","delegated","get","unsuspend","wrappedUnsuspend","Map","reverse","set","componentDidUpdate","componentDidMount","REACT_ELEMENT_TYPE","CAMEL_PROPS","ONCHANGE_INPUT_TYPES","callback","textContent","preactRender","preactHydrate","key","Object","defineProperty","configurable","v","writable","value","oldEventHook","event","empty","isPropagationStopped","cancelBubble","isDefaultPrevented","defaultPrevented","persist","nativeEvent","currentComponent","classNameDescriptor","class","oldVNodeHook","enumerable","className","normalizedProps","test","toLowerCase","replace","undefined","multiple","Array","isArray","selected","indexOf","oldBeforeRender","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentDispatcher","readContext","createFactory","bind","isValidElement","element","cloneElement","preactCloneElement","apply","arguments","unmountComponentAtNode","findDOMNode","base","nodeType","unstable_batchedUpdates","arg","StrictMode","useState","useReducer","useEffect","useLayoutEffect","useRef","useImperativeHandle","useMemo","useCallback","useContext","useDebugValue","version","createContext","createRef"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/preact/compat/mangle.json b/node_modules/preact/compat/mangle.json
new file mode 100644
index 0000000..506a6a4
--- /dev/null
+++ b/node_modules/preact/compat/mangle.json
@@ -0,0 +1,21 @@
+{
+  "help": {
+    "what is this file?": "It controls protected/private property mangling so that minified builds have consistent property names.",
+    "why are there duplicate minified properties?": "Most properties are only used on one type of objects, so they can have the same name since they will never collide. Doing this reduces size."
+  },
+  "minify": {
+    "mangle": {
+      "properties": {
+        "regex": "^_[^_]",
+        "reserved": [
+          "__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED",
+          "__REACT_DEVTOOLS_GLOBAL_HOOK__",
+          "__PREACT_DEVTOOLS__",
+          "_renderers",
+          "__source",
+          "__self"
+        ]
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/node_modules/preact/compat/src/Children.js b/node_modules/preact/compat/src/Children.js
index 50c981e..0295d93 100644
--- a/node_modules/preact/compat/src/Children.js
+++ b/node_modules/preact/compat/src/Children.js
@@ -1,7 +1,7 @@
 import { toChildArray } from 'preact';
 
 const mapFn = (children, fn) => {
-	if (!children) return null;
+	if (children == null) return null;
 	return toChildArray(toChildArray(children).map(fn));
 };
 
diff --git a/node_modules/preact/compat/src/events.js b/node_modules/preact/compat/src/events.js
deleted file mode 100644
index bb0c893..0000000
--- a/node_modules/preact/compat/src/events.js
+++ /dev/null
@@ -1,36 +0,0 @@
-/**
- * Normalize event handlers like react does. Most famously it uses `onChange` for any input element.
- * @param {import('./internal').VNode} vnode The vnode to normalize events on
- */
-export function applyEventNormalization({ type, props }) {
-	if (!props || typeof type != 'string') return;
-	let newProps = {};
-
-	for (let i in props) {
-		if (/^on(Ani|Tra|Tou)/.test(i)) {
-			props[i.toLowerCase()] = props[i];
-			delete props[i];
-		}
-		newProps[i.toLowerCase()] = i;
-	}
-	if (newProps.ondoubleclick) {
-		props.ondblclick = props[newProps.ondoubleclick];
-		delete props[newProps.ondoubleclick];
-	}
-	if (newProps.onbeforeinput) {
-		props.onbeforeinput = props[newProps.onbeforeinput];
-		delete props[newProps.onbeforeinput];
-	}
-	// for *textual inputs* (incl textarea), normalize `onChange` -> `onInput`:
-	if (
-		newProps.onchange &&
-		(type === 'textarea' ||
-			(type.toLowerCase() === 'input' && !/^fil|che|ra/i.test(props.type)))
-	) {
-		let normalized = newProps.oninput || 'oninput';
-		if (!props[normalized]) {
-			props[normalized] = props[newProps.onchange];
-			delete props[newProps.onchange];
-		}
-	}
-}
diff --git a/node_modules/preact/compat/src/render.js b/node_modules/preact/compat/src/render.js
index 1e4b255..e3c67f5 100644
--- a/node_modules/preact/compat/src/render.js
+++ b/node_modules/preact/compat/src/render.js
@@ -5,16 +5,48 @@ import {
 	toChildArray,
 	Component
 } from 'preact';
-import { applyEventNormalization } from './events';
+
+export const REACT_ELEMENT_TYPE =
+	(typeof Symbol != 'undefined' && Symbol.for && Symbol.for('react.element')) ||
+	0xeac7;
 
 const CAMEL_PROPS = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
 
+// Input types for which onchange should not be converted to oninput.
+// type="file|checkbox|radio", plus "range" in IE11.
+// (IE11 doesn't support Symbol, which we use here to turn `rad` into `ra` which matches "range")
+const ONCHANGE_INPUT_TYPES =
+	typeof Symbol != 'undefined' ? /fil|che|rad/i : /fil|che|ra/i;
+
 // Some libraries like `react-virtualized` explicitly check for this.
 Component.prototype.isReactComponent = {};
 
-export const REACT_ELEMENT_TYPE =
-	(typeof Symbol != 'undefined' && Symbol.for && Symbol.for('react.element')) ||
-	0xeac7;
+// `UNSAFE_*` lifecycle hooks
+// Preact only ever invokes the unprefixed methods.
+// Here we provide a base "fallback" implementation that calls any defined UNSAFE_ prefixed method.
+// - If a component defines its own `componentDidMount()` (including via defineProperty), use that.
+// - If a component defines `UNSAFE_componentDidMount()`, `componentDidMount` is the alias getter/setter.
+// - If anything assigns to an `UNSAFE_*` property, the assignment is forwarded to the unprefixed property.
+// See https://github.com/preactjs/preact/issues/1941
+[
+	'componentWillMount',
+	'componentWillReceiveProps',
+	'componentWillUpdate'
+].forEach(key => {
+	Object.defineProperty(Component.prototype, key, {
+		configurable: true,
+		get() {
+			return this['UNSAFE_' + key];
+		},
+		set(v) {
+			Object.defineProperty(this, key, {
+				configurable: true,
+				writable: true,
+				value: v
+			});
+		}
+	});
+});
 
 /**
  * Proxy render() since React returns a Component reference.
@@ -27,9 +59,7 @@ export function render(vnode, parent, callback) {
 	// React destroys any existing DOM nodes, see #1727
 	// ...but only on the first render, see #1828
 	if (parent._children == null) {
-		while (parent.firstChild) {
-			parent.removeChild(parent.firstChild);
-		}
+		parent.textContent = '';
 	}
 
 	preactRender(vnode, parent);
@@ -48,43 +78,20 @@ export function hydrate(vnode, parent, callback) {
 let oldEventHook = options.event;
 options.event = e => {
 	if (oldEventHook) e = oldEventHook(e);
-	e.persist = () => {};
-	let stoppedPropagating = false,
-		defaultPrevented = false;
-
-	const origStopPropagation = e.stopPropagation;
-	e.stopPropagation = () => {
-		origStopPropagation.call(e);
-		stoppedPropagating = true;
-	};
-
-	const origPreventDefault = e.preventDefault;
-	e.preventDefault = () => {
-		origPreventDefault.call(e);
-		defaultPrevented = true;
-	};
-
-	e.isPropagationStopped = () => stoppedPropagating;
-	e.isDefaultPrevented = () => defaultPrevented;
+	e.persist = empty;
+	e.isPropagationStopped = isPropagationStopped;
+	e.isDefaultPrevented = isDefaultPrevented;
 	return (e.nativeEvent = e);
 };
 
-// Patch in `UNSAFE_*` lifecycle hooks
-function setSafeDescriptor(proto, key) {
-	if (proto['UNSAFE_' + key] && !proto[key]) {
-		Object.defineProperty(proto, key, {
-			get() {
-				return this['UNSAFE_' + key];
-			},
-			// This `set` is only used if a user sets a lifecycle like cWU
-			// after setting a lifecycle like UNSAFE_cWU. I doubt anyone
-			// actually does this in practice so not testing it
-			/* istanbul ignore next */
-			set(v) {
-				this['UNSAFE_' + key] = v;
-			}
-		});
-	}
+function empty() {}
+
+function isPropagationStopped() {
+	return this.cancelBubble;
+}
+
+function isDefaultPrevented() {
+	return this.defaultPrevented;
 }
 
 let classNameDescriptor = {
@@ -101,65 +108,69 @@ options.vnode = vnode => {
 	let type = vnode.type;
 	let props = vnode.props;
 
-	if (type) {
-		// Alias `class` prop to `className` if available
-		if (props.class != props.className) {
-			classNameDescriptor.enumerable = 'className' in props;
-			if (props.className != null) props.class = props.className;
-			Object.defineProperty(props, 'className', classNameDescriptor);
+	const isComponent = typeof type == 'function';
+	if (isComponent) {
+		if ((classNameDescriptor.enumerable = 'className' in props)) {
+			props.class = props.className;
 		}
+		Object.defineProperty(props, 'className', classNameDescriptor);
+	} else if (type) {
+		let normalizedProps = {};
 
-		// Apply DOM VNode compat
-		if (typeof type != 'function') {
-			// Apply defaultValue to value
-			if (props.defaultValue && props.value !== undefined) {
-				if (!props.value && props.value !== 0) {
-					props.value = props.defaultValue;
-				}
-				props.defaultValue = undefined;
-			}
+		for (let i in props) {
+			let value = props[i];
 
-			// Add support for array select values: <select value={[]} />
-			if (type === 'select' && props.multiple && Array.isArray(props.value)) {
-				toChildArray(props.children).forEach(child => {
-					if (props.value.indexOf(child.props.value) != -1) {
-						child.props.selected = true;
-					}
-				});
-				props.value = undefined;
+			// Alias `class` prop to `className` if available
+			if (i === 'className') {
+				normalizedProps.class = value;
+				classNameDescriptor.enumerable = true;
 			}
 
-			// Calling `setAttribute` with a truthy value will lead to it being
-			// passed as a stringified value, e.g. `download="true"`. React
-			// converts it to an empty string instead, otherwise the attribute
-			// value will be used as the file name and the file will be called
-			// "true" upon downloading it.
-			if (props.download === true) {
-				props.download = '';
+			if (i === 'defaultValue' && 'value' in props && props.value == null) {
+				// `defaultValue` is treated as a fallback `value` when a value prop is present but null/undefined.
+				// `defaultValue` for Elements with no value prop is the same as the DOM defaultValue property.
+				i = 'value';
+			} else if (i === 'download' && value === true) {
+				// Calling `setAttribute` with a truthy value will lead to it being
+				// passed as a stringified value, e.g. `download="true"`. React
+				// converts it to an empty string instead, otherwise the attribute
+				// value will be used as the file name and the file will be called
+				// "true" upon downloading it.
+				value = '';
+			} else if (/ondoubleclick/i.test(i)) {
+				i = 'ondblclick';
+			} else if (
+				/^onchange(textarea|input)/i.test(i + type) &&
+				!ONCHANGE_INPUT_TYPES.test(props.type)
+			) {
+				i = 'oninput';
+			} else if (/^on(Ani|Tra|Tou|BeforeInp)/.test(i)) {
+				i = i.toLowerCase();
+			} else if (CAMEL_PROPS.test(i)) {
+				i = i.replace(/[A-Z0-9]/, '-$&').toLowerCase();
+			} else if (value === null) {
+				value = undefined;
 			}
 
-			// Normalize DOM vnode properties.
-			let i;
-			for (i in props) {
-				let shouldSanitize = CAMEL_PROPS.test(i);
-				if (shouldSanitize)
-					vnode.props[i.replace(/[A-Z0-9]/, '-$&').toLowerCase()] = props[i];
-				if (shouldSanitize || props[i] === null) props[i] = undefined;
-			}
+			normalizedProps[i] = value;
 		}
-		// Component base class compat
-		// We can't just patch the base component class, because components that use
-		// inheritance and are transpiled down to ES5 will overwrite our patched
-		// getters and setters. See #1941
-		else if (type.prototype && !type.prototype._patchedLifecycles) {
-			type.prototype._patchedLifecycles = true;
-			setSafeDescriptor(type.prototype, 'componentWillMount');
-			setSafeDescriptor(type.prototype, 'componentWillReceiveProps');
-			setSafeDescriptor(type.prototype, 'componentWillUpdate');
+
+		Object.defineProperty(normalizedProps, 'className', classNameDescriptor);
+
+		// Add support for array select values: <select multiple value={[]} />
+		if (
+			type == 'select' &&
+			normalizedProps.multiple &&
+			Array.isArray(normalizedProps.value)
+		) {
+			// forEach() always returns undefined, which we abuse here to unset the value prop.
+			normalizedProps.value = toChildArray(props.children).forEach(child => {
+				child.props.selected =
+					normalizedProps.value.indexOf(child.props.value) != -1;
+			});
 		}
 
-		// Events
-		applyEventNormalization(vnode);
+		vnode.props = normalizedProps;
 	}
 
 	if (oldVNodeHook) oldVNodeHook(vnode);
diff --git a/node_modules/preact/compat/test-utils.js b/node_modules/preact/compat/test-utils.js
new file mode 100644
index 0000000..2dac062
--- /dev/null
+++ b/node_modules/preact/compat/test-utils.js
@@ -0,0 +1 @@
+module.exports = require('preact/test-utils');
diff --git a/node_modules/preact/compat/test/browser/Children.test.js b/node_modules/preact/compat/test/browser/Children.test.js
new file mode 100644
index 0000000..4e0c32d
--- /dev/null
+++ b/node_modules/preact/compat/test/browser/Children.test.js
@@ -0,0 +1,185 @@
+import {
+	setupScratch,
+	teardown,
+	serializeHtml
+} from '../../../test/_util/helpers';
+import { div, span } from '../../../test/_util/dom';
+import React, { createElement, Children, render } from 'preact/compat';
+
+describe('Children', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	describe('.count', () => {
+		let count;
+		function Foo(props) {
+			count = Children.count(props.children);
+			return <div>{count}</div>;
+		}
+
+		it('should return 0 for no children', () => {
+			render(<Foo />, scratch);
+			expect(count).to.equal(0);
+		});
+
+		it('should return number of children', () => {
+			render(
+				<Foo>
+					<div />
+					foo
+				</Foo>,
+				scratch
+			);
+			expect(count).to.equal(2);
+		});
+	});
+
+	describe('.only', () => {
+		let actual;
+		function Foo(props) {
+			actual = Children.only(props.children);
+			return <div>{actual}</div>;
+		}
+
+		it('should only allow 1 child', () => {
+			render(<Foo>foo</Foo>, scratch);
+			expect(actual).to.equal('foo');
+		});
+
+		it('should throw if no children are passed', () => {
+			// eslint-disable-next-line prefer-arrow-callback
+			expect(function() {
+				render(<Foo />, scratch);
+			}).to.throw();
+		});
+
+		it('should throw if more children are passed', () => {
+			// eslint-disable-next-line prefer-arrow-callback
+			expect(function() {
+				render(
+					<Foo>
+						foo
+						<span />
+					</Foo>,
+					scratch
+				);
+			}).to.throw();
+		});
+	});
+
+	describe('.map', () => {
+		function Foo(props) {
+			let children = Children.map(props.children, child => (
+				<span>{child}</span>
+			));
+			return <div>{children}</div>;
+		}
+
+		it('should iterate over children', () => {
+			render(
+				<Foo>
+					foo<div>bar</div>
+				</Foo>,
+				scratch
+			);
+			let expected = div([span('foo'), span(div('bar'))]);
+			expect(serializeHtml(scratch)).to.equal(expected);
+		});
+
+		it('should work with no children', () => {
+			render(<Foo />, scratch);
+			expect(serializeHtml(scratch)).to.equal('<div></div>');
+		});
+
+		it('should work with children as zero number', () => {
+			const testNumber = 0;
+
+			render(<Foo>{testNumber}</Foo>, scratch);
+			expect(serializeHtml(scratch)).to.equal('<div><span>0</span></div>');
+		});
+
+		it('should flatten result', () => {
+			const ProblemChild = ({ children }) => {
+				return React.Children.map(children, child => {
+					return React.Children.map(child.props.children, x => x);
+				}).filter(React.isValidElement);
+			};
+
+			const App = () => {
+				return (
+					<ProblemChild>
+						<div>
+							<div>1</div>
+							<div>2</div>
+						</div>
+					</ProblemChild>
+				);
+			};
+
+			render(<App />, scratch);
+
+			expect(scratch.textContent).to.equal('12');
+		});
+
+		it('should call with indices', () => {
+			const assertion = [];
+			const ProblemChild = ({ children }) => {
+				return React.Children.map(children, (child, i) => {
+					assertion.push(i);
+					return React.Children.map(child.props.children, (x, j) => {
+						assertion.push(j);
+						return x;
+					});
+				}).filter(React.isValidElement);
+			};
+
+			const App = () => {
+				return (
+					<ProblemChild>
+						<div>
+							<div>1</div>
+							<div>2</div>
+						</div>
+						<div>
+							<div>3</div>
+							<div>4</div>
+						</div>
+					</ProblemChild>
+				);
+			};
+
+			render(<App />, scratch);
+			expect(scratch.textContent).to.equal('1234');
+			expect(assertion.length).to.equal(6);
+		});
+	});
+
+	describe('.forEach', () => {
+		function Foo(props) {
+			let children = [];
+			Children.forEach(props.children, child =>
+				children.push(<span>{child}</span>)
+			);
+			return <div>{children}</div>;
+		}
+
+		it('should iterate over children', () => {
+			render(
+				<Foo>
+					foo<div>bar</div>
+				</Foo>,
+				scratch
+			);
+			let expected = div([span('foo'), span(div('bar'))]);
+			expect(serializeHtml(scratch)).to.equal(expected);
+		});
+	});
+});
diff --git a/node_modules/preact/compat/test/browser/PureComponent.test.js b/node_modules/preact/compat/test/browser/PureComponent.test.js
new file mode 100644
index 0000000..1e69307
--- /dev/null
+++ b/node_modules/preact/compat/test/browser/PureComponent.test.js
@@ -0,0 +1,125 @@
+import React, { createElement } from 'preact/compat';
+import { setupRerender } from 'preact/test-utils';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+
+describe('PureComponent', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	/** @type {() => void} */
+	let rerender;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+		rerender = setupRerender();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	it('should be a class', () => {
+		expect(React)
+			.to.have.property('PureComponent')
+			.that.is.a('function');
+	});
+
+	it('should pass props in constructor', () => {
+		let spy = sinon.spy();
+		class Foo extends React.PureComponent {
+			constructor(props) {
+				super(props);
+				spy(this.props, props);
+			}
+		}
+
+		React.render(<Foo foo="bar" />, scratch);
+
+		let expected = { foo: 'bar' };
+		expect(spy).to.be.calledWithMatch(expected, expected);
+	});
+
+	it('should ignore the __source variable', () => {
+		const pureSpy = sinon.spy();
+		const appSpy = sinon.spy();
+		let set;
+		class Pure extends React.PureComponent {
+			render() {
+				pureSpy();
+				return <div>Static</div>;
+			}
+		}
+
+		const App = () => {
+			const [, setState] = React.useState(0);
+			appSpy();
+			set = setState;
+			return <Pure __source={{}} />;
+		};
+
+		React.render(<App />, scratch);
+		expect(appSpy).to.be.calledOnce;
+		expect(pureSpy).to.be.calledOnce;
+
+		set(1);
+		rerender();
+		expect(appSpy).to.be.calledTwice;
+		expect(pureSpy).to.be.calledOnce;
+	});
+
+	it('should only re-render when props or state change', () => {
+		class C extends React.PureComponent {
+			render() {
+				return <div />;
+			}
+		}
+		let spy = sinon.spy(C.prototype, 'render');
+
+		let inst = React.render(<C />, scratch);
+		expect(spy).to.have.been.calledOnce;
+		spy.resetHistory();
+
+		inst = React.render(<C />, scratch);
+		expect(spy).not.to.have.been.called;
+
+		let b = { foo: 'bar' };
+		inst = React.render(<C a="a" b={b} />, scratch);
+		expect(spy).to.have.been.calledOnce;
+		spy.resetHistory();
+
+		inst = React.render(<C a="a" b={b} />, scratch);
+		expect(spy).not.to.have.been.called;
+
+		inst.setState({});
+		rerender();
+		expect(spy).not.to.have.been.called;
+
+		inst.setState({ a: 'a', b });
+		rerender();
+		expect(spy).to.have.been.calledOnce;
+		spy.resetHistory();
+
+		inst.setState({ a: 'a', b });
+		rerender();
+		expect(spy).not.to.have.been.called;
+	});
+
+	it('should update when props are removed', () => {
+		let spy = sinon.spy();
+		class App extends React.PureComponent {
+			render() {
+				spy();
+				return <div>foo</div>;
+			}
+		}
+
+		React.render(<App a="foo" />, scratch);
+		React.render(<App />, scratch);
+		expect(spy).to.be.calledTwice;
+	});
+
+	it('should have "isPureReactComponent" property', () => {
+		let Pure = new React.PureComponent();
+		expect(Pure.isReactComponent).to.deep.equal({});
+	});
+});
diff --git a/node_modules/preact/compat/test/browser/cloneElement.test.js b/node_modules/preact/compat/test/browser/cloneElement.test.js
new file mode 100644
index 0000000..dce5ec3
--- /dev/null
+++ b/node_modules/preact/compat/test/browser/cloneElement.test.js
@@ -0,0 +1,89 @@
+import { createElement as preactH } from 'preact';
+import React, { createElement, render, cloneElement } from 'preact/compat';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+
+describe('compat cloneElement', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	it('should clone elements', () => {
+		let element = (
+			<foo a="b" c="d">
+				a<span>b</span>
+			</foo>
+		);
+		expect(cloneElement(element)).to.eql(element);
+	});
+
+	it('should support props.children', () => {
+		let element = <foo children={<span>b</span>} />;
+		let clone = cloneElement(element);
+		expect(clone).to.eql(element);
+		expect(cloneElement(clone).props.children).to.eql(element.props.children);
+	});
+
+	it('children take precedence over props.children', () => {
+		let element = (
+			<foo children={<span>c</span>}>
+				<div>b</div>
+			</foo>
+		);
+		let clone = cloneElement(element);
+		expect(clone).to.eql(element);
+		expect(clone.props.children.type).to.eql('div');
+	});
+
+	it('should support children in prop argument', () => {
+		let element = <foo />;
+		let children = [<span>b</span>];
+		let clone = cloneElement(element, { children });
+		expect(clone.props.children).to.eql(children);
+	});
+
+	it('single child argument takes precedence over props.children', () => {
+		let element = <foo />;
+		let childrenA = [<span>b</span>];
+		let childrenB = [<div>c</div>];
+		let clone = cloneElement(element, { children: childrenA }, ...childrenB);
+		expect(clone.props.children).to.eql(childrenB[0]);
+	});
+
+	it('multiple children arguments take precedence over props.children', () => {
+		let element = <foo />;
+		let childrenA = [<span>b</span>];
+		let childrenB = [<div>c</div>, 'd'];
+		let clone = cloneElement(element, { children: childrenA }, ...childrenB);
+		expect(clone.props.children).to.eql(childrenB);
+	});
+
+	it('children argument takes precedence over props.children even if falsey', () => {
+		let element = <foo />;
+		let childrenA = [<span>b</span>];
+		let clone = cloneElement(element, { children: childrenA }, undefined);
+		expect(clone.children).to.eql(undefined);
+	});
+
+	it('should skip cloning on invalid element', () => {
+		let element = { foo: 42 };
+		let clone = cloneElement(element);
+		expect(clone).to.eql(element);
+	});
+
+	it('should work with jsx constructor from core', () => {
+		function Foo(props) {
+			return <div>{props.value}</div>;
+		}
+
+		let clone = cloneElement(preactH(Foo), { value: 'foo' });
+		render(clone, scratch);
+		expect(scratch.textContent).to.equal('foo');
+	});
+});
diff --git a/node_modules/preact/compat/test/browser/compat.options.test.js b/node_modules/preact/compat/test/browser/compat.options.test.js
new file mode 100644
index 0000000..6c52278
--- /dev/null
+++ b/node_modules/preact/compat/test/browser/compat.options.test.js
@@ -0,0 +1,85 @@
+import { vnodeSpy, eventSpy } from '../../../test/_util/optionSpies';
+import React, {
+	createElement,
+	render,
+	Component,
+	createRef
+} from 'preact/compat';
+import { setupRerender } from 'preact/test-utils';
+import {
+	setupScratch,
+	teardown,
+	createEvent
+} from '../../../test/_util/helpers';
+
+describe('compat options', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	/** @type {() => void} */
+	let rerender;
+
+	/** @type {() => void} */
+	let increment;
+
+	/** @type {import('../../src/index').PropRef<HTMLButtonElement | null>} */
+	let buttonRef;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+		rerender = setupRerender();
+
+		vnodeSpy.resetHistory();
+		eventSpy.resetHistory();
+
+		buttonRef = createRef();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	class ClassApp extends Component {
+		constructor() {
+			super();
+			this.state = { count: 0 };
+			increment = () =>
+				this.setState(({ count }) => ({
+					count: count + 1
+				}));
+		}
+
+		render() {
+			return (
+				<button ref={buttonRef} onClick={increment}>
+					{this.state.count}
+				</button>
+			);
+		}
+	}
+
+	it('should call old options on mount', () => {
+		render(<ClassApp />, scratch);
+
+		expect(vnodeSpy).to.have.been.called;
+	});
+
+	it('should call old options on event and update', () => {
+		render(<ClassApp />, scratch);
+		expect(scratch.innerHTML).to.equal('<button>0</button>');
+
+		buttonRef.current.dispatchEvent(createEvent('click'));
+		rerender();
+		expect(scratch.innerHTML).to.equal('<button>1</button>');
+
+		expect(vnodeSpy).to.have.been.called;
+		expect(eventSpy).to.have.been.called;
+	});
+
+	it('should call old options on unmount', () => {
+		render(<ClassApp />, scratch);
+		render(null, scratch);
+
+		expect(vnodeSpy).to.have.been.called;
+	});
+});
diff --git a/node_modules/preact/compat/test/browser/component.test.js b/node_modules/preact/compat/test/browser/component.test.js
new file mode 100644
index 0000000..de78a1f
--- /dev/null
+++ b/node_modules/preact/compat/test/browser/component.test.js
@@ -0,0 +1,243 @@
+import { setupRerender } from 'preact/test-utils';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+import React, { createElement } from 'preact/compat';
+
+describe('components', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	/** @type {() => void} */
+	let rerender;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+		rerender = setupRerender();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	it('should have "isReactComponent" property', () => {
+		let Comp = new React.Component();
+		expect(Comp.isReactComponent).to.deep.equal({});
+	});
+
+	it('should be sane', () => {
+		let props;
+
+		class Demo extends React.Component {
+			render() {
+				props = this.props;
+				return <div id="demo">{this.props.children}</div>;
+			}
+		}
+
+		React.render(
+			<Demo a="b" c="d">
+				inner
+			</Demo>,
+			scratch
+		);
+
+		expect(props).to.exist.and.deep.equal({
+			a: 'b',
+			c: 'd',
+			children: 'inner'
+		});
+
+		expect(scratch.innerHTML).to.equal('<div id="demo">inner</div>');
+	});
+
+	it('should single out children before componentWillReceiveProps', () => {
+		let props;
+
+		class Child extends React.Component {
+			componentWillReceiveProps(newProps) {
+				props = newProps;
+			}
+			render() {
+				return this.props.children;
+			}
+		}
+
+		class Parent extends React.Component {
+			render() {
+				return <Child>second</Child>;
+			}
+		}
+
+		let a = React.render(<Parent />, scratch);
+		a.forceUpdate();
+		rerender();
+
+		expect(props).to.exist.and.deep.equal({
+			children: 'second'
+		});
+	});
+
+	describe('UNSAFE_* lifecycle methods', () => {
+		it('should support UNSAFE_componentWillMount', () => {
+			let spy = sinon.spy();
+
+			class Foo extends React.Component {
+				// eslint-disable-next-line camelcase
+				UNSAFE_componentWillMount() {
+					spy();
+				}
+
+				render() {
+					return <h1>foo</h1>;
+				}
+			}
+
+			React.render(<Foo />, scratch);
+
+			expect(spy).to.be.calledOnce;
+		});
+
+		it('should support UNSAFE_componentWillMount #2', () => {
+			let spy = sinon.spy();
+
+			class Foo extends React.Component {
+				render() {
+					return <h1>foo</h1>;
+				}
+			}
+
+			Object.defineProperty(Foo.prototype, 'UNSAFE_componentWillMount', {
+				value: spy
+			});
+
+			React.render(<Foo />, scratch);
+			expect(spy).to.be.calledOnce;
+		});
+
+		it('should support UNSAFE_componentWillReceiveProps', () => {
+			let spy = sinon.spy();
+
+			class Foo extends React.Component {
+				// eslint-disable-next-line camelcase
+				UNSAFE_componentWillReceiveProps() {
+					spy();
+				}
+
+				render() {
+					return <h1>foo</h1>;
+				}
+			}
+
+			React.render(<Foo />, scratch);
+			// Trigger an update
+			React.render(<Foo />, scratch);
+			expect(spy).to.be.calledOnce;
+		});
+
+		it('should support UNSAFE_componentWillReceiveProps #2', () => {
+			let spy = sinon.spy();
+
+			class Foo extends React.Component {
+				render() {
+					return <h1>foo</h1>;
+				}
+			}
+
+			Object.defineProperty(Foo.prototype, 'UNSAFE_componentWillReceiveProps', {
+				value: spy
+			});
+
+			React.render(<Foo />, scratch);
+			// Trigger an update
+			React.render(<Foo />, scratch);
+			expect(spy).to.be.calledOnce;
+		});
+
+		it('should support UNSAFE_componentWillUpdate', () => {
+			let spy = sinon.spy();
+
+			class Foo extends React.Component {
+				// eslint-disable-next-line camelcase
+				UNSAFE_componentWillUpdate() {
+					spy();
+				}
+
+				render() {
+					return <h1>foo</h1>;
+				}
+			}
+
+			React.render(<Foo />, scratch);
+			// Trigger an update
+			React.render(<Foo />, scratch);
+			expect(spy).to.be.calledOnce;
+		});
+
+		it('should support UNSAFE_componentWillUpdate #2', () => {
+			let spy = sinon.spy();
+
+			class Foo extends React.Component {
+				render() {
+					return <h1>foo</h1>;
+				}
+			}
+
+			Object.defineProperty(Foo.prototype, 'UNSAFE_componentWillUpdate', {
+				value: spy
+			});
+
+			React.render(<Foo />, scratch);
+			// Trigger an update
+			React.render(<Foo />, scratch);
+			expect(spy).to.be.calledOnce;
+		});
+
+		it('should alias UNSAFE_* method to non-prefixed variant', () => {
+			let inst;
+			class Foo extends React.Component {
+				// eslint-disable-next-line camelcase
+				UNSAFE_componentWillMount() {}
+				// eslint-disable-next-line camelcase
+				UNSAFE_componentWillReceiveProps() {}
+				// eslint-disable-next-line camelcase
+				UNSAFE_componentWillUpdate() {}
+				render() {
+					inst = this;
+					return <div>foo</div>;
+				}
+			}
+
+			React.render(<Foo />, scratch);
+
+			expect(inst.UNSAFE_componentWillMount).to.equal(inst.componentWillMount);
+			expect(inst.UNSAFE_componentWillReceiveProps).to.equal(
+				inst.UNSAFE_componentWillReceiveProps
+			);
+			expect(inst.UNSAFE_componentWillUpdate).to.equal(
+				inst.UNSAFE_componentWillUpdate
+			);
+		});
+
+		it('should call UNSAFE_* methods through Suspense with wrapper component #2525', () => {
+			class Page extends React.Component {
+				UNSAFE_componentWillMount() {}
+				render() {
+					return <h1>Example</h1>;
+				}
+			}
+
+			const Wrapper = () => <Page />;
+
+			sinon.spy(Page.prototype, 'UNSAFE_componentWillMount');
+
+			React.render(
+				<React.Suspense fallback={<div>fallback</div>}>
+					<Wrapper />
+				</React.Suspense>,
+				scratch
+			);
+
+			expect(scratch.innerHTML).to.equal('<h1>Example</h1>');
+			expect(Page.prototype.UNSAFE_componentWillMount).to.have.been.called;
+		});
+	});
+});
diff --git a/node_modules/preact/compat/test/browser/createElement.test.js b/node_modules/preact/compat/test/browser/createElement.test.js
new file mode 100644
index 0000000..8a39b3f
--- /dev/null
+++ b/node_modules/preact/compat/test/browser/createElement.test.js
@@ -0,0 +1,49 @@
+import React, { createElement, render } from 'preact/compat';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+import { getSymbol } from './testUtils';
+
+describe('compat createElement()', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	it('should normalize vnodes', () => {
+		let vnode = (
+			<div a="b">
+				<a>t</a>
+			</div>
+		);
+
+		const $$typeof = getSymbol('react.element', 0xeac7);
+		expect(vnode).to.have.property('$$typeof', $$typeof);
+		expect(vnode).to.have.property('type', 'div');
+		expect(vnode)
+			.to.have.property('props')
+			.that.is.an('object');
+		expect(vnode.props).to.have.property('children');
+		expect(vnode.props.children).to.have.property('$$typeof', $$typeof);
+		expect(vnode.props.children).to.have.property('type', 'a');
+		expect(vnode.props.children)
+			.to.have.property('props')
+			.that.is.an('object');
+		expect(vnode.props.children.props).to.eql({ children: 't' });
+	});
+
+	it('should not normalize text nodes', () => {
+		String.prototype.capFLetter = function() {
+			return this.charAt(0).toUpperCase() + this.slice(1);
+		};
+		let vnode = <div>hi buddy</div>;
+
+		render(vnode, scratch);
+
+		expect(scratch.innerHTML).to.equal('<div>hi buddy</div>');
+	});
+});
diff --git a/node_modules/preact/compat/test/browser/createFactory.test.js b/node_modules/preact/compat/test/browser/createFactory.test.js
new file mode 100644
index 0000000..8d4f929
--- /dev/null
+++ b/node_modules/preact/compat/test/browser/createFactory.test.js
@@ -0,0 +1,26 @@
+import React, { render, createElement, createFactory } from 'preact/compat';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+
+describe('createFactory', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	it('should create a DOM element', () => {
+		render(createFactory('span')({ class: 'foo' }, '1'), scratch);
+		expect(scratch.innerHTML).to.equal('<span class="foo">1</span>');
+	});
+
+	it('should create a component', () => {
+		const Foo = ({ id, children }) => <div id={id}>foo {children}</div>;
+		render(createFactory(Foo)({ id: 'value' }, 'bar'), scratch);
+		expect(scratch.innerHTML).to.equal('<div id="value">foo bar</div>');
+	});
+});
diff --git a/node_modules/preact/compat/test/browser/events.test.js b/node_modules/preact/compat/test/browser/events.test.js
new file mode 100644
index 0000000..fd8cf26
--- /dev/null
+++ b/node_modules/preact/compat/test/browser/events.test.js
@@ -0,0 +1,244 @@
+import { render } from 'preact';
+import {
+	setupScratch,
+	teardown,
+	createEvent
+} from '../../../test/_util/helpers';
+
+import React, { createElement } from 'preact/compat';
+
+describe('preact/compat events', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+	let proto;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+
+		proto = Element.prototype;
+		sinon.spy(proto, 'addEventListener');
+		sinon.spy(proto, 'removeEventListener');
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+
+		proto.addEventListener.restore();
+		proto.removeEventListener.restore();
+	});
+
+	it('should patch events', () => {
+		let spy = sinon.spy();
+		render(<div onClick={spy} />, scratch);
+		scratch.firstChild.click();
+
+		expect(spy).to.be.calledOnce;
+		const event = spy.args[0][0];
+		expect(event).to.haveOwnProperty('persist');
+		expect(event).to.haveOwnProperty('nativeEvent');
+		expect(event).to.haveOwnProperty('isDefaultPrevented');
+		expect(event).to.haveOwnProperty('isPropagationStopped');
+		expect(typeof event.persist).to.equal('function');
+		expect(typeof event.isDefaultPrevented).to.equal('function');
+		expect(typeof event.isPropagationStopped).to.equal('function');
+
+		expect(() => event.persist()).to.not.throw();
+		expect(() => event.isDefaultPrevented()).to.not.throw();
+		expect(() => event.isPropagationStopped()).to.not.throw();
+
+		expect(event.isDefaultPrevented()).to.be.false;
+		event.preventDefault();
+		expect(event.isDefaultPrevented()).to.be.true;
+
+		expect(event.isPropagationStopped()).to.be.false;
+		event.stopPropagation();
+		expect(event.isPropagationStopped()).to.be.true;
+	});
+
+	it('should normalize ondoubleclick event', () => {
+		let vnode = <div onDoubleClick={() => null} />;
+		expect(vnode.props).to.haveOwnProperty('ondblclick');
+	});
+
+	it('should normalize onChange for textarea', () => {
+		let vnode = <textarea onChange={() => null} />;
+		expect(vnode.props).to.haveOwnProperty('oninput');
+		expect(vnode.props).to.not.haveOwnProperty('onchange');
+
+		vnode = <textarea oninput={() => null} onChange={() => null} />;
+		expect(vnode.props).to.haveOwnProperty('oninput');
+		expect(vnode.props).to.not.haveOwnProperty('onchange');
+	});
+
+	it('should normalize onChange for range, except in IE11', () => {
+		// NOTE: we don't normalize `onchange` for range inputs in IE11.
+		const eventType = /Trident\//.test(navigator.userAgent)
+			? 'change'
+			: 'input';
+		render(<input type="range" onChange={() => null} />, scratch);
+		expect(proto.addEventListener).to.have.been.calledOnce;
+		expect(proto.addEventListener).to.have.been.calledWithExactly(
+			eventType,
+			sinon.match.func,
+			false
+		);
+	});
+
+	it('should support onAnimationEnd', () => {
+		const func = sinon.spy(() => {});
+		render(<div onAnimationEnd={func} />, scratch);
+
+		expect(
+			proto.addEventListener
+		).to.have.been.calledOnce.and.to.have.been.calledWithExactly(
+			'animationend',
+			sinon.match.func,
+			false
+		);
+
+		scratch.firstChild.dispatchEvent(createEvent('animationend'));
+		expect(func).to.have.been.calledOnce;
+
+		render(<div />, scratch);
+		expect(
+			proto.removeEventListener
+		).to.have.been.calledOnce.and.to.have.been.calledWithExactly(
+			'animationend',
+			sinon.match.func,
+			false
+		);
+	});
+
+	it('should support onTouch* events', () => {
+		const onTouchStart = sinon.spy();
+		const onTouchEnd = sinon.spy();
+		const onTouchMove = sinon.spy();
+		const onTouchCancel = sinon.spy();
+
+		render(
+			<div
+				onTouchStart={onTouchStart}
+				onTouchEnd={onTouchEnd}
+				onTouchMove={onTouchMove}
+				onTouchCancel={onTouchCancel}
+			/>,
+			scratch
+		);
+
+		expect(proto.addEventListener.args.length).to.eql(4);
+		expect(proto.addEventListener.args[0].length).to.eql(3);
+		expect(proto.addEventListener.args[0][0]).to.eql('touchstart');
+		expect(proto.addEventListener.args[0][2]).to.eql(false);
+		expect(proto.addEventListener.args[1].length).to.eql(3);
+		expect(proto.addEventListener.args[1][0]).to.eql('touchend');
+		expect(proto.addEventListener.args[1][2]).to.eql(false);
+		expect(proto.addEventListener.args[2].length).to.eql(3);
+		expect(proto.addEventListener.args[2][0]).to.eql('touchmove');
+		expect(proto.addEventListener.args[2][2]).to.eql(false);
+		expect(proto.addEventListener.args[3].length).to.eql(3);
+		expect(proto.addEventListener.args[3][0]).to.eql('touchcancel');
+		expect(proto.addEventListener.args[3][2]).to.eql(false);
+
+		scratch.firstChild.dispatchEvent(createEvent('touchstart'));
+		expect(onTouchStart).to.have.been.calledOnce;
+
+		scratch.firstChild.dispatchEvent(createEvent('touchmove'));
+		expect(onTouchMove).to.have.been.calledOnce;
+
+		scratch.firstChild.dispatchEvent(createEvent('touchend'));
+		expect(onTouchEnd).to.have.been.calledOnce;
+
+		scratch.firstChild.dispatchEvent(createEvent('touchcancel'));
+		expect(onTouchCancel).to.have.been.calledOnce;
+
+		render(<div />, scratch);
+
+		expect(proto.removeEventListener.args.length).to.eql(4);
+		expect(proto.removeEventListener.args[0].length).to.eql(3);
+		expect(proto.removeEventListener.args[0][0]).to.eql('touchstart');
+		expect(proto.removeEventListener.args[0][2]).to.eql(false);
+		expect(proto.removeEventListener.args[1].length).to.eql(3);
+		expect(proto.removeEventListener.args[1][0]).to.eql('touchend');
+		expect(proto.removeEventListener.args[1][2]).to.eql(false);
+		expect(proto.removeEventListener.args[2].length).to.eql(3);
+		expect(proto.removeEventListener.args[2][0]).to.eql('touchmove');
+		expect(proto.removeEventListener.args[2][2]).to.eql(false);
+		expect(proto.removeEventListener.args[3].length).to.eql(3);
+		expect(proto.removeEventListener.args[3][0]).to.eql('touchcancel');
+		expect(proto.removeEventListener.args[3][2]).to.eql(false);
+	});
+
+	it('should support onTransitionEnd', () => {
+		const func = sinon.spy(() => {});
+		render(<div onTransitionEnd={func} />, scratch);
+
+		expect(
+			proto.addEventListener
+		).to.have.been.calledOnce.and.to.have.been.calledWithExactly(
+			'transitionend',
+			sinon.match.func,
+			false
+		);
+
+		scratch.firstChild.dispatchEvent(createEvent('transitionend'));
+		expect(func).to.have.been.calledOnce;
+
+		render(<div />, scratch);
+		expect(
+			proto.removeEventListener
+		).to.have.been.calledOnce.and.to.have.been.calledWithExactly(
+			'transitionend',
+			sinon.match.func,
+			false
+		);
+	});
+
+	it('should normalize onChange', () => {
+		let props = { onChange() {} };
+
+		function expectToBeNormalized(vnode, desc) {
+			expect(vnode, desc)
+				.to.have.property('props')
+				.with.all.keys(['oninput'].concat(vnode.props.type ? 'type' : []))
+				.and.property('oninput')
+				.that.is.a('function');
+		}
+
+		function expectToBeUnmodified(vnode, desc) {
+			expect(vnode, desc)
+				.to.have.property('props')
+				.eql({
+					...props,
+					...(vnode.props.type ? { type: vnode.props.type } : {})
+				});
+		}
+
+		expectToBeUnmodified(<div {...props} />, '<div>');
+		expectToBeUnmodified(
+			<input {...props} type="radio" />,
+			'<input type="radio">'
+		);
+		expectToBeUnmodified(
+			<input {...props} type="checkbox" />,
+			'<input type="checkbox">'
+		);
+		expectToBeUnmodified(
+			<input {...props} type="file" />,
+			'<input type="file">'
+		);
+
+		expectToBeNormalized(<textarea {...props} />, '<textarea>');
+		expectToBeNormalized(<input {...props} />, '<input>');
+		expectToBeNormalized(
+			<input {...props} type="text" />,
+			'<input type="text">'
+		);
+	});
+
+	it('should normalize beforeinput event listener', () => {
+		let spy = sinon.spy();
+		render(<input onBeforeInput={spy} />, scratch);
+		scratch.firstChild.dispatchEvent(createEvent('beforeinput'));
+		expect(spy).to.be.calledOnce;
+	});
+});
diff --git a/node_modules/preact/compat/test/browser/exports.test.js b/node_modules/preact/compat/test/browser/exports.test.js
new file mode 100644
index 0000000..f4a3f26
--- /dev/null
+++ b/node_modules/preact/compat/test/browser/exports.test.js
@@ -0,0 +1,85 @@
+import Compat from 'preact/compat';
+// eslint-disable-next-line no-duplicate-imports
+import * as Named from 'preact/compat';
+
+describe('compat exports', () => {
+	it('should have a default export', () => {
+		expect(Compat.createElement).to.be.a('function');
+		expect(Compat.Component).to.be.a('function');
+		expect(Compat.Fragment).to.exist;
+		expect(Compat.render).to.be.a('function');
+		expect(Compat.hydrate).to.be.a('function');
+		expect(Compat.cloneElement).to.be.a('function');
+		expect(Compat.createContext).to.be.a('function');
+		expect(Compat.createRef).to.be.a('function');
+
+		// Hooks
+		expect(Compat.useState).to.be.a('function');
+		expect(Compat.useReducer).to.be.a('function');
+		expect(Compat.useEffect).to.be.a('function');
+		expect(Compat.useLayoutEffect).to.be.a('function');
+		expect(Compat.useRef).to.be.a('function');
+		expect(Compat.useMemo).to.be.a('function');
+		expect(Compat.useCallback).to.be.a('function');
+		expect(Compat.useContext).to.be.a('function');
+
+		// Suspense
+		expect(Compat.Suspense).to.be.a('function');
+		expect(Compat.lazy).to.be.a('function');
+
+		// Compat specific
+		expect(Compat.PureComponent).to.exist.and.be.a('function');
+		expect(Compat.createPortal).to.exist.and.be.a('function');
+		expect(Compat.createFactory).to.exist.and.be.a('function');
+		expect(Compat.isValidElement).to.exist.and.be.a('function');
+		expect(Compat.findDOMNode).to.exist.and.be.a('function');
+		expect(Compat.Children.map).to.exist.and.be.a('function');
+		expect(Compat.Children.forEach).to.exist.and.be.a('function');
+		expect(Compat.Children.count).to.exist.and.be.a('function');
+		expect(Compat.Children.toArray).to.exist.and.be.a('function');
+		expect(Compat.Children.only).to.exist.and.be.a('function');
+		expect(Compat.unmountComponentAtNode).to.exist.and.be.a('function');
+		expect(Compat.unstable_batchedUpdates).to.exist.and.be.a('function');
+		expect(Compat.version).to.exist.and.be.a('string');
+	});
+
+	it('should have named exports', () => {
+		expect(Named.createElement).to.be.a('function');
+		expect(Named.Component).to.be.a('function');
+		expect(Named.Fragment).to.exist;
+		expect(Named.render).to.be.a('function');
+		expect(Named.hydrate).to.be.a('function');
+		expect(Named.cloneElement).to.be.a('function');
+		expect(Named.createContext).to.be.a('function');
+		expect(Named.createRef).to.be.a('function');
+
+		// Hooks
+		expect(Named.useState).to.be.a('function');
+		expect(Named.useReducer).to.be.a('function');
+		expect(Named.useEffect).to.be.a('function');
+		expect(Named.useLayoutEffect).to.be.a('function');
+		expect(Named.useRef).to.be.a('function');
+		expect(Named.useMemo).to.be.a('function');
+		expect(Named.useCallback).to.be.a('function');
+		expect(Named.useContext).to.be.a('function');
+
+		// Suspense
+		expect(Named.Suspense).to.be.a('function');
+		expect(Named.lazy).to.be.a('function');
+
+		// Compat specific
+		expect(Named.PureComponent).to.exist.and.be.a('function');
+		expect(Named.createPortal).to.exist.and.be.a('function');
+		expect(Named.createFactory).to.exist.and.be.a('function');
+		expect(Named.isValidElement).to.exist.and.be.a('function');
+		expect(Named.findDOMNode).to.exist.and.be.a('function');
+		expect(Named.Children.map).to.exist.and.be.a('function');
+		expect(Named.Children.forEach).to.exist.and.be.a('function');
+		expect(Named.Children.count).to.exist.and.be.a('function');
+		expect(Named.Children.toArray).to.exist.and.be.a('function');
+		expect(Named.Children.only).to.exist.and.be.a('function');
+		expect(Named.unmountComponentAtNode).to.exist.and.be.a('function');
+		expect(Named.unstable_batchedUpdates).to.exist.and.be.a('function');
+		expect(Named.version).to.exist.and.be.a('string');
+	});
+});
diff --git a/node_modules/preact/compat/test/browser/findDOMNode.test.js b/node_modules/preact/compat/test/browser/findDOMNode.test.js
new file mode 100644
index 0000000..0812ed9
--- /dev/null
+++ b/node_modules/preact/compat/test/browser/findDOMNode.test.js
@@ -0,0 +1,51 @@
+import React, { createElement, findDOMNode } from 'preact/compat';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+
+describe('findDOMNode()', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	class Helper extends React.Component {
+		render({ something }) {
+			if (something == null) return null;
+			if (something === false) return null;
+			return <div />;
+		}
+	}
+
+	beforeEach(() => {
+		scratch = setupScratch();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	it.skip('should return DOM Node if render is not false nor null', () => {
+		const helper = React.render(<Helper />, scratch);
+		expect(findDOMNode(helper)).to.be.instanceof(Node);
+	});
+
+	it('should return null if given null', () => {
+		expect(findDOMNode(null)).to.be.null;
+	});
+
+	it('should return a regular DOM Element if given a regular DOM Element', () => {
+		let scratch = document.createElement('div');
+		expect(findDOMNode(scratch)).to.equalNode(scratch);
+	});
+
+	// NOTE: React.render() returning false or null has the component pointing
+	// 			to no DOM Node, in contrast, Preact always render an empty Text DOM Node.
+	it('should return null if render returns false', () => {
+		const helper = React.render(<Helper something={false} />, scratch);
+		expect(findDOMNode(helper)).to.be.null;
+	});
+
+	// NOTE: React.render() returning false or null has the component pointing
+	// 			to no DOM Node, in contrast, Preact always render an empty Text DOM Node.
+	it('should return null if render returns null', () => {
+		const helper = React.render(<Helper something={null} />, scratch);
+		expect(findDOMNode(helper)).to.be.null;
+	});
+});
diff --git a/node_modules/preact/compat/test/browser/forwardRef.test.js b/node_modules/preact/compat/test/browser/forwardRef.test.js
new file mode 100644
index 0000000..68f9219
--- /dev/null
+++ b/node_modules/preact/compat/test/browser/forwardRef.test.js
@@ -0,0 +1,460 @@
+import React, {
+	createElement,
+	render,
+	createRef,
+	forwardRef,
+	hydrate,
+	memo,
+	useState,
+	useRef,
+	useImperativeHandle,
+	createPortal
+} from 'preact/compat';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+import { setupRerender, act } from 'preact/test-utils';
+import { getSymbol } from './testUtils';
+
+/* eslint-disable react/jsx-boolean-value, react/display-name, prefer-arrow-callback */
+
+describe('forwardRef', () => {
+	/** @type {HTMLDivElement} */
+	let scratch, rerender;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+		rerender = setupRerender();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	it('should have isReactComponent flag', () => {
+		let App = forwardRef((_, ref) => <div ref={ref}>foo</div>);
+		expect(App.prototype.isReactComponent).to.equal(true);
+	});
+
+	it('should have $$typeof property', () => {
+		let App = forwardRef((_, ref) => <div ref={ref}>foo</div>);
+		const expected = getSymbol('react.forward_ref', 0xf47);
+		expect(App.$$typeof).to.equal(expected);
+	});
+
+	it('should pass ref with createRef', () => {
+		let App = forwardRef((_, ref) => <div ref={ref}>foo</div>);
+		let ref = createRef();
+		render(<App ref={ref} />, scratch);
+
+		expect(ref.current).to.equalNode(scratch.firstChild);
+	});
+
+	it('should share the same ref reference', () => {
+		let passedRef;
+		let App = forwardRef((_, ref) => {
+			passedRef = ref;
+			return <div ref={ref}>foo</div>;
+		});
+
+		let ref = createRef();
+		render(<App ref={ref} />, scratch);
+
+		expect(ref).to.equal(passedRef);
+	});
+
+	it('should pass ref with a callback', () => {
+		let App = forwardRef((_, ref) => (
+			<div>
+				<span ref={ref}>foo</span>
+			</div>
+		));
+		let ref;
+		render(<App ref={x => (ref = x)} />, scratch);
+
+		expect(ref).to.equalNode(scratch.firstChild.firstChild);
+	});
+
+	it('should forward props', () => {
+		let spy = sinon.spy();
+		let App = forwardRef(spy);
+		render(<App foo="bar" />, scratch);
+
+		expect(spy).to.be.calledWithMatch({ foo: 'bar' });
+	});
+
+	it('should support nesting', () => {
+		let passedRef;
+		let Inner = forwardRef((_, ref) => {
+			passedRef = ref;
+			return <div ref={ref}>inner</div>;
+		});
+		let App = forwardRef((_, ref) => <Inner ref={ref} />);
+
+		let ref = createRef();
+		render(<App ref={ref} />, scratch);
+
+		expect(ref).to.equal(passedRef);
+	});
+
+	it('should forward null on unmount', () => {
+		let passedRef;
+		let App = forwardRef((_, ref) => {
+			passedRef = ref;
+			return <div ref={ref}>foo</div>;
+		});
+
+		let ref = createRef();
+		render(<App ref={ref} />, scratch);
+		render(null, scratch);
+
+		expect(passedRef.current).to.equal(null);
+	});
+
+	it('should be able to render and hydrate forwardRef components', () => {
+		const Foo = ({ label, forwardedRef }) => (
+			<div ref={forwardedRef}>{label}</div>
+		);
+		const App = forwardRef((props, ref) => (
+			<Foo {...props} forwardedRef={ref} />
+		));
+
+		const ref = createRef();
+		const markup = <App ref={ref} label="Hi" />;
+
+		const element = document.createElement('div');
+		element.innerHTML = '<div>Hi</div>';
+		expect(element.textContent).to.equal('Hi');
+		expect(ref.current == null).to.equal(true);
+
+		hydrate(markup, element);
+		expect(element.textContent).to.equal('Hi');
+		expect(ref.current.tagName).to.equal('DIV');
+	});
+
+	it('should update refs when switching between children', () => {
+		function Foo({ forwardedRef, setRefOnDiv }) {
+			return (
+				<section>
+					<div ref={setRefOnDiv ? forwardedRef : null}>First</div>
+					<span ref={setRefOnDiv ? null : forwardedRef}>Second</span>
+				</section>
+			);
+		}
+
+		const App = forwardRef((props, ref) => (
+			<Foo {...props} forwardedRef={ref} />
+		));
+
+		const ref = createRef();
+
+		render(<App ref={ref} setRefOnDiv={true} />, scratch);
+		expect(ref.current.nodeName).to.equal('DIV');
+
+		render(<App ref={ref} setRefOnDiv={false} />, scratch);
+		expect(ref.current.nodeName).to.equal('SPAN');
+	});
+
+	it('should support rendering null', () => {
+		const App = forwardRef(() => null);
+		const ref = createRef();
+
+		render(<App ref={ref} />, scratch);
+		expect(ref.current == null).to.equal(true);
+	});
+
+	it('should support rendering null for multiple children', () => {
+		const Foo = forwardRef(() => null);
+		const ref = createRef();
+
+		render(
+			<div>
+				<div />
+				<Foo ref={ref} />
+				<div />
+			</div>,
+			scratch
+		);
+		expect(ref.current == null).to.equal(true);
+	});
+
+	it('should support useImperativeHandle', () => {
+		let setValue;
+		const Foo = forwardRef((props, ref) => {
+			const result = useState('');
+			setValue = result[1];
+
+			useImperativeHandle(
+				ref,
+				() => ({
+					getValue: () => result[0]
+				}),
+				[result[0]]
+			);
+
+			return <input ref={ref} value={result[0]} />;
+		});
+
+		const ref = createRef();
+		render(<Foo ref={ref} />, scratch);
+
+		expect(typeof ref.current.getValue).to.equal('function');
+		expect(ref.current.getValue()).to.equal('');
+
+		setValue('x');
+		rerender();
+		expect(typeof ref.current.getValue).to.equal('function');
+		expect(ref.current.getValue()).to.equal('x');
+	});
+
+	it('should not bailout if forwardRef is not wrapped in memo', () => {
+		const Component = props => <div {...props} />;
+
+		let renderCount = 0;
+
+		const App = forwardRef((props, ref) => {
+			renderCount++;
+			return <Component {...props} forwardedRef={ref} />;
+		});
+
+		const ref = createRef();
+
+		render(<App ref={ref} optional="foo" />, scratch);
+		expect(renderCount).to.equal(1);
+
+		render(<App ref={ref} optional="foo" />, scratch);
+		expect(renderCount).to.equal(2);
+	});
+
+	it('should bailout if forwardRef is wrapped in memo', () => {
+		const Component = props => <div ref={props.forwardedRef} />;
+
+		let renderCount = 0;
+
+		const App = memo(
+			forwardRef((props, ref) => {
+				renderCount++;
+				return <Component {...props} forwardedRef={ref} />;
+			})
+		);
+
+		const ref = createRef();
+
+		render(<App ref={ref} optional="foo" />, scratch);
+		expect(renderCount).to.equal(1);
+
+		expect(ref.current.nodeName).to.equal('DIV');
+
+		render(<App ref={ref} optional="foo" />, scratch);
+		expect(renderCount).to.equal(1);
+
+		const differentRef = createRef();
+
+		render(<App ref={differentRef} optional="foo" />, scratch);
+		expect(renderCount).to.equal(2);
+
+		expect(ref.current == null).to.equal(true);
+		expect(differentRef.current.nodeName).to.equal('DIV');
+
+		render(<App ref={ref} optional="bar" />, scratch);
+		expect(renderCount).to.equal(3);
+	});
+
+	it('should bailout if forwardRef is wrapped in memo using function refs', () => {
+		const Component = props => <div ref={props.forwardedRef} />;
+
+		let renderCount = 0;
+
+		const App = memo(
+			forwardRef((props, ref) => {
+				renderCount++;
+				return <Component {...props} forwardedRef={ref} />;
+			})
+		);
+
+		const ref = sinon.spy();
+
+		render(<App ref={ref} optional="foo" />, scratch);
+		expect(renderCount).to.equal(1);
+
+		expect(ref).to.have.been.called;
+
+		ref.resetHistory();
+		render(<App ref={ref} optional="foo" />, scratch);
+		expect(renderCount).to.equal(1);
+
+		const differentRef = sinon.spy();
+
+		render(<App ref={differentRef} optional="foo" />, scratch);
+		expect(renderCount).to.equal(2);
+
+		expect(ref).to.have.been.calledWith(null);
+		expect(differentRef).to.have.been.called;
+
+		differentRef.resetHistory();
+		render(<App ref={ref} optional="bar" />, scratch);
+		expect(renderCount).to.equal(3);
+	});
+
+	it('should pass ref through memo() with custom comparer function', () => {
+		const Foo = props => <div ref={props.forwardedRef} />;
+
+		let renderCount = 0;
+
+		const App = memo(
+			forwardRef((props, ref) => {
+				renderCount++;
+				return <Foo {...props} forwardedRef={ref} />;
+			}),
+			(o, p) => o.a === p.a && o.b === p.b
+		);
+
+		const ref = createRef();
+
+		render(<App ref={ref} a="0" b="0" c="1" />, scratch);
+		expect(renderCount).to.equal(1);
+
+		expect(ref.current.nodeName).to.equal('DIV');
+
+		// Changing either a or b rerenders
+		render(<App ref={ref} a="0" b="1" c="1" />, scratch);
+		expect(renderCount).to.equal(2);
+
+		// Changing c doesn't rerender
+		render(<App ref={ref} a="0" b="1" c="2" />, scratch);
+		expect(renderCount).to.equal(2);
+
+		const App2 = memo(App, (o, p) => o.a === p.a && o.c === p.c);
+
+		render(<App2 ref={ref} a="0" b="0" c="0" />, scratch);
+		expect(renderCount).to.equal(3);
+
+		// Changing just b no longer updates
+		render(<App2 ref={ref} a="0" b="1" c="0" />, scratch);
+		expect(renderCount).to.equal(3);
+
+		// Changing just a and c updates
+		render(<App2 ref={ref} a="2" b="2" c="2" />, scratch);
+		expect(renderCount).to.equal(4);
+
+		// Changing just c does not update
+		render(<App2 ref={ref} a="2" b="2" c="3" />, scratch);
+		expect(renderCount).to.equal(4);
+
+		// Changing ref still rerenders
+		const differentRef = createRef();
+
+		render(<App2 ref={differentRef} a="2" b="2" c="3" />, scratch);
+		expect(renderCount).to.equal(5);
+
+		expect(ref.current == null).to.equal(true);
+		expect(differentRef.current.nodeName).to.equal('DIV');
+	});
+
+	it('calls ref when this is a function.', () => {
+		const spy = sinon.spy();
+		const Bar = forwardRef((props, ref) => {
+			useImperativeHandle(ref, () => ({ foo: 100 }));
+			return null;
+		});
+
+		render(<Bar ref={spy} />, scratch);
+		expect(spy).to.be.calledOnce;
+		expect(spy).to.be.calledWithExactly({ foo: 100 });
+	});
+
+	it('stale ref missing with passed useRef', () => {
+		let _ref = null;
+		let _set = null;
+		const Inner = forwardRef((props, ref) => {
+			const _hook = useState(null);
+			_ref = ref;
+			_set = _hook[1];
+			return <div ref={ref} />;
+		});
+
+		const Parent = () => {
+			const parentRef = useRef(null);
+			return <Inner ref={parentRef}>child</Inner>;
+		};
+
+		act(() => {
+			render(<Parent />, scratch);
+		});
+
+		expect(_ref.current).to.equal(scratch.firstChild);
+
+		act(() => {
+			_set(1);
+			rerender();
+		});
+
+		expect(_ref.current).to.equal(scratch.firstChild);
+	});
+
+	it('should forward at diff time instead vnode-creation.', () => {
+		let ref, forceTransition, forceOpen;
+
+		const Portal = ({ children, open }) =>
+			open ? createPortal(children, scratch) : null;
+
+		const Wrapper = forwardRef((_props, ref) => <div ref={ref}>Wrapper</div>);
+		const Transition = ({ children }) => {
+			const state = useState(0);
+			forceTransition = state[1];
+			expect(children.ref).to.not.be.undefined;
+			if (state[0] === 0) expect(children.props.ref).to.be.undefined;
+			return children;
+		};
+
+		const App = () => {
+			const openState = useState(false);
+			forceOpen = openState[1];
+			ref = useRef();
+			return (
+				<Portal open={openState[0]}>
+					<Transition>
+						<Wrapper ref={ref} />
+					</Transition>
+				</Portal>
+			);
+		};
+
+		render(<App />, scratch);
+
+		act(() => {
+			forceOpen(true);
+		});
+
+		expect(ref.current.innerHTML).to.equal('Wrapper');
+
+		act(() => {
+			forceTransition(1);
+		});
+
+		expect(ref.current.innerHTML).to.equal('Wrapper');
+	});
+
+	// Issue #2566
+	it('should pass null as ref when no ref is present', () => {
+		let actual;
+		const App = forwardRef((_, ref) => {
+			actual = ref;
+			return <div />;
+		});
+
+		render(<App />, scratch);
+		expect(actual).to.equal(null);
+	});
+
+	// Issue #2599
+	it('should not crash when explicitly passing null', () => {
+		let actual;
+		const App = forwardRef((_, ref) => {
+			actual = ref;
+			return <div />;
+		});
+
+		// eslint-disable-next-line new-cap
+		render(App({}, null), scratch);
+		expect(actual).to.equal(null);
+	});
+});
diff --git a/node_modules/preact/compat/test/browser/hydrate.test.js b/node_modules/preact/compat/test/browser/hydrate.test.js
new file mode 100644
index 0000000..e42cdb7
--- /dev/null
+++ b/node_modules/preact/compat/test/browser/hydrate.test.js
@@ -0,0 +1,34 @@
+import React, { hydrate } from 'preact/compat';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+
+describe('compat hydrate', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	it('should render react-style jsx', () => {
+		const input = document.createElement('input');
+		scratch.appendChild(input);
+		input.focus();
+		expect(document.activeElement).to.equal(input);
+
+		hydrate(<input />, scratch);
+		expect(document.activeElement).to.equal(input);
+	});
+
+	it('should call the callback', () => {
+		scratch.innerHTML = '<div></div>';
+
+		let spy = sinon.spy();
+		hydrate(<div />, scratch, spy);
+		expect(spy).to.be.calledOnce;
+		expect(spy).to.be.calledWithExactly();
+	});
+});
diff --git a/node_modules/preact/compat/test/browser/isValidElement.test.js b/node_modules/preact/compat/test/browser/isValidElement.test.js
new file mode 100644
index 0000000..0fa34ef
--- /dev/null
+++ b/node_modules/preact/compat/test/browser/isValidElement.test.js
@@ -0,0 +1,22 @@
+import { createElement as preactCreateElement } from 'preact';
+import React, { isValidElement } from 'preact/compat';
+
+describe('isValidElement', () => {
+	it('should check return false for invalid arguments', () => {
+		expect(isValidElement(null)).to.equal(false);
+		expect(isValidElement(false)).to.equal(false);
+		expect(isValidElement(true)).to.equal(false);
+		expect(isValidElement('foo')).to.equal(false);
+		expect(isValidElement(123)).to.equal(false);
+		expect(isValidElement([])).to.equal(false);
+		expect(isValidElement({})).to.equal(false);
+	});
+
+	it('should detect a preact vnode', () => {
+		expect(isValidElement(preactCreateElement('div'))).to.equal(true);
+	});
+
+	it('should detect a compat vnode', () => {
+		expect(isValidElement(React.createElement('div'))).to.equal(true);
+	});
+});
diff --git a/node_modules/preact/compat/test/browser/memo.test.js b/node_modules/preact/compat/test/browser/memo.test.js
new file mode 100644
index 0000000..7451b4f
--- /dev/null
+++ b/node_modules/preact/compat/test/browser/memo.test.js
@@ -0,0 +1,175 @@
+import { setupRerender } from 'preact/test-utils';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+import React, { createElement, Component, render, memo } from 'preact/compat';
+
+const h = React.createElement;
+
+describe('memo()', () => {
+	let scratch, rerender;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+		rerender = setupRerender();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	it('should have isReactComponent flag', () => {
+		// eslint-disable-next-line react/display-name
+		let App = memo(() => <div>foo</div>);
+		expect(App.prototype.isReactComponent).to.equal(true);
+	});
+
+	it('should work with function components', () => {
+		let spy = sinon.spy();
+
+		function Foo() {
+			spy();
+			return <h1>Hello World</h1>;
+		}
+
+		let Memoized = memo(Foo);
+
+		let update;
+		class App extends Component {
+			constructor() {
+				super();
+				update = () => this.setState({});
+			}
+			render() {
+				return <Memoized />;
+			}
+		}
+		render(<App />, scratch);
+
+		expect(spy).to.be.calledOnce;
+
+		update();
+		rerender();
+
+		expect(spy).to.be.calledOnce;
+	});
+
+	it('should support adding refs', () => {
+		let spy = sinon.spy();
+
+		let ref = null;
+
+		function Foo() {
+			spy();
+			return <h1>Hello World</h1>;
+		}
+
+		let Memoized = memo(Foo);
+
+		let update;
+		class App extends Component {
+			constructor() {
+				super();
+				update = () => this.setState({});
+			}
+			render() {
+				return <Memoized ref={ref} />;
+			}
+		}
+		render(<App />, scratch);
+
+		expect(spy).to.be.calledOnce;
+
+		ref = {};
+
+		update();
+		rerender();
+
+		expect(ref.current).not.to.be.undefined;
+
+		// TODO: not sure whether this is in-line with react...
+		expect(spy).to.be.calledTwice;
+	});
+
+	it('should support custom comparer functions', () => {
+		function Foo() {
+			return <h1>Hello World</h1>;
+		}
+
+		let spy = sinon.spy(() => true);
+		let Memoized = memo(Foo, spy);
+
+		let update;
+		class App extends Component {
+			constructor() {
+				super();
+				update = () => this.setState({});
+			}
+			render() {
+				return <Memoized />;
+			}
+		}
+		render(<App />, scratch);
+
+		update();
+		rerender();
+
+		expect(spy).to.be.calledOnce;
+		expect(spy).to.be.calledWith({}, {});
+	});
+
+	it('should rerender when custom comparer returns false', () => {
+		const spy = sinon.spy();
+		function Foo() {
+			spy();
+			return <h1>Hello World</h1>;
+		}
+
+		const App = memo(Foo, () => false);
+		render(<App />, scratch);
+		expect(spy).to.be.calledOnce;
+
+		render(<App foo="bar" />, scratch);
+		expect(spy).to.be.calledTwice;
+	});
+
+	it('should pass props and nextProps to comparer fn', () => {
+		const spy = sinon.spy(() => false);
+		function Foo() {
+			return <div>foo</div>;
+		}
+
+		const props = { foo: true };
+		const nextProps = { foo: false };
+		const App = memo(Foo, spy);
+		render(h(App, props), scratch);
+		render(h(App, nextProps), scratch);
+
+		expect(spy).to.be.calledWith(props, nextProps);
+	});
+
+	it('should nest without errors', () => {
+		const Foo = () => <div>foo</div>;
+		const App = memo(memo(Foo));
+
+		// eslint-disable-next-line prefer-arrow-callback
+		expect(function() {
+			render(<App />, scratch);
+		}).to.not.throw();
+	});
+
+	it('should pass ref through nested memos', () => {
+		class Foo extends Component {
+			render() {
+				return <h1>Hello World</h1>;
+			}
+		}
+
+		const App = memo(memo(Foo));
+
+		const ref = {};
+
+		render(<App ref={ref} />, scratch);
+
+		expect(ref.current).not.to.be.undefined;
+		expect(ref.current).to.be.instanceOf(Foo);
+	});
+});
diff --git a/node_modules/preact/compat/test/browser/portals.test.js b/node_modules/preact/compat/test/browser/portals.test.js
new file mode 100644
index 0000000..e644c57
--- /dev/null
+++ b/node_modules/preact/compat/test/browser/portals.test.js
@@ -0,0 +1,627 @@
+import React, {
+	createElement,
+	render,
+	createPortal,
+	useState,
+	Component
+} from 'preact/compat';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+import { setupRerender, act } from 'preact/test-utils';
+
+/* eslint-disable react/jsx-boolean-value, react/display-name, prefer-arrow-callback */
+
+describe('Portal', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+	let rerender;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+		rerender = setupRerender();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	it('should render into a different root node', () => {
+		let root = document.createElement('div');
+		document.body.appendChild(root);
+
+		function Foo(props) {
+			return <div>{createPortal(props.children, root)}</div>;
+		}
+		render(<Foo>foobar</Foo>, scratch);
+
+		expect(root.innerHTML).to.equal('foobar');
+
+		root.parentNode.removeChild(root);
+	});
+
+	it('should insert the portal', () => {
+		let setFalse;
+		function Foo(props) {
+			const [mounted, setMounted] = useState(true);
+			setFalse = () => setMounted(() => false);
+			return (
+				<div>
+					<p>Hello</p>
+					{mounted && createPortal(props.children, scratch)}
+				</div>
+			);
+		}
+		render(<Foo>foobar</Foo>, scratch);
+		expect(scratch.innerHTML).to.equal('foobar<div><p>Hello</p></div>');
+
+		setFalse();
+		rerender();
+		expect(scratch.innerHTML).to.equal('<div><p>Hello</p></div>');
+	});
+
+	it('should toggle the portal', () => {
+		let toggle;
+
+		function Foo(props) {
+			const [mounted, setMounted] = useState(true);
+			toggle = () => setMounted(s => !s);
+			return (
+				<div>
+					<p>Hello</p>
+					{mounted && createPortal(props.children, scratch)}
+				</div>
+			);
+		}
+
+		render(
+			<Foo>
+				<div>foobar</div>
+			</Foo>,
+			scratch
+		);
+		expect(scratch.innerHTML).to.equal(
+			'<div>foobar</div><div><p>Hello</p></div>'
+		);
+
+		toggle();
+		rerender();
+		expect(scratch.innerHTML).to.equal('<div><p>Hello</p></div>');
+
+		toggle();
+		rerender();
+		expect(scratch.innerHTML).to.equal(
+			'<div><p>Hello</p></div><div>foobar</div>'
+		);
+	});
+
+	it('should notice prop changes on the portal', () => {
+		let set;
+
+		function Foo(props) {
+			const [additionalProps, setProps] = useState({
+				style: { backgroundColor: 'red' }
+			});
+			set = c => setProps(c);
+			return (
+				<div>
+					<p>Hello</p>
+					{createPortal(<p {...additionalProps}>Foo</p>, scratch)}
+				</div>
+			);
+		}
+
+		render(<Foo />, scratch);
+		expect(scratch.firstChild.style.backgroundColor).to.equal('red');
+
+		set({});
+		rerender();
+		expect(scratch.firstChild.style.backgroundColor).to.equal('');
+	});
+
+	it('should not unmount the portal component', () => {
+		let spy = sinon.spy();
+		let set;
+		class Child extends Component {
+			componentWillUnmount() {
+				spy();
+			}
+
+			render(props) {
+				return props.children;
+			}
+		}
+
+		function Foo(props) {
+			const [additionalProps, setProps] = useState({
+				style: { background: 'red' }
+			});
+			set = c => setProps(c);
+			return (
+				<div>
+					<p>Hello</p>
+					{createPortal(<Child {...additionalProps}>Foo</Child>, scratch)}
+				</div>
+			);
+		}
+
+		render(<Foo />, scratch);
+		expect(spy).not.to.be.called;
+
+		set({});
+		rerender();
+		expect(spy).not.to.be.called;
+	});
+
+	it('should not render <undefined> for Portal nodes', () => {
+		let root = document.createElement('div');
+		let dialog = document.createElement('div');
+		dialog.id = 'container';
+
+		scratch.appendChild(root);
+		scratch.appendChild(dialog);
+
+		function Dialog() {
+			return <div>Dialog content</div>;
+		}
+
+		function App() {
+			return <div>{createPortal(<Dialog />, dialog)}</div>;
+		}
+
+		render(<App />, root);
+		expect(scratch.firstChild.firstChild.childNodes.length).to.equal(0);
+	});
+
+	it('should unmount Portal', () => {
+		let root = document.createElement('div');
+		let dialog = document.createElement('div');
+		dialog.id = 'container';
+
+		scratch.appendChild(root);
+		scratch.appendChild(dialog);
+
+		function Dialog() {
+			return <div>Dialog content</div>;
+		}
+
+		function App() {
+			return <div>{createPortal(<Dialog />, dialog)}</div>;
+		}
+
+		render(<App />, root);
+		expect(dialog.childNodes.length).to.equal(2);
+		render(null, root);
+		expect(dialog.childNodes.length).to.equal(0);
+	});
+
+	it('should leave a working root after the portal', () => {
+		let toggle, toggle2;
+
+		function Foo(props) {
+			const [mounted, setMounted] = useState(false);
+			const [mounted2, setMounted2] = useState(true);
+			toggle = () => setMounted(s => !s);
+			toggle2 = () => setMounted2(s => !s);
+			return (
+				<div>
+					{mounted && createPortal(props.children, scratch)}
+					{mounted2 && <p>Hello</p>}
+				</div>
+			);
+		}
+
+		render(
+			<Foo>
+				<div>foobar</div>
+			</Foo>,
+			scratch
+		);
+		expect(scratch.innerHTML).to.equal('<div><p>Hello</p></div>');
+
+		toggle();
+		rerender();
+		expect(scratch.innerHTML).to.equal(
+			'<div><p>Hello</p></div><div>foobar</div>'
+		);
+
+		toggle2();
+		rerender();
+		expect(scratch.innerHTML).to.equal('<div></div><div>foobar</div>');
+
+		toggle2();
+		rerender();
+		expect(scratch.innerHTML).to.equal(
+			'<div><p>Hello</p></div><div>foobar</div>'
+		);
+
+		toggle();
+		rerender();
+		expect(scratch.innerHTML).to.equal('<div><p>Hello</p></div>');
+
+		toggle2();
+		rerender();
+		expect(scratch.innerHTML).to.equal('<div></div>');
+	});
+
+	it('should work with stacking portals', () => {
+		let toggle, toggle2;
+
+		function Foo(props) {
+			const [mounted, setMounted] = useState(false);
+			const [mounted2, setMounted2] = useState(false);
+			toggle = () => setMounted(s => !s);
+			toggle2 = () => setMounted2(s => !s);
+			return (
+				<div>
+					<p>Hello</p>
+					{mounted && createPortal(props.children, scratch)}
+					{mounted2 && createPortal(props.children2, scratch)}
+				</div>
+			);
+		}
+
+		render(
+			<Foo children2={<div>foobar2</div>}>
+				<div>foobar</div>
+			</Foo>,
+			scratch
+		);
+		expect(scratch.innerHTML).to.equal('<div><p>Hello</p></div>');
+
+		toggle();
+		rerender();
+		expect(scratch.innerHTML).to.equal(
+			'<div><p>Hello</p></div><div>foobar</div>'
+		);
+
+		toggle2();
+		rerender();
+		expect(scratch.innerHTML).to.equal(
+			'<div><p>Hello</p></div><div>foobar</div><div>foobar2</div>'
+		);
+
+		toggle2();
+		rerender();
+		expect(scratch.innerHTML).to.equal(
+			'<div><p>Hello</p></div><div>foobar</div>'
+		);
+
+		toggle();
+		rerender();
+		expect(scratch.innerHTML).to.equal('<div><p>Hello</p></div>');
+	});
+
+	it('should work with changing the container', () => {
+		let set, ref;
+
+		function Foo(props) {
+			const [container, setContainer] = useState(scratch);
+			set = setContainer;
+
+			return (
+				<div
+					ref={r => {
+						ref = r;
+					}}
+				>
+					<p>Hello</p>
+					{createPortal(props.children, container)}
+				</div>
+			);
+		}
+
+		render(
+			<Foo>
+				<div>foobar</div>
+			</Foo>,
+			scratch
+		);
+		expect(scratch.innerHTML).to.equal(
+			'<div>foobar</div><div><p>Hello</p></div>'
+		);
+
+		set(() => ref);
+		rerender();
+		expect(scratch.innerHTML).to.equal(
+			'<div><p>Hello</p><div>foobar</div></div>'
+		);
+	});
+
+	it('should work with replacing placeholder portals', () => {
+		let toggle, toggle2;
+
+		function Foo(props) {
+			const [mounted, setMounted] = useState(false);
+			const [mounted2, setMounted2] = useState(false);
+			toggle = () => setMounted(s => !s);
+			toggle2 = () => setMounted2(s => !s);
+			return (
+				<div>
+					<p>Hello</p>
+					{createPortal(mounted && props.children, scratch)}
+					{createPortal(mounted2 && props.children, scratch)}
+				</div>
+			);
+		}
+
+		render(
+			<Foo>
+				<div>foobar</div>
+			</Foo>,
+			scratch
+		);
+		expect(scratch.innerHTML).to.equal('<div><p>Hello</p></div>');
+
+		toggle();
+		rerender();
+		expect(scratch.innerHTML).to.equal(
+			'<div><p>Hello</p></div><div>foobar</div>'
+		);
+
+		toggle();
+		rerender();
+		expect(scratch.innerHTML).to.equal('<div><p>Hello</p></div>');
+
+		toggle2();
+		rerender();
+		expect(scratch.innerHTML).to.equal(
+			'<div><p>Hello</p></div><div>foobar</div>'
+		);
+
+		toggle2();
+		rerender();
+		expect(scratch.innerHTML).to.equal('<div><p>Hello</p></div>');
+	});
+
+	it('should work with removing an element from stacked container to new one', () => {
+		let toggle, root2;
+
+		function Foo(props) {
+			const [root, setRoot] = useState(scratch);
+			toggle = () => setRoot(() => root2);
+			return (
+				<div
+					ref={r => {
+						root2 = r;
+					}}
+				>
+					<p>Hello</p>
+					{createPortal(props.children, scratch)}
+					{createPortal(props.children, root)}
+				</div>
+			);
+		}
+
+		render(
+			<Foo>
+				<div>foobar</div>
+			</Foo>,
+			scratch
+		);
+		expect(scratch.innerHTML).to.equal(
+			'<div>foobar</div><div>foobar</div><div><p>Hello</p></div>'
+		);
+
+		toggle();
+		rerender();
+		expect(scratch.innerHTML).to.equal(
+			'<div>foobar</div><div><p>Hello</p><div>foobar</div></div>'
+		);
+	});
+
+	it('should support nested portals', () => {
+		let toggle, toggle2, inner;
+
+		function Bar() {
+			const [mounted, setMounted] = useState(false);
+			toggle2 = () => setMounted(s => !s);
+			return (
+				<div
+					ref={r => {
+						inner = r;
+					}}
+				>
+					<p>Inner</p>
+					{mounted && createPortal(<p>hiFromBar</p>, scratch)}
+					{mounted && createPortal(<p>innerPortal</p>, inner)}
+				</div>
+			);
+		}
+
+		function Foo(props) {
+			const [mounted, setMounted] = useState(false);
+			toggle = () => setMounted(s => !s);
+			return (
+				<div>
+					<p>Hello</p>
+					{mounted && createPortal(<Bar />, scratch)}
+				</div>
+			);
+		}
+
+		render(<Foo />, scratch);
+		expect(scratch.innerHTML).to.equal('<div><p>Hello</p></div>');
+
+		toggle();
+		rerender();
+		expect(scratch.innerHTML).to.equal(
+			'<div><p>Hello</p></div><div><p>Inner</p></div>'
+		);
+
+		toggle2();
+		rerender();
+		expect(scratch.innerHTML).to.equal(
+			'<div><p>Hello</p></div><div><p>Inner</p><p>innerPortal</p></div><p>hiFromBar</p>'
+		);
+
+		toggle();
+		rerender();
+		expect(scratch.innerHTML).to.equal('<div><p>Hello</p></div>');
+	});
+
+	it('should support nested portals remounting #2669', () => {
+		let setVisible;
+		let i = 0;
+
+		function PortalComponent(props) {
+			const innerVnode = <div id="inner">{i}</div>;
+			innerVnode.___id = 'inner_' + i++;
+			const outerVnode = (
+				<div id="outer">
+					{i}
+					{props.show && createPortal(innerVnode, scratch)}
+				</div>
+			);
+			outerVnode.___id = 'outer_' + i++;
+			return createPortal(outerVnode, scratch);
+		}
+
+		function App() {
+			const [visible, _setVisible] = useState(true);
+			setVisible = _setVisible;
+
+			return (
+				<div id="app">
+					test
+					<PortalComponent show={visible} />
+				</div>
+			);
+		}
+
+		render(<App />, scratch);
+		expect(scratch.innerHTML).to.equal(
+			'<div id="outer">1</div><div id="inner">0</div><div id="app">test</div>'
+		);
+
+		act(() => {
+			setVisible(false);
+		});
+		rerender();
+		expect(scratch.innerHTML).to.equal(
+			'<div id="outer">3</div><div id="app">test</div>'
+		);
+
+		act(() => {
+			setVisible(true);
+		});
+		rerender();
+		expect(scratch.innerHTML).to.equal(
+			'<div id="outer">5</div><div id="app">test</div><div id="inner">4</div>'
+		);
+
+		act(() => {
+			setVisible(false);
+		});
+		rerender();
+		expect(scratch.innerHTML).to.equal(
+			'<div id="outer">7</div><div id="app">test</div>'
+		);
+	});
+
+	it('should not unmount when parent renders', () => {
+		let root = document.createElement('div');
+		let dialog = document.createElement('div');
+		dialog.id = 'container';
+
+		scratch.appendChild(root);
+		scratch.appendChild(dialog);
+
+		let spy = sinon.spy();
+		class Child extends Component {
+			componentDidMount() {
+				spy();
+			}
+
+			render() {
+				return <div id="child">child</div>;
+			}
+		}
+
+		let spyParent = sinon.spy();
+		class App extends Component {
+			componentDidMount() {
+				spyParent();
+			}
+			render() {
+				return <div>{createPortal(<Child />, dialog)}</div>;
+			}
+		}
+
+		render(<App />, root);
+		let dom = document.getElementById('child');
+		expect(spyParent).to.be.calledOnce;
+		expect(spy).to.be.calledOnce;
+
+		// Render twice to trigger update scenario
+		render(<App />, root);
+		render(<App />, root);
+
+		let domNew = document.getElementById('child');
+		expect(dom).to.equal(domNew);
+		expect(spyParent).to.be.calledOnce;
+		expect(spy).to.be.calledOnce;
+	});
+
+	it('should switch between non portal and portal node (Modal as lastChild)', () => {
+		let toggle;
+		const Modal = ({ children, open }) =>
+			open ? createPortal(<div>{children}</div>, scratch) : <div>Closed</div>;
+
+		const App = () => {
+			const [open, setOpen] = useState(false);
+			toggle = setOpen.bind(this, x => !x);
+			return (
+				<div>
+					<button onClick={() => setOpen(!open)}>Show</button>
+					{open ? 'Open' : 'Closed'}
+					<Modal open={open}>Hello</Modal>
+				</div>
+			);
+		};
+
+		render(<App />, scratch);
+		expect(scratch.innerHTML).to.equal(
+			'<div><button>Show</button>Closed<div>Closed</div></div>'
+		);
+
+		toggle();
+		rerender();
+		expect(scratch.innerHTML).to.equal(
+			'<div><button>Show</button>Open</div><div>Hello</div>'
+		);
+	});
+
+	it('should switch between non portal and portal node (Modal as firstChild)', () => {
+		let toggle;
+		const Modal = ({ children, open }) =>
+			open ? createPortal(<div>{children}</div>, scratch) : <div>Closed</div>;
+
+		const App = () => {
+			const [open, setOpen] = useState(false);
+			toggle = setOpen.bind(this, x => !x);
+			return (
+				<div>
+					<Modal open={open}>Hello</Modal>
+					<button onClick={() => setOpen(!open)}>Show</button>
+					{open ? 'Open' : 'Closed'}
+				</div>
+			);
+		};
+
+		render(<App />, scratch);
+		expect(scratch.innerHTML).to.equal(
+			'<div><div>Closed</div><button>Show</button>Closed</div>'
+		);
+
+		toggle();
+		rerender();
+		expect(scratch.innerHTML).to.equal(
+			'<div><button>Show</button>Open</div><div>Hello</div>'
+		);
+
+		toggle();
+		rerender();
+		expect(scratch.innerHTML).to.equal(
+			'<div><div>Closed</div><button>Show</button>Closed</div>'
+		);
+	});
+});
diff --git a/node_modules/preact/compat/test/browser/render.test.js b/node_modules/preact/compat/test/browser/render.test.js
new file mode 100644
index 0000000..ca6190b
--- /dev/null
+++ b/node_modules/preact/compat/test/browser/render.test.js
@@ -0,0 +1,357 @@
+import React, {
+	createElement,
+	render,
+	Component,
+	hydrate,
+	createContext
+} from 'preact/compat';
+import { setupRerender, act } from 'preact/test-utils';
+import {
+	setupScratch,
+	teardown,
+	serializeHtml,
+	createEvent
+} from '../../../test/_util/helpers';
+
+describe('compat render', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	/** @type {() => void} */
+	let rerender;
+
+	const ce = type => document.createElement(type);
+	const text = text => document.createTextNode(text);
+
+	beforeEach(() => {
+		scratch = setupScratch();
+		rerender = setupRerender();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	it('should render react-style jsx', () => {
+		let jsx = (
+			<div className="foo bar" data-foo="bar">
+				<span id="some_id">inner!</span>
+				{['a', 'b']}
+			</div>
+		);
+
+		expect(jsx.props).to.have.property('className', 'foo bar');
+
+		React.render(jsx, scratch);
+		expect(serializeHtml(scratch)).to.equal(
+			'<div class="foo bar" data-foo="bar"><span id="some_id">inner!</span>ab</div>'
+		);
+	});
+
+	it('should replace isomorphic content', () => {
+		let root = ce('div');
+		let initialChild = ce('div');
+		initialChild.appendChild(text('initial content'));
+		root.appendChild(initialChild);
+
+		render(<div>dynamic content</div>, root);
+		expect(root)
+			.to.have.property('textContent')
+			.that.is.a('string')
+			.that.equals('dynamic content');
+	});
+
+	it('should remove extra elements', () => {
+		let root = ce('div');
+		let inner = ce('div');
+
+		root.appendChild(inner);
+
+		let c1 = ce('div');
+		c1.appendChild(text('isomorphic content'));
+		inner.appendChild(c1);
+
+		let c2 = ce('div');
+		c2.appendChild(text('extra content'));
+		inner.appendChild(c2);
+
+		render(<div>dynamic content</div>, root);
+		expect(root)
+			.to.have.property('textContent')
+			.that.is.a('string')
+			.that.equals('dynamic content');
+	});
+
+	// Note: Replacing text nodes inside the root itself is currently unsupported.
+	// We do replace them everywhere else, though.
+	it('should remove text nodes', () => {
+		let root = ce('div');
+
+		let div = ce('div');
+		root.appendChild(div);
+		div.appendChild(text('Text Content'));
+		div.appendChild(text('More Text Content'));
+
+		render(<div>dynamic content</div>, root);
+		expect(root)
+			.to.have.property('textContent')
+			.that.is.a('string')
+			.that.equals('dynamic content');
+	});
+
+	it('should ignore maxLength / minLength when is null', () => {
+		render(<input maxLength={null} minLength={null} />, scratch);
+		expect(scratch.firstElementChild.getAttribute('maxlength')).to.equal(null);
+		expect(scratch.firstElementChild.getAttribute('minlength')).to.equal(null);
+	});
+
+	it('should support defaultValue', () => {
+		render(<input defaultValue="foo" />, scratch);
+		expect(scratch.firstElementChild).to.have.property('value', 'foo');
+	});
+
+	it('should ignore defaultValue when value is 0', () => {
+		render(<input defaultValue={2} value={0} />, scratch);
+		expect(scratch.firstElementChild.value).to.equal('0');
+	});
+
+	it('should keep value of uncontrolled inputs using defaultValue', () => {
+		// See https://github.com/preactjs/preact/issues/2391
+
+		const spy = sinon.spy();
+
+		class Input extends Component {
+			render() {
+				return (
+					<input
+						type="text"
+						defaultValue="bar"
+						onChange={() => {
+							spy();
+							this.forceUpdate();
+						}}
+					/>
+				);
+			}
+		}
+
+		render(<Input />, scratch);
+		expect(scratch.firstChild.value).to.equal('bar');
+		scratch.firstChild.focus();
+		scratch.firstChild.value = 'foo';
+
+		scratch.firstChild.dispatchEvent(createEvent('input'));
+		rerender();
+		expect(scratch.firstChild.value).to.equal('foo');
+		expect(spy).to.be.calledOnce;
+	});
+
+	it('should call the callback', () => {
+		let spy = sinon.spy();
+		render(<div />, scratch, spy);
+		expect(spy).to.be.calledOnce;
+		expect(spy).to.be.calledWithExactly();
+	});
+
+	// Issue #1727
+	it('should destroy the any existing DOM nodes inside the container', () => {
+		scratch.appendChild(document.createElement('div'));
+		scratch.appendChild(document.createElement('div'));
+
+		render(<span>foo</span>, scratch);
+		expect(scratch.innerHTML).to.equal('<span>foo</span>');
+	});
+
+	it('should only destroy existing DOM nodes on first render', () => {
+		scratch.appendChild(document.createElement('div'));
+		scratch.appendChild(document.createElement('div'));
+
+		render(<input />, scratch);
+
+		let child = scratch.firstChild;
+		child.focus();
+		render(<input />, scratch);
+		expect(document.activeElement.nodeName).to.equal('INPUT');
+	});
+
+	it('should normalize class+className even on components', () => {
+		function Foo(props) {
+			return (
+				<div class={props.class} className={props.className}>
+					foo
+				</div>
+			);
+		}
+		render(<Foo class="foo" />, scratch);
+		expect(scratch.firstChild.className).to.equal('foo');
+		render(null, scratch);
+
+		render(<Foo className="foo" />, scratch);
+		expect(scratch.firstChild.className).to.equal('foo');
+	});
+
+	it('should normalize className when it has an empty string', () => {
+		function Foo(props) {
+			expect(props.className).to.equal('');
+			return <div className="">foo</div>;
+		}
+
+		render(<Foo className="" />, scratch);
+	});
+
+	// Issue #2275
+	it('should normalize class+className + DOM properties', () => {
+		function Foo(props) {
+			return <ul class="old" {...props} />;
+		}
+
+		render(<Foo fontSize="xlarge" className="new" />, scratch);
+		expect(scratch.firstChild.className).to.equal('new');
+	});
+
+	it('should give precedence to last-applied class/className prop', () => {
+		render(<ul className="from className" class="from class" />, scratch);
+		expect(scratch.firstChild.className).to.equal('from class');
+
+		render(<ul class="from class" className="from className" />, scratch);
+		expect(scratch.firstChild.className).to.equal('from className');
+	});
+
+	// Issue #2224
+	it('should not mark both class and className as enumerable', () => {
+		function ClassNameCheck(props) {
+			return (
+				<div>{props.propertyIsEnumerable('className') ? 'Failed' : ''}</div>
+			);
+		}
+
+		let update;
+		class OtherThing extends Component {
+			render({ children }) {
+				update = () => this.forceUpdate();
+				return (
+					<div>
+						{children}
+						<ClassNameCheck class="test" />
+					</div>
+				);
+			}
+		}
+
+		function App() {
+			return (
+				<OtherThing>
+					<ClassNameCheck class="test" />
+				</OtherThing>
+			);
+		}
+
+		render(<App />, scratch);
+
+		update();
+		rerender();
+
+		expect(/Failed/g.test(scratch.textContent)).to.equal(
+			false,
+			'not enumerable'
+		);
+	});
+
+	it('should cast boolean "download" values', () => {
+		render(<a download />, scratch);
+		expect(scratch.firstChild.getAttribute('download')).to.equal('');
+
+		render(<a download={false} />, scratch);
+		expect(scratch.firstChild.getAttribute('download')).to.equal(null);
+	});
+
+	it('should support static content', () => {
+		const updateSpy = sinon.spy();
+		const mountSpy = sinon.spy();
+		const renderSpy = sinon.spy();
+
+		function StaticContent({ children, element = 'div', staticMode }) {
+			// if we're in the server or a spa navigation, just render it
+			if (!staticMode) {
+				return createElement(element, {
+					children
+				});
+			}
+
+			// avoid re-render on the client
+			return createElement(element, {
+				dangerouslySetInnerHTML: { __html: '' }
+			});
+		}
+
+		class App extends Component {
+			componentDidMount() {
+				mountSpy();
+			}
+
+			componentDidUpdate() {
+				updateSpy();
+			}
+
+			render() {
+				renderSpy();
+				return <div>Staticness</div>;
+			}
+		}
+
+		act(() => {
+			render(
+				<StaticContent staticMode={false}>
+					<App />
+				</StaticContent>,
+				scratch
+			);
+		});
+
+		expect(scratch.innerHTML).to.eq('<div><div>Staticness</div></div>');
+		expect(renderSpy).to.be.calledOnce;
+		expect(mountSpy).to.be.calledOnce;
+		expect(updateSpy).to.not.be.calledOnce;
+
+		act(() => {
+			hydrate(
+				<StaticContent staticMode>
+					<App />
+				</StaticContent>,
+				scratch
+			);
+		});
+
+		expect(scratch.innerHTML).to.eq('<div><div>Staticness</div></div>');
+		expect(renderSpy).to.be.calledOnce;
+		expect(mountSpy).to.be.calledOnce;
+		expect(updateSpy).to.not.be.calledOnce;
+	});
+
+	it("should support react-relay's usage of __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED", () => {
+		const Ctx = createContext('foo');
+
+		// Simplified version of: https://github.com/facebook/relay/blob/fba79309977bf6b356ee77a5421ca5e6f306223b/packages/react-relay/readContext.js#L17-L28
+		function readContext(Context) {
+			const {
+				ReactCurrentDispatcher
+			} = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
+			const dispatcher = ReactCurrentDispatcher.current;
+			return dispatcher.readContext(Context);
+		}
+
+		function Foo() {
+			const value = readContext(Ctx);
+			return <div>{value}</div>;
+		}
+
+		React.render(
+			<Ctx.Provider value="foo">
+				<Foo />
+			</Ctx.Provider>,
+			scratch
+		);
+
+		expect(scratch.textContent).to.equal('foo');
+	});
+});
diff --git a/node_modules/preact/compat/test/browser/select.test.js b/node_modules/preact/compat/test/browser/select.test.js
new file mode 100644
index 0000000..bf8c9b9
--- /dev/null
+++ b/node_modules/preact/compat/test/browser/select.test.js
@@ -0,0 +1,33 @@
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+import React, { createElement, render } from 'preact/compat';
+
+describe('Select', () => {
+	let scratch;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	it('should work with multiple selected (array of values)', () => {
+		function App() {
+			return (
+				<select multiple value={['B', 'C']}>
+					<option value="A">A</option>
+					<option value="B">B</option>
+					<option value="C">C</option>
+				</select>
+			);
+		}
+
+		render(<App />, scratch);
+		const options = scratch.firstChild.children;
+		expect(options[0]).to.have.property('selected', false);
+		expect(options[1]).to.have.property('selected', true);
+		expect(options[2]).to.have.property('selected', true);
+		expect(scratch.firstChild.value).to.equal('B');
+	});
+});
diff --git a/node_modules/preact/compat/test/browser/suspense-list.test.js b/node_modules/preact/compat/test/browser/suspense-list.test.js
new file mode 100644
index 0000000..f3d4c91
--- /dev/null
+++ b/node_modules/preact/compat/test/browser/suspense-list.test.js
@@ -0,0 +1,588 @@
+import { setupRerender } from 'preact/test-utils';
+import React, {
+	createElement,
+	render,
+	Component,
+	Suspense,
+	SuspenseList
+} from 'preact/compat';
+import { useState } from 'preact/hooks';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+
+const h = React.createElement;
+/* eslint-env browser, mocha */
+
+function getSuspendableComponent(text) {
+	let resolve;
+	let resolved = false;
+	const promise = new Promise(_resolve => {
+		resolve = () => {
+			resolved = true;
+			_resolve();
+			return promise;
+		};
+	});
+
+	class LifecycleSuspender extends Component {
+		render() {
+			if (!resolved) {
+				throw promise;
+			}
+			return <span>{text}</span>;
+		}
+	}
+
+	LifecycleSuspender.resolve = () => {
+		resolve();
+	};
+
+	return LifecycleSuspender;
+}
+
+describe('suspense-list', () => {
+	/** @type {HTMLDivElement} */
+	let scratch,
+		rerender,
+		unhandledEvents = [];
+
+	function onUnhandledRejection(event) {
+		unhandledEvents.push(event);
+	}
+
+	function getSuspenseList(revealOrder) {
+		const A = getSuspendableComponent('A');
+		const B = getSuspendableComponent('B');
+		const C = getSuspendableComponent('C');
+		render(
+			<SuspenseList revealOrder={revealOrder}>
+				<Suspense fallback={<span>Loading...</span>}>
+					<A />
+				</Suspense>
+				<Suspense fallback={<span>Loading...</span>}>
+					<B />
+				</Suspense>
+				<Suspense fallback={<span>Loading...</span>}>
+					<C />
+				</Suspense>
+			</SuspenseList>,
+			scratch
+		); // Render initial state
+
+		return [A.resolve, B.resolve, C.resolve];
+	}
+
+	function getNestedSuspenseList(outerRevealOrder, innerRevealOrder) {
+		const A = getSuspendableComponent('A');
+		const B = getSuspendableComponent('B');
+		const C = getSuspendableComponent('C');
+		const D = getSuspendableComponent('D');
+
+		render(
+			<SuspenseList revealOrder={outerRevealOrder}>
+				<Suspense fallback={<span>Loading...</span>}>
+					<A />
+				</Suspense>
+				<SuspenseList revealOrder={innerRevealOrder}>
+					<Suspense fallback={<span>Loading...</span>}>
+						<B />
+					</Suspense>
+					<Suspense fallback={<span>Loading...</span>}>
+						<C />
+					</Suspense>
+				</SuspenseList>
+				<Suspense fallback={<span>Loading...</span>}>
+					<D />
+				</Suspense>
+			</SuspenseList>,
+			scratch
+		);
+		return [A.resolve, B.resolve, C.resolve, D.resolve];
+	}
+
+	beforeEach(() => {
+		scratch = setupScratch();
+		rerender = setupRerender();
+		unhandledEvents = [];
+
+		if ('onunhandledrejection' in window) {
+			window.addEventListener('unhandledrejection', onUnhandledRejection);
+		}
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+
+		if ('onunhandledrejection' in window) {
+			window.removeEventListener('unhandledrejection', onUnhandledRejection);
+
+			if (unhandledEvents.length) {
+				throw unhandledEvents[0].reason;
+			}
+		}
+	});
+
+	it('should work for single element', async () => {
+		const Component = getSuspendableComponent('A');
+		render(
+			<SuspenseList>
+				<Suspense fallback={<span>Loading...</span>}>
+					<Component />
+				</Suspense>
+			</SuspenseList>,
+			scratch
+		); // Render initial state
+
+		rerender(); // Re-render with fallback cuz lazy threw
+		expect(scratch.innerHTML).to.eql(`<span>Loading...</span>`);
+
+		await Component.resolve();
+		rerender();
+		expect(scratch.innerHTML).to.eql(`<span>A</span>`);
+	});
+
+	it('should let components appear backwards if no revealOrder is mentioned', async () => {
+		const [resolver1, resolver2, resolver3] = getSuspenseList();
+
+		rerender(); // Re-render with fallback cuz lazy threw
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolver2();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>B</span><span>Loading...</span>`
+		);
+
+		await resolver3();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>B</span><span>C</span>`
+		);
+
+		await resolver1();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>A</span><span>B</span><span>C</span>`
+		);
+	});
+
+	it('should let components appear forwards if no revealOrder is mentioned', async () => {
+		const [resolver1, resolver2, resolver3] = getSuspenseList();
+
+		rerender(); // Re-render with fallback cuz lazy threw
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolver1();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>A</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolver2();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>A</span><span>B</span><span>Loading...</span>`
+		);
+
+		await resolver3();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>A</span><span>B</span><span>C</span>`
+		);
+	});
+
+	it('should let components appear in forwards if revealOrder=forwards and first one resolves before others', async () => {
+		const [resolver1, resolver2, resolver3] = getSuspenseList('forwards');
+
+		rerender(); // Re-render with fallback cuz lazy threw
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolver1();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>A</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolver3();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>A</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolver2();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>A</span><span>B</span><span>C</span>`
+		);
+	});
+
+	it('should make components appear together if revealOrder=forwards and others resolves before first', async () => {
+		const [resolver1, resolver2, resolver3] = getSuspenseList('forwards');
+
+		rerender(); // Re-render with fallback cuz lazy threw
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolver2();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolver3();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolver1();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>A</span><span>B</span><span>C</span>`
+		);
+	});
+
+	it('should let components appear backwards if revealOrder=backwards and others resolves before first', async () => {
+		const [resolver1, resolver2, resolver3] = getSuspenseList('backwards');
+
+		rerender(); // Re-render with fallback cuz lazy threw
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolver3();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>Loading...</span><span>C</span>`
+		);
+
+		await resolver2();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>B</span><span>C</span>`
+		);
+
+		await resolver1();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>A</span><span>B</span><span>C</span>`
+		);
+	});
+
+	it('should make components appear together if revealOrder=backwards and first one resolves others', async () => {
+		const [resolver1, resolver2, resolver3] = getSuspenseList('backwards');
+
+		rerender(); // Re-render with fallback cuz lazy threw
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolver1();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolver3();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>Loading...</span><span>C</span>`
+		);
+
+		await resolver2();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>A</span><span>B</span><span>C</span>`
+		);
+	});
+
+	it('should make components appear together if revealOrder=together and first one resolves others', async () => {
+		const [resolver1, resolver2, resolver3] = getSuspenseList('together');
+
+		rerender(); // Re-render with fallback cuz lazy threw
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolver1();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolver3();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolver2();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>A</span><span>B</span><span>C</span>`
+		);
+	});
+
+	it('should make components appear together if revealOrder=together and second one resolves before others', async () => {
+		const [resolver1, resolver2, resolver3] = getSuspenseList('together');
+
+		rerender(); // Re-render with fallback cuz lazy threw
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolver2();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolver1();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolver3();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>A</span><span>B</span><span>C</span>`
+		);
+	});
+
+	it('should not do anything to non suspense elements', async () => {
+		const A = getSuspendableComponent('A');
+		const B = getSuspendableComponent('B');
+		render(
+			<SuspenseList>
+				<Suspense fallback={<span>Loading...</span>}>
+					<A />
+				</Suspense>
+				<div>foo</div>
+				<Suspense fallback={<span>Loading...</span>}>
+					<B />
+				</Suspense>
+				<span>bar</span>
+			</SuspenseList>,
+			scratch
+		);
+
+		rerender(); // Re-render with fallback cuz lazy threw
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><div>foo</div><span>Loading...</span><span>bar</span>`
+		);
+
+		await A.resolve();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>A</span><div>foo</div><span>Loading...</span><span>bar</span>`
+		);
+
+		await B.resolve();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>A</span><div>foo</div><span>B</span><span>bar</span>`
+		);
+	});
+
+	it('should make sure nested SuspenseList works with forwards', async () => {
+		const [resolveA, resolveB, resolveC, resolveD] = getNestedSuspenseList(
+			'forwards',
+			'forwards'
+		);
+		rerender(); // Re-render with fallback cuz lazy threw
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>Loading...</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolveB();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>Loading...</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolveA();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>A</span><span>B</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolveC();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>A</span><span>B</span><span>C</span><span>Loading...</span>`
+		);
+
+		await resolveD();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>A</span><span>B</span><span>C</span><span>D</span>`
+		);
+	});
+
+	it('should make sure nested SuspenseList works with backwards', async () => {
+		const [resolveA, resolveB, resolveC, resolveD] = getNestedSuspenseList(
+			'forwards',
+			'backwards'
+		);
+		rerender(); // Re-render with fallback cuz lazy threw
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>Loading...</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolveA();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>A</span><span>Loading...</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolveC();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>A</span><span>Loading...</span><span>C</span><span>Loading...</span>`
+		);
+
+		await resolveB();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>A</span><span>B</span><span>C</span><span>Loading...</span>`
+		);
+
+		await resolveD();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>A</span><span>B</span><span>C</span><span>D</span>`
+		);
+	});
+
+	it('should make sure nested SuspenseList works with together', async () => {
+		const [resolveA, resolveB, resolveC, resolveD] = getNestedSuspenseList(
+			'together',
+			'forwards'
+		);
+		rerender(); // Re-render with fallback cuz lazy threw
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>Loading...</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolveA();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>Loading...</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolveD();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>Loading...</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolveB();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>Loading...</span><span>Loading...</span><span>Loading...</span><span>Loading...</span>`
+		);
+
+		await resolveC();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<span>A</span><span>B</span><span>C</span><span>D</span>`
+		);
+	});
+
+	it('should work with forwards even when a <Suspense> child does not suspend', async () => {
+		const Component = getSuspendableComponent('A');
+
+		render(
+			<SuspenseList revealOrder="forwards">
+				<Suspense fallback={<span>Loading...</span>}>
+					<div />
+				</Suspense>
+				<Suspense fallback={<span>Loading...</span>}>
+					<Component />
+				</Suspense>
+			</SuspenseList>,
+			scratch
+		); // Render initial state
+
+		rerender();
+		expect(scratch.innerHTML).to.eql(`<div></div><span>Loading...</span>`);
+
+		await Component.resolve();
+		rerender();
+		expect(scratch.innerHTML).to.eql(`<div></div><span>A</span>`);
+	});
+
+	it('should work with together even when a <Suspense> child does not suspend', async () => {
+		const Component = getSuspendableComponent('A');
+
+		render(
+			<SuspenseList revealOrder="together">
+				<Suspense fallback={<span>Loading...</span>}>
+					<div />
+				</Suspense>
+				<Suspense fallback={<span>Loading...</span>}>
+					<Component />
+				</Suspense>
+			</SuspenseList>,
+			scratch
+		); // Render initial state
+
+		rerender();
+		expect(scratch.innerHTML).to.eql(`<div></div><span>Loading...</span>`);
+
+		await Component.resolve();
+		rerender();
+		expect(scratch.innerHTML).to.eql(`<div></div><span>A</span>`);
+	});
+
+	it('should not suspend resolved children if a new suspense comes in between', async () => {
+		const ComponentA = getSuspendableComponent('A');
+		const ComponentB = getSuspendableComponent('B');
+
+		let showB;
+		function Container() {
+			const [showHidden, setShowHidden] = useState(false);
+			showB = setShowHidden;
+			return (
+				<SuspenseList revealOrder="together">
+					<Suspense fallback={<span>Loading...</span>}>
+						<div />
+					</Suspense>
+					{showHidden && (
+						<Suspense fallback={<span>Loading...</span>}>
+							<ComponentB />
+						</Suspense>
+					)}
+					<Suspense fallback={<span>Loading...</span>}>
+						<ComponentA />
+					</Suspense>
+				</SuspenseList>
+			);
+		}
+		render(<Container />, scratch); // Render initial state
+
+		rerender();
+		expect(scratch.innerHTML).to.eql(`<div></div><span>Loading...</span>`);
+
+		await ComponentA.resolve();
+		rerender();
+		expect(scratch.innerHTML).to.eql(`<div></div><span>A</span>`);
+
+		showB(true);
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`<div></div><span>Loading...</span><span>A</span>`
+		);
+
+		await ComponentB.resolve();
+		rerender();
+		expect(scratch.innerHTML).to.eql(`<div></div><span>B</span><span>A</span>`);
+	});
+});
diff --git a/node_modules/preact/compat/test/browser/suspense.test.js b/node_modules/preact/compat/test/browser/suspense.test.js
new file mode 100644
index 0000000..da3a8bf
--- /dev/null
+++ b/node_modules/preact/compat/test/browser/suspense.test.js
@@ -0,0 +1,1815 @@
+import { setupRerender } from 'preact/test-utils';
+import React, {
+	createElement,
+	render,
+	Component,
+	Suspense,
+	lazy,
+	Fragment,
+	createContext
+} from 'preact/compat';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+
+const h = React.createElement;
+/* eslint-env browser, mocha */
+
+/**
+ * @typedef {import('../../../src').ComponentType<any>} ComponentType
+ * @returns {[typeof Component, (c: ComponentType) => Promise<void>, (c: ComponentType) => void]}
+ */
+function createLazy() {
+	/** @type {(c: ComponentType) => Promise<void>} */
+	let resolver, rejecter;
+	const Lazy = lazy(() => {
+		let promise = new Promise((resolve, reject) => {
+			resolver = c => {
+				resolve({ default: c });
+				return promise;
+			};
+
+			rejecter = () => {
+				reject();
+				return promise;
+			};
+		});
+
+		return promise;
+	});
+
+	return [Lazy, c => resolver(c), e => rejecter(e)];
+}
+
+/**
+ * @typedef {[(c: ComponentType) => Promise<void>, (error: Error) => Promise<void>]} Resolvers
+ * @param {ComponentType} DefaultComponent
+ * @returns {[typeof Component, () => Resolvers]}
+ */
+export function createSuspender(DefaultComponent) {
+	/** @type {(lazy: React.JSX.Element) => void} */
+	let renderLazy;
+	class Suspender extends Component {
+		constructor(props, context) {
+			super(props, context);
+			this.state = { Lazy: null };
+
+			renderLazy = Lazy => this.setState({ Lazy });
+		}
+
+		render(props, state) {
+			return state.Lazy ? h(state.Lazy, props) : h(DefaultComponent, props);
+		}
+	}
+
+	sinon.spy(Suspender.prototype, 'render');
+
+	/**
+	 * @returns {Resolvers}
+	 */
+	function suspend() {
+		const [Lazy, resolve, reject] = createLazy();
+		renderLazy(Lazy);
+		return [resolve, reject];
+	}
+
+	return [Suspender, suspend];
+}
+
+class Catcher extends Component {
+	constructor(props) {
+		super(props);
+		this.state = { error: false };
+	}
+
+	componentDidCatch(e) {
+		if (e.then) {
+			this.setState({ error: { message: '{Promise}' } });
+		} else {
+			this.setState({ error: e });
+		}
+	}
+
+	render(props, state) {
+		return state.error ? (
+			<div>Catcher did catch: {state.error.message}</div>
+		) : (
+			props.children
+		);
+	}
+}
+
+describe('suspense', () => {
+	/** @type {HTMLDivElement} */
+	let scratch,
+		rerender,
+		unhandledEvents = [];
+
+	function onUnhandledRejection(event) {
+		unhandledEvents.push(event);
+	}
+
+	beforeEach(() => {
+		scratch = setupScratch();
+		rerender = setupRerender();
+
+		unhandledEvents = [];
+		if ('onunhandledrejection' in window) {
+			window.addEventListener('unhandledrejection', onUnhandledRejection);
+		}
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+
+		if ('onunhandledrejection' in window) {
+			window.removeEventListener('unhandledrejection', onUnhandledRejection);
+
+			if (unhandledEvents.length) {
+				throw unhandledEvents[0].reason;
+			}
+		}
+	});
+
+	it('should support lazy', () => {
+		const LazyComp = ({ name }) => <div>Hello from {name}</div>;
+
+		/** @type {() => Promise<void>} */
+		let resolve;
+		const Lazy = lazy(() => {
+			const p = new Promise(res => {
+				resolve = () => {
+					res({ default: LazyComp });
+					return p;
+				};
+			});
+
+			return p;
+		});
+
+		render(
+			<Suspense fallback={<div>Suspended...</div>}>
+				<Lazy name="LazyComp" />
+			</Suspense>,
+			scratch
+		); // Render initial state
+		rerender(); // Re-render with fallback cuz lazy threw
+
+		expect(scratch.innerHTML).to.eql(`<div>Suspended...</div>`);
+
+		return resolve().then(() => {
+			rerender();
+			expect(scratch.innerHTML).to.eql(`<div>Hello from LazyComp</div>`);
+		});
+	});
+
+	it('should support a call to setState before rendering the fallback', () => {
+		const LazyComp = ({ name }) => <div>Hello from {name}</div>;
+
+		/** @type {() => Promise<void>} */
+		let resolve;
+		const Lazy = lazy(() => {
+			const p = new Promise(res => {
+				resolve = () => {
+					res({ default: LazyComp });
+					return p;
+				};
+			});
+
+			return p;
+		});
+
+		/** @type {(Object) => void} */
+		let setState;
+		class App extends Component {
+			constructor(props) {
+				super(props);
+				this.state = {};
+				setState = this.setState.bind(this);
+			}
+			render(props, state) {
+				return (
+					<Fragment>
+						<Suspense fallback={<div>Suspended...</div>}>
+							<Lazy name="LazyComp" />
+						</Suspense>
+					</Fragment>
+				);
+			}
+		}
+
+		render(<App />, scratch); // Render initial state
+
+		setState({ foo: 'bar' });
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(`<div>Suspended...</div>`);
+
+		return resolve().then(() => {
+			rerender();
+			expect(scratch.innerHTML).to.eql(`<div>Hello from LazyComp</div>`);
+		});
+	});
+
+	it('lazy should forward refs', () => {
+		const LazyComp = () => <div>Hello from LazyComp</div>;
+		let ref = {};
+
+		/** @type {() => Promise<void>} */
+		let resolve;
+		const Lazy = lazy(() => {
+			const p = new Promise(res => {
+				resolve = () => {
+					res({ default: LazyComp });
+					return p;
+				};
+			});
+
+			return p;
+		});
+
+		render(
+			<Suspense fallback={<div>Suspended...</div>}>
+				<Lazy ref={ref} />
+			</Suspense>,
+			scratch
+		);
+		rerender();
+
+		return resolve().then(() => {
+			rerender();
+			expect(ref.current.constructor).to.equal(LazyComp);
+		});
+	});
+
+	it('should suspend when a promise is thrown', () => {
+		class ClassWrapper extends Component {
+			render(props) {
+				return <div id="class-wrapper">{props.children}</div>;
+			}
+		}
+
+		const FuncWrapper = props => <div id="func-wrapper">{props.children}</div>;
+
+		const [Suspender, suspend] = createSuspender(() => <div>Hello</div>);
+
+		render(
+			<Suspense fallback={<div>Suspended...</div>}>
+				<ClassWrapper>
+					<FuncWrapper>
+						<Suspender />
+					</FuncWrapper>
+				</ClassWrapper>
+			</Suspense>,
+			scratch
+		);
+
+		expect(scratch.innerHTML).to.eql(
+			`<div id="class-wrapper"><div id="func-wrapper"><div>Hello</div></div></div>`
+		);
+
+		const [resolve] = suspend();
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(`<div>Suspended...</div>`);
+
+		return resolve(() => <div>Hello2</div>).then(() => {
+			rerender();
+			expect(scratch.innerHTML).to.eql(
+				`<div id="class-wrapper"><div id="func-wrapper"><div>Hello2</div></div></div>`
+			);
+		});
+	});
+
+	it('should not call lifecycle methods of an initially suspending component', () => {
+		let componentWillMount = sinon.spy();
+		let componentDidMount = sinon.spy();
+		let componentWillUnmount = sinon.spy();
+
+		/** @type {() => Promise<void>} */
+		let resolve;
+		let resolved = false;
+		const promise = new Promise(_resolve => {
+			resolve = () => {
+				resolved = true;
+				_resolve();
+				return promise;
+			};
+		});
+
+		class LifecycleSuspender extends Component {
+			render() {
+				if (!resolved) {
+					throw promise;
+				}
+				return <div>Lifecycle</div>;
+			}
+			componentWillMount() {
+				componentWillMount();
+			}
+			componentDidMount() {
+				componentDidMount();
+			}
+			componentWillUnmount() {
+				componentWillUnmount();
+			}
+		}
+
+		render(
+			<Suspense fallback={<div>Suspended...</div>}>
+				<LifecycleSuspender />
+			</Suspense>,
+			scratch
+		);
+
+		expect(scratch.innerHTML).to.eql(``);
+		expect(componentWillMount).to.have.been.calledOnce;
+		expect(componentDidMount).to.not.have.been.called;
+		expect(componentWillUnmount).to.not.have.been.called;
+
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(`<div>Suspended...</div>`);
+		expect(componentWillMount).to.have.been.calledOnce;
+		expect(componentDidMount).to.not.have.been.called;
+		expect(componentWillUnmount).to.not.have.been.called;
+
+		return resolve().then(() => {
+			rerender();
+			expect(scratch.innerHTML).to.eql(`<div>Lifecycle</div>`);
+
+			expect(componentWillMount).to.have.been.calledOnce;
+			expect(componentDidMount).to.have.been.calledOnce;
+			expect(componentWillUnmount).to.not.have.been.called;
+		});
+	});
+
+	it('should properly call lifecycle methods and maintain state of a delayed suspending component', () => {
+		let componentWillMount = sinon.spy();
+		let componentDidMount = sinon.spy();
+		let componentDidUpdate = sinon.spy();
+		let componentWillUnmount = sinon.spy();
+
+		/** @type {() => void} */
+		let increment;
+
+		/** @type {() => Promise<void>} */
+		let resolve;
+		let resolved = false;
+		const promise = new Promise(_resolve => {
+			resolve = () => {
+				resolved = true;
+				_resolve();
+				return promise;
+			};
+		});
+
+		class LifecycleSuspender extends Component {
+			constructor(props) {
+				super(props);
+				this.state = { count: 0 };
+
+				increment = () => this.setState(({ count }) => ({ count: count + 1 }));
+			}
+			render() {
+				if (this.state.count == 2 && !resolved) {
+					throw promise;
+				}
+
+				return (
+					<Fragment>
+						<p>Count: {this.state.count}</p>
+					</Fragment>
+				);
+			}
+			componentWillMount() {
+				componentWillMount();
+			}
+			componentDidMount() {
+				componentDidMount();
+			}
+			componentWillUnmount() {
+				componentWillUnmount();
+			}
+			componentDidUpdate() {
+				componentDidUpdate();
+			}
+		}
+
+		render(
+			<Suspense fallback={<div>Suspended...</div>}>
+				<LifecycleSuspender />
+			</Suspense>,
+			scratch
+		);
+
+		expect(scratch.innerHTML).to.eql(`<p>Count: 0</p>`);
+		expect(componentWillMount).to.have.been.calledOnce;
+		expect(componentDidMount).to.have.been.calledOnce;
+		expect(componentDidUpdate).to.not.have.been.called;
+		expect(componentWillUnmount).to.not.have.been.called;
+
+		increment();
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(`<p>Count: 1</p>`);
+		expect(componentWillMount).to.have.been.calledOnce;
+		expect(componentDidMount).to.have.been.calledOnce;
+		expect(componentDidUpdate).to.have.been.calledOnce;
+		expect(componentWillUnmount).to.not.have.been.called;
+
+		increment();
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(`<div>Suspended...</div>`);
+		expect(componentWillMount).to.have.been.calledOnce;
+		expect(componentDidMount).to.have.been.calledOnce;
+		expect(componentDidUpdate).to.have.been.calledOnce;
+		expect(componentWillUnmount).to.not.have.been.called;
+
+		return resolve().then(() => {
+			rerender();
+
+			expect(scratch.innerHTML).to.eql(`<p>Count: 2</p>`);
+			expect(componentWillMount).to.have.been.calledOnce;
+			expect(componentDidMount).to.have.been.calledOnce;
+			// TODO: This is called thrice since the cDU queued up after the second
+			// increment is never cleared once the component suspends. So when it
+			// resumes and the component is rerendered, we queue up another cDU so
+			// cDU is called an extra time.
+			expect(componentDidUpdate).to.have.been.calledThrice;
+			expect(componentWillUnmount).to.not.have.been.called;
+		});
+	});
+
+	it('should not call lifecycle methods when a sibling suspends', () => {
+		let componentWillMount = sinon.spy();
+		let componentDidMount = sinon.spy();
+		let componentWillUnmount = sinon.spy();
+		class LifecycleLogger extends Component {
+			render() {
+				return <div>Lifecycle</div>;
+			}
+			componentWillMount() {
+				componentWillMount();
+			}
+			componentDidMount() {
+				componentDidMount();
+			}
+			componentWillUnmount() {
+				componentWillUnmount();
+			}
+		}
+
+		const [Suspender, suspend] = createSuspender(() => <div>Suspense</div>);
+
+		render(
+			<Suspense fallback={<div>Suspended...</div>}>
+				<Suspender />
+				<LifecycleLogger />
+			</Suspense>,
+			scratch
+		);
+
+		expect(scratch.innerHTML).to.eql(`<div>Suspense</div><div>Lifecycle</div>`);
+		expect(componentWillMount).to.have.been.calledOnce;
+		expect(componentDidMount).to.have.been.calledOnce;
+		expect(componentWillUnmount).to.not.have.been.called;
+
+		const [resolve] = suspend();
+
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(`<div>Suspended...</div>`);
+		expect(componentWillMount).to.have.been.calledOnce;
+		expect(componentDidMount).to.have.been.calledOnce;
+		expect(componentWillUnmount).to.not.have.been.called;
+
+		return resolve(() => <div>Suspense 2</div>).then(() => {
+			rerender();
+			expect(scratch.innerHTML).to.eql(
+				`<div>Suspense 2</div><div>Lifecycle</div>`
+			);
+
+			expect(componentWillMount).to.have.been.calledOnce;
+			expect(componentDidMount).to.have.been.calledOnce;
+			expect(componentWillUnmount).to.not.have.been.called;
+		});
+	});
+
+	it("should call fallback's lifecycle methods when suspending", () => {
+		class LifecycleLogger extends Component {
+			render() {
+				return <div>Lifecycle</div>;
+			}
+			componentWillMount() {}
+			componentDidMount() {}
+			componentWillUnmount() {}
+		}
+
+		const componentWillMount = sinon.spy(
+			LifecycleLogger.prototype,
+			'componentWillMount'
+		);
+		const componentDidMount = sinon.spy(
+			LifecycleLogger.prototype,
+			'componentDidMount'
+		);
+		const componentWillUnmount = sinon.spy(
+			LifecycleLogger.prototype,
+			'componentWillUnmount'
+		);
+
+		const [Suspender, suspend] = createSuspender(() => <div>Suspense</div>);
+
+		render(
+			<Suspense fallback={<LifecycleLogger />}>
+				<Suspender />
+			</Suspense>,
+			scratch
+		);
+
+		expect(scratch.innerHTML).to.eql(`<div>Suspense</div>`);
+		expect(componentWillMount).to.not.have.been.called;
+		expect(componentDidMount).to.not.have.been.called;
+		expect(componentWillUnmount).to.not.have.been.called;
+
+		const [resolve] = suspend();
+
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(`<div>Lifecycle</div>`);
+		expect(componentWillMount).to.have.been.calledOnce;
+		expect(componentDidMount).to.have.been.calledOnce;
+		expect(componentWillUnmount).to.not.have.been.called;
+
+		return resolve(() => <div>Suspense 2</div>).then(() => {
+			rerender();
+			expect(scratch.innerHTML).to.eql(`<div>Suspense 2</div>`);
+
+			expect(componentWillMount).to.have.been.calledOnce;
+			expect(componentDidMount).to.have.been.calledOnce;
+			expect(componentWillUnmount).to.have.been.calledOnce;
+		});
+	});
+
+	it('should keep state of siblings when suspending', () => {
+		/** @type {(state: { s: string }) => void} */
+		let setState;
+		class Stateful extends Component {
+			constructor(props) {
+				super(props);
+				setState = this.setState.bind(this);
+				this.state = { s: 'initial' };
+			}
+			render(props, state) {
+				return <div>Stateful: {state.s}</div>;
+			}
+		}
+
+		const [Suspender, suspend] = createSuspender(() => <div>Suspense</div>);
+
+		render(
+			<Suspense fallback={<div>Suspended...</div>}>
+				<Suspender />
+				<Stateful />
+			</Suspense>,
+			scratch
+		);
+
+		expect(scratch.innerHTML).to.eql(
+			`<div>Suspense</div><div>Stateful: initial</div>`
+		);
+
+		setState({ s: 'first' });
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(
+			`<div>Suspense</div><div>Stateful: first</div>`
+		);
+
+		const [resolve] = suspend();
+
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(`<div>Suspended...</div>`);
+
+		return resolve(() => <div>Suspense 2</div>).then(() => {
+			rerender();
+			expect(scratch.innerHTML).to.eql(
+				`<div>Suspense 2</div><div>Stateful: first</div>`
+			);
+		});
+	});
+
+	// TODO: Fix this test
+	it.skip('should allow children to update state while suspending', () => {
+		/** @type {(state: { s: string }) => void} */
+		let setState;
+		class Stateful extends Component {
+			constructor(props) {
+				super(props);
+				setState = this.setState.bind(this);
+				this.state = { s: 'initial' };
+			}
+			render(props, state) {
+				return <div>Stateful: {state.s}</div>;
+			}
+		}
+
+		const [Suspender, suspend] = createSuspender(() => <div>Suspense</div>);
+
+		render(
+			<Suspense fallback={<div>Suspended...</div>}>
+				<Suspender />
+				<Stateful />
+			</Suspense>,
+			scratch
+		);
+
+		expect(scratch.innerHTML).to.eql(
+			`<div>Suspense</div><div>Stateful: initial</div>`
+		);
+
+		setState({ s: 'first' });
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(
+			`<div>Suspense</div><div>Stateful: first</div>`
+		);
+
+		const [resolve] = suspend();
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(`<div>Suspended...</div>`);
+
+		setState({ s: 'second' });
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(`<div>Suspended...</div>`);
+
+		return resolve(() => <div>Suspense 2</div>).then(() => {
+			rerender();
+			expect(scratch.innerHTML).to.eql(
+				`<div>Suspense 2</div><div>Stateful: second</div>`
+			);
+		});
+	});
+
+	it('should allow siblings of Suspense to update state while suspending', () => {
+		/** @type {(state: { s: string }) => void} */
+		let setState;
+		class Stateful extends Component {
+			constructor(props) {
+				super(props);
+				setState = this.setState.bind(this);
+				this.state = { s: 'initial' };
+			}
+			render(props, state) {
+				return <div>Stateful: {state.s}</div>;
+			}
+		}
+
+		const [Suspender, suspend] = createSuspender(() => <div>Suspense</div>);
+
+		render(
+			<Fragment>
+				<Suspense fallback={<div>Suspended...</div>}>
+					<Suspender />
+				</Suspense>
+				<Stateful />
+			</Fragment>,
+			scratch
+		);
+
+		expect(scratch.innerHTML).to.eql(
+			`<div>Suspense</div><div>Stateful: initial</div>`
+		);
+
+		setState({ s: 'first' });
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(
+			`<div>Suspense</div><div>Stateful: first</div>`
+		);
+
+		const [resolve] = suspend();
+
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(
+			`<div>Suspended...</div><div>Stateful: first</div>`
+		);
+
+		setState({ s: 'second' });
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(
+			`<div>Suspended...</div><div>Stateful: second</div>`
+		);
+
+		return resolve(() => <div>Suspense 2</div>).then(() => {
+			rerender();
+			expect(scratch.innerHTML).to.eql(
+				`<div>Suspense 2</div><div>Stateful: second</div>`
+			);
+		});
+	});
+
+	it('should suspend with custom error boundary', () => {
+		const [Suspender, suspend] = createSuspender(() => (
+			<div>within error boundary</div>
+		));
+
+		render(
+			<Suspense fallback={<div>Suspended...</div>}>
+				<Catcher>
+					<Suspender />
+				</Catcher>
+			</Suspense>,
+			scratch
+		);
+
+		expect(scratch.innerHTML).to.eql(`<div>within error boundary</div>`);
+
+		const [resolve] = suspend();
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(`<div>Suspended...</div>`);
+
+		return resolve(() => <div>within error boundary 2</div>).then(() => {
+			rerender();
+			expect(scratch.innerHTML).to.eql(`<div>within error boundary 2</div>`);
+		});
+	});
+
+	it('should allow multiple sibling children to suspend', () => {
+		const [Suspender1, suspend1] = createSuspender(() => (
+			<div>Hello first</div>
+		));
+		const [Suspender2, suspend2] = createSuspender(() => (
+			<div>Hello second</div>
+		));
+
+		render(
+			<Suspense fallback={<div>Suspended...</div>}>
+				<Catcher>
+					<Suspender1 />
+					<Suspender2 />
+				</Catcher>
+			</Suspense>,
+			scratch
+		);
+
+		expect(scratch.innerHTML).to.eql(
+			`<div>Hello first</div><div>Hello second</div>`
+		);
+		expect(Suspender1.prototype.render).to.have.been.calledOnce;
+		expect(Suspender2.prototype.render).to.have.been.calledOnce;
+
+		const [resolve1] = suspend1();
+		const [resolve2] = suspend2();
+		expect(Suspender1.prototype.render).to.have.been.calledOnce;
+		expect(Suspender2.prototype.render).to.have.been.calledOnce;
+
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(`<div>Suspended...</div>`);
+		expect(Suspender1.prototype.render).to.have.been.calledTwice;
+		expect(Suspender2.prototype.render).to.have.been.calledTwice;
+
+		return resolve1(() => <div>Hello first 2</div>).then(() => {
+			rerender();
+			expect(scratch.innerHTML).to.eql(`<div>Suspended...</div>`);
+			expect(Suspender1.prototype.render).to.have.been.calledTwice;
+			expect(Suspender2.prototype.render).to.have.been.calledTwice;
+
+			return resolve2(() => <div>Hello second 2</div>).then(() => {
+				rerender();
+				expect(scratch.innerHTML).to.eql(
+					`<div>Hello first 2</div><div>Hello second 2</div>`
+				);
+				expect(Suspender1.prototype.render).to.have.been.calledThrice;
+				expect(Suspender2.prototype.render).to.have.been.calledThrice;
+			});
+		});
+	});
+
+	it('should call multiple nested sibling suspending components render in one go', () => {
+		const [Suspender1, suspend1] = createSuspender(() => (
+			<div>Hello first</div>
+		));
+		const [Suspender2, suspend2] = createSuspender(() => (
+			<div>Hello second</div>
+		));
+
+		render(
+			<Suspense fallback={<div>Suspended...</div>}>
+				<Catcher>
+					<Suspender1 />
+					<div>
+						<Suspender2 />
+					</div>
+				</Catcher>
+			</Suspense>,
+			scratch
+		);
+
+		expect(scratch.innerHTML).to.eql(
+			`<div>Hello first</div><div><div>Hello second</div></div>`
+		);
+		expect(Suspender1.prototype.render).to.have.been.calledOnce;
+		expect(Suspender2.prototype.render).to.have.been.calledOnce;
+
+		const [resolve1] = suspend1();
+		const [resolve2] = suspend2();
+		expect(Suspender1.prototype.render).to.have.been.calledOnce;
+		expect(Suspender2.prototype.render).to.have.been.calledOnce;
+
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(`<div>Suspended...</div>`);
+		expect(Suspender1.prototype.render).to.have.been.calledTwice;
+		expect(Suspender2.prototype.render).to.have.been.calledTwice;
+
+		return resolve1(() => <div>Hello first 2</div>).then(() => {
+			rerender();
+			expect(scratch.innerHTML).to.eql(`<div>Suspended...</div>`);
+			expect(Suspender1.prototype.render).to.have.been.calledTwice;
+			expect(Suspender2.prototype.render).to.have.been.calledTwice;
+
+			return resolve2(() => <div>Hello second 2</div>).then(() => {
+				rerender();
+				expect(scratch.innerHTML).to.eql(
+					`<div>Hello first 2</div><div><div>Hello second 2</div></div>`
+				);
+				expect(Suspender1.prototype.render).to.have.been.calledThrice;
+				expect(Suspender2.prototype.render).to.have.been.calledThrice;
+			});
+		});
+	});
+
+	it('should support text directly under Suspense', () => {
+		const [Suspender, suspend] = createSuspender(() => <div>Hello</div>);
+
+		render(
+			<Suspense fallback={<div>Suspended...</div>}>
+				Text
+				{/* Adding a <div> here will make things work... */}
+				<Suspender />
+			</Suspense>,
+			scratch
+		);
+
+		expect(scratch.innerHTML).to.eql(`Text<div>Hello</div>`);
+
+		const [resolve] = suspend();
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(`<div>Suspended...</div>`);
+
+		return resolve(() => <div>Hello 2</div>).then(() => {
+			rerender();
+			expect(scratch.innerHTML).to.eql(`Text<div>Hello 2</div>`);
+		});
+	});
+
+	it('should support to change DOM tag directly under suspense', () => {
+		/** @type {(state: {tag: string}) => void} */
+		let setState;
+		class StatefulComp extends Component {
+			constructor(props) {
+				super(props);
+				setState = this.setState.bind(this);
+				this.state = {
+					tag: props.defaultTag
+				};
+			}
+			render(props, { tag: Tag }) {
+				return <Tag>Stateful</Tag>;
+			}
+		}
+
+		const [Suspender, suspend] = createSuspender(() => <div>Hello</div>);
+
+		render(
+			<Suspense fallback={<div>Suspended...</div>}>
+				<StatefulComp defaultTag="div" />
+				<Suspender />
+			</Suspense>,
+			scratch
+		);
+
+		expect(scratch.innerHTML).to.eql(`<div>Stateful</div><div>Hello</div>`);
+
+		const [resolve] = suspend();
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(`<div>Suspended...</div>`);
+
+		setState({ tag: 'article' });
+
+		return resolve(() => <div>Hello 2</div>).then(() => {
+			rerender();
+			expect(scratch.innerHTML).to.eql(
+				`<article>Stateful</article><div>Hello 2</div>`
+			);
+		});
+	});
+
+	it('should only suspend the most inner Suspend', () => {
+		const [Suspender, suspend] = createSuspender(() => <div>Hello</div>);
+
+		render(
+			<Suspense fallback={<div>Suspended... 1</div>}>
+				Not suspended...
+				<Suspense fallback={<div>Suspended... 2</div>}>
+					<Catcher>
+						<Suspender />
+					</Catcher>
+				</Suspense>
+			</Suspense>,
+			scratch
+		);
+
+		expect(scratch.innerHTML).to.eql(`Not suspended...<div>Hello</div>`);
+
+		const [resolve] = suspend();
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(
+			`Not suspended...<div>Suspended... 2</div>`
+		);
+
+		return resolve(() => <div>Hello 2</div>).then(() => {
+			rerender();
+			expect(scratch.innerHTML).to.eql(`Not suspended...<div>Hello 2</div>`);
+		});
+	});
+
+	it('should throw when missing Suspense', () => {
+		const [Suspender, suspend] = createSuspender(() => <div>Hello</div>);
+
+		render(
+			<Catcher>
+				<Suspender />
+			</Catcher>,
+			scratch
+		);
+		rerender();
+		expect(scratch.innerHTML).to.eql(`<div>Hello</div>`);
+
+		suspend();
+		rerender();
+		expect(scratch.innerHTML).to.eql(`<div>Catcher did catch: {Promise}</div>`);
+	});
+
+	it("should throw when lazy's loader throws", () => {
+		/** @type {() => Promise<any>} */
+		let reject;
+		const ThrowingLazy = lazy(() => {
+			const prom = new Promise((res, rej) => {
+				reject = () => {
+					rej(new Error("Thrown in lazy's loader..."));
+					return prom;
+				};
+			});
+
+			return prom;
+		});
+
+		render(
+			<Suspense fallback={<div>Suspended...</div>}>
+				<Catcher>
+					<ThrowingLazy />
+				</Catcher>
+			</Suspense>,
+			scratch
+		);
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(`<div>Suspended...</div>`);
+
+		return reject().then(
+			() => {
+				expect.fail('Suspended promises resolved instead of rejected.');
+			},
+			() => {
+				rerender();
+				expect(scratch.innerHTML).to.eql(
+					`<div>Catcher did catch: Thrown in lazy's loader...</div>`
+				);
+			}
+		);
+	});
+
+	it('should support null fallback', () => {
+		const [Suspender, suspend] = createSuspender(() => <div>Hello</div>);
+
+		render(
+			<div id="wrapper">
+				<Suspense fallback={null}>
+					<div id="inner">
+						<Suspender />
+					</div>
+				</Suspense>
+			</div>,
+			scratch
+		);
+		expect(scratch.innerHTML).to.equal(
+			`<div id="wrapper"><div id="inner"><div>Hello</div></div></div>`
+		);
+
+		const [resolve] = suspend();
+		rerender();
+		expect(scratch.innerHTML).to.equal(`<div id="wrapper"></div>`);
+
+		return resolve(() => <div>Hello2</div>).then(() => {
+			rerender();
+			expect(scratch.innerHTML).to.equal(
+				`<div id="wrapper"><div id="inner"><div>Hello2</div></div></div>`
+			);
+		});
+	});
+
+	it('should support suspending multiple times', () => {
+		const [Suspender, suspend] = createSuspender(() => (
+			<div>initial render</div>
+		));
+		const Loading = () => <div>Suspended...</div>;
+
+		render(
+			<Suspense fallback={<Loading />}>
+				<Suspender />
+			</Suspense>,
+			scratch
+		);
+
+		expect(scratch.innerHTML).to.eql(`<div>initial render</div>`);
+
+		let [resolve] = suspend();
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(`<div>Suspended...</div>`);
+
+		return resolve(() => <div>Hello1</div>)
+			.then(() => {
+				// Rerender promise resolution
+				rerender();
+				expect(scratch.innerHTML).to.eql(`<div>Hello1</div>`);
+
+				// suspend again
+				[resolve] = suspend();
+				rerender();
+
+				expect(scratch.innerHTML).to.eql(`<div>Suspended...</div>`);
+
+				return resolve(() => <div>Hello2</div>);
+			})
+			.then(() => {
+				// Rerender promise resolution
+				rerender();
+				expect(scratch.innerHTML).to.eql(`<div>Hello2</div>`);
+			});
+	});
+
+	it("should correctly render when a suspended component's child also suspends", () => {
+		const [Suspender1, suspend1] = createSuspender(() => <div>Hello1</div>);
+		const [LazyChild, resolveChild] = createLazy();
+
+		render(
+			<Suspense fallback={<div>Suspended...</div>}>
+				<Suspender1 />
+			</Suspense>,
+			scratch
+		);
+
+		expect(scratch.innerHTML).to.equal(`<div>Hello1</div>`);
+
+		let [resolve1] = suspend1();
+		rerender();
+		expect(scratch.innerHTML).to.equal('<div>Suspended...</div>');
+
+		return resolve1(() => <LazyChild />)
+			.then(() => {
+				rerender();
+				expect(scratch.innerHTML).to.equal('<div>Suspended...</div>');
+
+				return resolveChild(() => <div>All done!</div>);
+			})
+			.then(() => {
+				rerender();
+				expect(scratch.innerHTML).to.equal('<div>All done!</div>');
+			});
+	});
+
+	it('should correctly render nested Suspense components', () => {
+		// Inspired by the nested-suspense demo from #1865
+		// TODO: Explore writing a test that varies the loading orders
+
+		const [Lazy1, resolve1] = createLazy();
+		const [Lazy2, resolve2] = createLazy();
+		const [Lazy3, resolve3] = createLazy();
+
+		const Loading = () => <div>Suspended...</div>;
+		const loadingHtml = `<div>Suspended...</div>`;
+
+		render(
+			<Suspense fallback={<Loading />}>
+				<Lazy1 />
+				<div>
+					<Suspense fallback={<Loading />}>
+						<Lazy2 />
+					</Suspense>
+					<Lazy3 />
+				</div>
+				<b>4</b>
+			</Suspense>,
+			scratch
+		);
+		rerender(); // Rerender with the fallback HTML
+
+		expect(scratch.innerHTML).to.equal(loadingHtml);
+
+		return resolve1(() => <b>1</b>)
+			.then(() => {
+				rerender();
+				expect(scratch.innerHTML).to.equal(loadingHtml);
+
+				return resolve3(() => <b>3</b>);
+			})
+			.then(() => {
+				rerender();
+				expect(scratch.innerHTML).to.equal(
+					`<b>1</b><div>${loadingHtml}<b>3</b></div><b>4</b>`
+				);
+
+				return resolve2(() => <b>2</b>);
+			})
+			.then(() => {
+				rerender();
+				expect(scratch.innerHTML).to.equal(
+					`<b>1</b><div><b>2</b><b>3</b></div><b>4</b>`
+				);
+			});
+	});
+
+	it('should correctly render Suspense components inside Fragments', () => {
+		// Issue #2106.
+
+		const [Lazy1, resolve1] = createLazy();
+		const [Lazy2, resolve2] = createLazy();
+		const [Lazy3, resolve3] = createLazy();
+
+		const Loading = () => <div>Suspended...</div>;
+		const loadingHtml = `<div>Suspended...</div>`;
+
+		render(
+			<Fragment>
+				<Suspense fallback={<Loading />}>
+					<Lazy1 />
+				</Suspense>
+				<Fragment>
+					<Suspense fallback={<Loading />}>
+						<Lazy2 />
+					</Suspense>
+				</Fragment>
+				<Suspense fallback={<Loading />}>
+					<Lazy3 />
+				</Suspense>
+			</Fragment>,
+			scratch
+		);
+
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			`${loadingHtml}${loadingHtml}${loadingHtml}`
+		);
+
+		return resolve2(() => <span>2</span>)
+			.then(() => {
+				return resolve1(() => <span>1</span>);
+			})
+			.then(() => {
+				rerender();
+				expect(scratch.innerHTML).to.eql(
+					`<span>1</span><span>2</span>${loadingHtml}`
+				);
+				return resolve3(() => <span>3</span>);
+			})
+			.then(() => {
+				rerender();
+				expect(scratch.innerHTML).to.eql(
+					`<span>1</span><span>2</span><span>3</span>`
+				);
+			});
+	});
+
+	it('should not render any of the children if one child suspends', () => {
+		const [Lazy, resolve] = createLazy();
+
+		const Loading = () => <div>Suspended...</div>;
+		const loadingHtml = `<div>Suspended...</div>`;
+
+		render(
+			<Suspense fallback={<Loading />}>
+				<Lazy />
+				<div>World</div>
+			</Suspense>,
+			scratch
+		);
+		rerender();
+		expect(scratch.innerHTML).to.eql(loadingHtml);
+
+		return resolve(() => <div>Hello</div>).then(() => {
+			rerender();
+			expect(scratch.innerHTML).to.equal(`<div>Hello</div><div>World</div>`);
+		});
+	});
+
+	it('should render correctly when multiple children suspend with the same promise', () => {
+		/** @type {() => Promise<void>} */
+		let resolve;
+		let resolved = false;
+		const promise = new Promise(_resolve => {
+			resolve = () => {
+				resolved = true;
+				_resolve();
+				return promise;
+			};
+		});
+
+		const Child = props => {
+			if (!resolved) {
+				throw promise;
+			}
+			return props.children;
+		};
+
+		const Loading = () => <div>Suspended...</div>;
+		const loadingHtml = `<div>Suspended...</div>`;
+
+		render(
+			<Suspense fallback={<Loading />}>
+				<Child>
+					<div>A</div>
+				</Child>
+				<Child>
+					<div>B</div>
+				</Child>
+			</Suspense>,
+			scratch
+		);
+		rerender();
+		expect(scratch.innerHTML).to.eql(loadingHtml);
+
+		return resolve().then(() => {
+			resolved = true;
+			rerender();
+			expect(scratch.innerHTML).to.equal(`<div>A</div><div>B</div>`);
+		});
+	});
+
+	it('should un-suspend when suspender unmounts', () => {
+		const [Suspender, suspend] = createSuspender(() => <div>Suspender</div>);
+
+		let hide;
+
+		class Conditional extends Component {
+			constructor(props) {
+				super(props);
+				this.state = { show: true };
+
+				hide = () => {
+					this.setState({ show: false });
+				};
+			}
+
+			render(props, { show }) {
+				return (
+					<div>
+						conditional {show ? 'show' : 'hide'}
+						{show && <Suspender />}
+					</div>
+				);
+			}
+		}
+
+		render(
+			<Suspense fallback={<div>Suspended...</div>}>
+				<Conditional />
+			</Suspense>,
+			scratch
+		);
+
+		expect(scratch.innerHTML).to.eql(
+			`<div>conditional show<div>Suspender</div></div>`
+		);
+		expect(Suspender.prototype.render).to.have.been.calledOnce;
+
+		suspend();
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(`<div>Suspended...</div>`);
+
+		hide();
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(`<div>conditional hide</div>`);
+	});
+
+	it('should allow suspended multiple times', async () => {
+		const [Suspender1, suspend1] = createSuspender(() => (
+			<div>Suspender 1</div>
+		));
+		const [Suspender2, suspend2] = createSuspender(() => (
+			<div>Suspender 2</div>
+		));
+
+		let hide, resolve;
+
+		class Conditional extends Component {
+			constructor(props) {
+				super(props);
+				this.state = { show: true };
+
+				hide = () => {
+					this.setState({ show: false });
+				};
+			}
+
+			render(props, { show }) {
+				return (
+					<div>
+						conditional {show ? 'show' : 'hide'}
+						{show && (
+							<Suspense fallback="Suspended">
+								<Suspender1 />
+								<Suspender2 />
+							</Suspense>
+						)}
+					</div>
+				);
+			}
+		}
+
+		render(<Conditional />, scratch);
+		expect(scratch.innerHTML).to.eql(
+			'<div>conditional show<div>Suspender 1</div><div>Suspender 2</div></div>'
+		);
+
+		resolve = suspend1()[0];
+		rerender();
+		expect(scratch.innerHTML).to.eql('<div>conditional showSuspended</div>');
+
+		await resolve(() => <div>Done 1</div>);
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			'<div>conditional show<div>Done 1</div><div>Suspender 2</div></div>'
+		);
+
+		resolve = suspend2()[0];
+		rerender();
+		expect(scratch.innerHTML).to.eql('<div>conditional showSuspended</div>');
+
+		await resolve(() => <div>Done 2</div>);
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			'<div>conditional show<div>Done 1</div><div>Done 2</div></div>'
+		);
+
+		hide();
+		rerender();
+		expect(scratch.innerHTML).to.eql('<div>conditional hide</div>');
+	});
+
+	it('should allow same component to be suspended multiple times', async () => {
+		const cache = { '1': true };
+		function Lazy({ value }) {
+			if (!cache[value]) {
+				throw new Promise(resolve => {
+					cache[value] = resolve;
+				});
+			}
+			return <div>{`Lazy ${value}`}</div>;
+		}
+
+		let hide, setValue;
+
+		class Conditional extends Component {
+			constructor(props) {
+				super(props);
+				this.state = { show: true, value: '1' };
+
+				hide = () => {
+					this.setState({ show: false });
+				};
+				setValue = value => {
+					this.setState({ value });
+				};
+			}
+
+			render(props, { show, value }) {
+				return (
+					<div>
+						conditional {show ? 'show' : 'hide'}
+						{show && (
+							<Suspense fallback="Suspended">
+								<Lazy value={value} />
+							</Suspense>
+						)}
+					</div>
+				);
+			}
+		}
+
+		render(<Conditional />, scratch);
+		expect(scratch.innerHTML).to.eql(
+			'<div>conditional show<div>Lazy 1</div></div>'
+		);
+
+		setValue('2');
+		rerender();
+
+		expect(scratch.innerHTML).to.eql('<div>conditional showSuspended</div>');
+
+		await cache[2]();
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(
+			'<div>conditional show<div>Lazy 2</div></div>'
+		);
+
+		setValue('3');
+		rerender();
+
+		expect(scratch.innerHTML).to.eql('<div>conditional showSuspended</div>');
+
+		await cache[3]();
+		rerender();
+		expect(scratch.innerHTML).to.eql(
+			'<div>conditional show<div>Lazy 3</div></div>'
+		);
+
+		hide();
+		rerender();
+		expect(scratch.innerHTML).to.eql('<div>conditional hide</div>');
+	});
+
+	it('should allow resolve suspense promise after unmounts', async () => {
+		const [Suspender, suspend] = createSuspender(() => <div>Suspender</div>);
+
+		let hide, resolve;
+
+		class Conditional extends Component {
+			constructor(props) {
+				super(props);
+				this.state = { show: true };
+
+				hide = () => {
+					this.setState({ show: false });
+				};
+			}
+
+			render(props, { show }) {
+				return (
+					<div>
+						conditional {show ? 'show' : 'hide'}
+						{show && (
+							<Suspense fallback="Suspended">
+								<Suspender />
+							</Suspense>
+						)}
+					</div>
+				);
+			}
+		}
+
+		render(<Conditional />, scratch);
+		expect(scratch.innerHTML).to.eql(
+			'<div>conditional show<div>Suspender</div></div>'
+		);
+
+		resolve = suspend()[0];
+		rerender();
+		expect(scratch.innerHTML).to.eql('<div>conditional showSuspended</div>');
+
+		hide();
+		rerender();
+		expect(scratch.innerHTML).to.eql('<div>conditional hide</div>');
+
+		await resolve(() => <div>Done</div>);
+		rerender();
+		expect(scratch.innerHTML).to.eql('<div>conditional hide</div>');
+	});
+
+	it('should call componentWillUnmount on a suspended component', () => {
+		const cWUSpy = sinon.spy();
+
+		// eslint-disable-next-line react/require-render-return
+		class Suspender extends Component {
+			render() {
+				throw new Promise(() => {});
+			}
+		}
+
+		Suspender.prototype.componentWillUnmount = cWUSpy;
+
+		let hide;
+
+		let suspender = null;
+		let suspenderRef = s => {
+			// skip null values as we want to keep the ref even after unmount
+			if (s) {
+				suspender = s;
+			}
+		};
+
+		class Conditional extends Component {
+			constructor(props) {
+				super(props);
+				this.state = { show: true };
+
+				hide = () => {
+					this.setState({ show: false });
+				};
+			}
+
+			render(props, { show }) {
+				return (
+					<div>
+						conditional {show ? 'show' : 'hide'}
+						{show && <Suspender ref={suspenderRef} />}
+					</div>
+				);
+			}
+		}
+
+		render(
+			<Suspense fallback={<div>Suspended...</div>}>
+				<Conditional />
+			</Suspense>,
+			scratch
+		);
+
+		expect(scratch.innerHTML).to.eql(`<div>conditional show</div>`);
+		expect(cWUSpy).to.not.have.been.called;
+
+		hide();
+		rerender();
+
+		expect(cWUSpy).to.have.been.calledOnce;
+		expect(suspender).not.to.be.undefined;
+		expect(suspender).not.to.be.null;
+		expect(cWUSpy.getCall(0).thisValue).to.eql(suspender);
+		expect(scratch.innerHTML).to.eql(`<div>conditional hide</div>`);
+	});
+
+	xit('should support sCU=false when un-suspending', () => {
+		// See #2176 #2125
+		const [Suspender, suspend] = createSuspender(() => <div>Hello</div>);
+
+		render(
+			<Suspense fallback={<div>Suspended...</div>}>
+				Text
+				{/* Adding a <div> here will make things work... */}
+				<Suspender />
+			</Suspense>,
+			scratch
+		);
+
+		expect(scratch.innerHTML).to.eql(`Text<div>Hello</div>`);
+
+		const [resolve] = suspend();
+		rerender();
+
+		expect(scratch.innerHTML).to.eql(`<div>Suspended...</div>`);
+
+		Suspender.prototype.shouldComponentUpdate = () => false;
+
+		return resolve(() => <div>Hello 2</div>).then(() => {
+			rerender();
+			expect(scratch.innerHTML).to.eql(`Text<div>Hello 2</div>`);
+		});
+	});
+
+	xit('should allow suspended children to update', () => {
+		const log = [];
+		class Logger extends Component {
+			constructor(props) {
+				super(props);
+				log.push('construct');
+			}
+
+			render({ children }) {
+				log.push('render');
+				return children;
+			}
+		}
+
+		let suspender;
+		class Suspender extends Component {
+			constructor(props) {
+				super(props);
+				this.state = { promise: new Promise(() => {}) };
+				suspender = this;
+			}
+
+			unsuspend() {
+				this.setState({ promise: null });
+			}
+
+			render() {
+				if (this.state.promise) {
+					throw this.state.promise;
+				}
+
+				return 'hello';
+			}
+		}
+
+		render(
+			<section>
+				<Suspense fallback={<div>fallback</div>}>
+					<Suspender />
+					<Logger />
+				</Suspense>
+			</section>,
+			scratch
+		);
+
+		expect(log).to.eql(['construct', 'render']);
+		expect(scratch.innerHTML).to.eql('<section></section>');
+
+		// this rerender is needed because of Suspense issuing a forceUpdate itself
+		rerender();
+		expect(scratch.innerHTML).to.eql('<section><div>fallback</div></section>');
+
+		suspender.unsuspend();
+
+		rerender();
+
+		/**
+		 * These currently failing assertion shows the issue that we currently unmount
+		 * the suspended tree (unlike react, which adds a display="none") and block any
+		 * further processing on that tree. Thus updates below a suspended Suspense are
+		 * getting lost.
+		 */
+		expect(log).to.eql(['construct', 'render', 'render']);
+
+		/**
+		 * When the above assertion will hold true we will certainly run into the second issue
+		 * here. The problem is that we do not remove suspensions from an instance of Suspense
+		 * when one of its suspending children no longer throws because of a state
+		 * update.
+		 */
+		expect(scratch.innerHTML).to.eql(
+			'<section><div>Suspender un-suspended</div></section>'
+		);
+	});
+
+	it('should render delayed lazy components through components using shouldComponentUpdate', () => {
+		const [Suspender1, suspend1] = createSuspender(() => <i>1</i>);
+		const [Suspender2, suspend2] = createSuspender(() => <i>2</i>);
+
+		class Blocker extends Component {
+			shouldComponentUpdate() {
+				return false;
+			}
+			render(props) {
+				return (
+					<b>
+						<i>a</i>
+						{props.children}
+						<i>d</i>
+					</b>
+				);
+			}
+		}
+
+		render(
+			<Suspense fallback={<div>Suspended...</div>}>
+				<Blocker>
+					<Suspender1 />
+					<Suspender2 />
+				</Blocker>
+			</Suspense>,
+			scratch
+		);
+		expect(scratch.innerHTML).to.equal(
+			'<b><i>a</i><i>1</i><i>2</i><i>d</i></b>'
+		);
+
+		const [resolve1] = suspend1();
+		const [resolve2] = suspend2();
+		rerender();
+		expect(scratch.innerHTML).to.equal('<div>Suspended...</div>');
+
+		return resolve1(() => <i>b</i>)
+			.then(() => {
+				rerender();
+				expect(scratch.innerHTML).to.equal('<div>Suspended...</div>');
+
+				return resolve2(() => <i>c</i>);
+			})
+			.then(() => {
+				rerender();
+				expect(scratch.innerHTML).to.equal(
+					'<b><i>a</i><i>b</i><i>c</i><i>d</i></b>'
+				);
+			});
+	});
+
+	it('should render initially lazy components through components using shouldComponentUpdate', () => {
+		const [Lazy1, resolve1] = createLazy();
+		const [Lazy2, resolve2] = createLazy();
+
+		class Blocker extends Component {
+			shouldComponentUpdate() {
+				return false;
+			}
+			render(props) {
+				return (
+					<b>
+						<i>a</i>
+						{props.children}
+						<i>d</i>
+					</b>
+				);
+			}
+		}
+
+		render(
+			<Suspense fallback={<div>Suspended...</div>}>
+				<Blocker>
+					<Lazy1 />
+					<Lazy2 />
+				</Blocker>
+			</Suspense>,
+			scratch
+		);
+		rerender();
+		expect(scratch.innerHTML).to.equal('<div>Suspended...</div>');
+
+		return resolve1(() => <i>b</i>)
+			.then(() => {
+				rerender();
+				expect(scratch.innerHTML).to.equal('<div>Suspended...</div>');
+
+				return resolve2(() => <i>c</i>);
+			})
+			.then(() => {
+				rerender();
+				expect(scratch.innerHTML).to.equal(
+					'<b><i>a</i><i>b</i><i>c</i><i>d</i></b>'
+				);
+			});
+	});
+
+	it('should render initially lazy components through createContext', () => {
+		const ctx = createContext(null);
+		const [Lazy, resolve] = createLazy();
+
+		const suspense = (
+			<Suspense fallback={<div>Suspended...</div>}>
+				<ctx.Provider value="123">
+					<ctx.Consumer>{value => <Lazy value={value} />}</ctx.Consumer>
+				</ctx.Provider>
+			</Suspense>
+		);
+
+		render(suspense, scratch);
+		rerender();
+		expect(scratch.innerHTML).to.equal(`<div>Suspended...</div>`);
+
+		return resolve(props => <div>{props.value}</div>).then(() => {
+			rerender();
+			expect(scratch.innerHTML).to.eql(`<div>123</div>`);
+		});
+	});
+
+	it('should render delayed lazy components through createContext', () => {
+		const ctx = createContext(null);
+		const [Suspender, suspend] = createSuspender(({ value }) => (
+			<span>{value}</span>
+		));
+
+		const suspense = (
+			<Suspense fallback={<div>Suspended...</div>}>
+				<ctx.Provider value="123">
+					<ctx.Consumer>{value => <Suspender value={value} />}</ctx.Consumer>
+				</ctx.Provider>
+			</Suspense>
+		);
+
+		render(suspense, scratch);
+		expect(scratch.innerHTML).to.equal('<span>123</span>');
+
+		const [resolve] = suspend();
+		rerender();
+		expect(scratch.innerHTML).to.equal(`<div>Suspended...</div>`);
+
+		return resolve(props => <div>{props.value}</div>).then(() => {
+			rerender();
+			expect(scratch.innerHTML).to.eql(`<div>123</div>`);
+		});
+	});
+});
diff --git a/node_modules/preact/compat/test/browser/svg.test.js b/node_modules/preact/compat/test/browser/svg.test.js
new file mode 100644
index 0000000..3b45859
--- /dev/null
+++ b/node_modules/preact/compat/test/browser/svg.test.js
@@ -0,0 +1,94 @@
+import React, { createElement } from 'preact/compat';
+import {
+	setupScratch,
+	teardown,
+	serializeHtml,
+	sortAttributes
+} from '../../../test/_util/helpers';
+
+describe('svg', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	it('should render SVG to string', () => {
+		let svg = (
+			<svg viewBox="0 0 360 360">
+				<path
+					stroke="white"
+					fill="black"
+					d="M347.1 357.9L183.3 256.5 13 357.9V1.7h334.1v356.2zM58.5 47.2v231.4l124.8-74.1 118.3 72.8V47.2H58.5z"
+				/>
+			</svg>
+		);
+		// string -> parse
+		expect(svg).to.eql(svg);
+	});
+
+	it('should render SVG to DOM #1', () => {
+		const Demo = () => (
+			<svg viewBox="0 0 360 360">
+				<path
+					stroke="white"
+					fill="black"
+					d="M347.1 357.9L183.3 256.5 L 13 357.9V1.7h334.1v356.2zM58.5 47.2v231.4l124.8-74.1 l 118.3 72.8V47.2H58.5z"
+				/>
+			</svg>
+		);
+		React.render(<Demo />, scratch);
+
+		expect(serializeHtml(scratch)).to.equal(
+			sortAttributes(
+				'<svg viewBox="0 0 360 360"><path stroke="white" fill="black" d="M 347.1 357.9 L 183.3 256.5 L 13 357.9 V 1.7 h 334.1 v 356.2 Z M 58.5 47.2 v 231.4 l 124.8 -74.1 l 118.3 72.8 V 47.2 H 58.5 Z"></path></svg>'
+			)
+		);
+	});
+
+	it('should render SVG to DOM #2', () => {
+		React.render(
+			<svg viewBox="0 0 100 100">
+				<text textAnchor="mid">foo</text>
+				<path vectorEffect="non-scaling-stroke" d="M0 0 L100 100" />
+			</svg>,
+			scratch
+		);
+
+		expect(serializeHtml(scratch)).to.equal(
+			sortAttributes(
+				'<svg viewBox="0 0 100 100"><text text-anchor="mid">foo</text><path vector-effect="non-scaling-stroke" d="M 0 0 L 100 100"></path></svg>'
+			)
+		);
+	});
+
+	it('should render correct SVG attribute names to the DOM', () => {
+		React.render(
+			<svg
+				clipPath="value"
+				clipRule="value"
+				clipPathUnits="value"
+				glyphOrientationHorizontal="value"
+				glyphRef="value"
+				markerStart="value"
+				markerHeight="value"
+				markerUnits="value"
+				markerWidth="value"
+				x1="value"
+				xChannelSelector="value"
+			/>,
+			scratch
+		);
+
+		expect(serializeHtml(scratch)).to.eql(
+			sortAttributes(
+				'<svg clip-path="value" clip-rule="value" clipPathUnits="value" glyph-orientationhorizontal="value" glyphRef="value" marker-start="value" markerHeight="value" markerUnits="value" markerWidth="value" x1="value" xChannelSelector="value"></svg>'
+			)
+		);
+	});
+});
diff --git a/node_modules/preact/compat/test/browser/testUtils.js b/node_modules/preact/compat/test/browser/testUtils.js
new file mode 100644
index 0000000..04ed784
--- /dev/null
+++ b/node_modules/preact/compat/test/browser/testUtils.js
@@ -0,0 +1,24 @@
+/**
+ * Retrieve a Symbol if supported or use the fallback value
+ * @param {string} name The name of the Symbol to look up
+ * @param {number} fallback Fallback value if Symbols are not supported
+ */
+export function getSymbol(name, fallback) {
+	let out = fallback;
+
+	try {
+		// eslint-disable-next-line
+		if (
+			Function.prototype.toString
+				.call(eval('Symbol.for'))
+				.match(/\[native code\]/)
+		) {
+			// Concatenate these string literals to prevent the test
+			// harness and/or Babel from modifying the symbol value.
+			// eslint-disable-next-line
+			out = eval('Sym' + 'bol.for("' + name + '")');
+		}
+	} catch (e) {}
+
+	return out;
+}
diff --git a/node_modules/preact/compat/test/browser/textarea.test.js b/node_modules/preact/compat/test/browser/textarea.test.js
new file mode 100644
index 0000000..93c6ba9
--- /dev/null
+++ b/node_modules/preact/compat/test/browser/textarea.test.js
@@ -0,0 +1,55 @@
+import React, { render, useState } from 'preact/compat';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+import { act } from 'preact/test-utils';
+
+describe('Textarea', () => {
+	let scratch;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	it('should alias value to children', () => {
+		render(<textarea value="foo" />, scratch);
+
+		expect(scratch.firstElementChild.value).to.equal('foo');
+	});
+
+	it('should alias defaultValue to children', () => {
+		render(<textarea defaultValue="foo" />, scratch);
+
+		expect(scratch.firstElementChild.value).to.equal('foo');
+	});
+
+	it('should support resetting the value', () => {
+		let set;
+		const App = () => {
+			const [state, setState] = useState('');
+			set = setState;
+			return <textarea value={state} />;
+		};
+
+		render(<App />, scratch);
+		expect(scratch.innerHTML).to.equal('<textarea></textarea>');
+
+		act(() => {
+			set('hello');
+		});
+		// Note: This looks counterintuitive, but it's working correctly - the value
+		// missing from HTML because innerHTML doesn't serialize form field values.
+		// See demo: https://jsfiddle.net/4had2Lu8
+		// Related renderToString PR: preactjs/preact-render-to-string#161
+		expect(scratch.innerHTML).to.equal('<textarea></textarea>');
+		expect(scratch.firstElementChild.value).to.equal('hello');
+
+		act(() => {
+			set('');
+		});
+		expect(scratch.innerHTML).to.equal('<textarea></textarea>');
+		expect(scratch.firstElementChild.value).to.equal('');
+	});
+});
diff --git a/node_modules/preact/compat/test/browser/unmountComponentAtNode.test.js b/node_modules/preact/compat/test/browser/unmountComponentAtNode.test.js
new file mode 100644
index 0000000..bcf87df
--- /dev/null
+++ b/node_modules/preact/compat/test/browser/unmountComponentAtNode.test.js
@@ -0,0 +1,28 @@
+import React, { createElement, unmountComponentAtNode } from 'preact/compat';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+
+describe('unmountComponentAtNode', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	it('should unmount a root node', () => {
+		const App = () => <div>foo</div>;
+		React.render(<App />, scratch);
+
+		expect(unmountComponentAtNode(scratch)).to.equal(true);
+		expect(scratch.innerHTML).to.equal('');
+	});
+
+	it('should do nothing if root is not mounted', () => {
+		expect(unmountComponentAtNode(scratch)).to.equal(false);
+		expect(scratch.innerHTML).to.equal('');
+	});
+});
diff --git a/node_modules/preact/compat/test/browser/unstable_batchedUpdates.test.js b/node_modules/preact/compat/test/browser/unstable_batchedUpdates.test.js
new file mode 100644
index 0000000..61b2e8a
--- /dev/null
+++ b/node_modules/preact/compat/test/browser/unstable_batchedUpdates.test.js
@@ -0,0 +1,15 @@
+import { unstable_batchedUpdates } from 'preact/compat';
+
+describe('unstable_batchedUpdates', () => {
+	it('should call the callback', () => {
+		const spy = sinon.spy();
+		unstable_batchedUpdates(spy);
+		expect(spy).to.be.calledOnce;
+	});
+
+	it('should call callback with only one arg', () => {
+		const spy = sinon.spy();
+		unstable_batchedUpdates(spy, 'foo', 'bar');
+		expect(spy).to.be.calledWithExactly('foo');
+	});
+});
diff --git a/node_modules/preact/compat/test/ts/forward-ref.tsx b/node_modules/preact/compat/test/ts/forward-ref.tsx
new file mode 100644
index 0000000..e515921
--- /dev/null
+++ b/node_modules/preact/compat/test/ts/forward-ref.tsx
@@ -0,0 +1,21 @@
+import React from '../../src';
+
+const MyInput: React.ForwardFn<{ id: string }, { focus(): void }> = (props, ref) => {
+  const inputRef = React.useRef<HTMLInputElement>()
+
+  React.useImperativeHandle(ref, () => ({
+    focus: () => {
+      if (inputRef.current) {
+        inputRef.current.focus()
+      }
+    }
+  }))
+
+  return <input {...props} ref={inputRef} />
+}
+
+export const foo = React.forwardRef(MyInput)
+
+export const Bar = React.forwardRef<HTMLDivElement, { children: any }>((props, ref) => {
+	return <div ref={ref}>{props.children}</div>
+})
diff --git a/node_modules/preact/compat/test/ts/lazy.tsx b/node_modules/preact/compat/test/ts/lazy.tsx
new file mode 100644
index 0000000..2561105
--- /dev/null
+++ b/node_modules/preact/compat/test/ts/lazy.tsx
@@ -0,0 +1,20 @@
+import * as React from "../../src";
+
+export interface LazyProps {
+	isProp: boolean;
+}
+
+interface LazyState {
+	forState: string;
+}
+export default class IsLazyComponent extends React.Component<LazyProps, LazyState> {
+	render ({ isProp }: LazyProps) {
+		return (
+			<div>{
+				isProp ?
+				'Super Lazy TRUE' :
+				'Super Lazy FALSE'
+			}</div>
+		)
+	}
+}
diff --git a/node_modules/preact/compat/test/ts/memo.tsx b/node_modules/preact/compat/test/ts/memo.tsx
new file mode 100644
index 0000000..a6bbbb8
--- /dev/null
+++ b/node_modules/preact/compat/test/ts/memo.tsx
@@ -0,0 +1,40 @@
+import * as React from '../../src';
+
+function ExpectType<T>(v: T) {} // type assertion helper
+
+interface MemoProps {
+	required: string;
+	optional?: string;
+	defaulted: string;
+}
+
+const ReadonlyBaseComponent = (props: Readonly<MemoProps>) => (
+	<div>{props.required + props.optional + props.defaulted}</div>
+);
+ReadonlyBaseComponent.defaultProps = { defaulted: '' };
+
+const BaseComponent = (props: MemoProps) => (
+	<div>{props.required + props.optional + props.defaulted}</div>
+);
+BaseComponent.defaultProps = { defaulted: '' };
+
+// memo for readonly component with default comparison
+const MemoedReadonlyComponent = React.memo(ReadonlyBaseComponent);
+ExpectType<React.FunctionComponent<MemoProps>>(MemoedReadonlyComponent);
+export const memoedReadonlyComponent = (
+	<MemoedReadonlyComponent required="hi" />
+);
+
+// memo for non-readonly component with default comparison
+const MemoedComponent = React.memo(BaseComponent);
+ExpectType<React.FunctionComponent<MemoProps>>(MemoedComponent);
+export const memoedComponent = <MemoedComponent required="hi" />;
+
+// memo with custom comparison
+const CustomMemoedComponent = React.memo(BaseComponent, (a, b) => {
+	ExpectType<MemoProps>(a);
+	ExpectType<MemoProps>(b);
+	return a.required === b.required;
+});
+ExpectType<React.FunctionComponent<MemoProps>>(CustomMemoedComponent);
+export const customMemoedComponent = <CustomMemoedComponent required="hi" />;
diff --git a/node_modules/preact/compat/test/ts/react-default.tsx b/node_modules/preact/compat/test/ts/react-default.tsx
new file mode 100644
index 0000000..3570a08
--- /dev/null
+++ b/node_modules/preact/compat/test/ts/react-default.tsx
@@ -0,0 +1,6 @@
+import React from '../../src';
+class ReactIsh extends React.Component {
+	render() {
+		return <div>Text</div>
+	}
+}
diff --git a/node_modules/preact/compat/test/ts/react-star.tsx b/node_modules/preact/compat/test/ts/react-star.tsx
new file mode 100644
index 0000000..d686b95
--- /dev/null
+++ b/node_modules/preact/compat/test/ts/react-star.tsx
@@ -0,0 +1,7 @@
+// import React from '../../src';
+import * as React from '../../src';
+class ReactIsh extends React.Component {
+	render() {
+		return <div>Text</div>
+	}
+}
diff --git a/node_modules/preact/compat/test/ts/suspense.tsx b/node_modules/preact/compat/test/ts/suspense.tsx
new file mode 100644
index 0000000..0559c99
--- /dev/null
+++ b/node_modules/preact/compat/test/ts/suspense.tsx
@@ -0,0 +1,49 @@
+import * as React from "../../src";
+
+interface LazyProps {
+	isProp: boolean;
+}
+
+const IsLazyFunctional = (props: LazyProps) =>
+	<div>{
+		props.isProp ?
+		'Super Lazy TRUE' :
+		'Super Lazy FALSE'
+	}</div>
+
+const FallBack = () => <div>Still working...</div>;
+/**
+ * Have to mock dynamic import as import() throws a syntax error in the test runner
+ */
+const componentPromise = new Promise<{default: typeof IsLazyFunctional}>(resolve=>{
+	setTimeout(()=>{
+		resolve({ default: IsLazyFunctional});
+	},800);
+});
+
+/**
+ * For usage with import:
+ * const IsLazyComp = lazy(() => import('./lazy'));
+*/
+const IsLazyFunc = React.lazy(() => componentPromise);
+
+// Suspense using lazy component
+class SuspensefulFunc extends React.Component {
+	render() {
+		return <React.Suspense fallback={<FallBack/>}><IsLazyFunc isProp={false} /></React.Suspense>
+	}
+}
+
+//SuspenseList using lazy components
+function SuspenseListTester(props: any) {
+  return (
+    <React.SuspenseList revealOrder="together">
+      <React.Suspense fallback={<FallBack />}>
+        <IsLazyFunc isProp={false} />
+      </React.Suspense>
+      <React.Suspense fallback={<FallBack />}>
+        <IsLazyFunc isProp={false} />
+      </React.Suspense>
+    </React.SuspenseList>
+  )
+}
diff --git a/node_modules/preact/compat/test/ts/tsconfig.json b/node_modules/preact/compat/test/ts/tsconfig.json
new file mode 100644
index 0000000..742a039
--- /dev/null
+++ b/node_modules/preact/compat/test/ts/tsconfig.json
@@ -0,0 +1,20 @@
+{
+	"compilerOptions": {
+		"target": "es6",
+		"module": "es6",
+		"moduleResolution": "node",
+		"lib": [
+			"es6",
+			"dom",
+		],
+		"strict": true,
+		"forceConsistentCasingInFileNames": true,
+		"jsx": "react",
+		"noEmit": true,
+		"allowSyntheticDefaultImports": true
+	},
+	"include": [
+		"./**/*.ts",
+		"./**/*.tsx"
+	]
+}
diff --git a/node_modules/preact/debug/mangle.json b/node_modules/preact/debug/mangle.json
new file mode 100644
index 0000000..506a6a4
--- /dev/null
+++ b/node_modules/preact/debug/mangle.json
@@ -0,0 +1,21 @@
+{
+  "help": {
+    "what is this file?": "It controls protected/private property mangling so that minified builds have consistent property names.",
+    "why are there duplicate minified properties?": "Most properties are only used on one type of objects, so they can have the same name since they will never collide. Doing this reduces size."
+  },
+  "minify": {
+    "mangle": {
+      "properties": {
+        "regex": "^_[^_]",
+        "reserved": [
+          "__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED",
+          "__REACT_DEVTOOLS_GLOBAL_HOOK__",
+          "__PREACT_DEVTOOLS__",
+          "_renderers",
+          "__source",
+          "__self"
+        ]
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/node_modules/preact/debug/test/browser/component-stack-2.test.js b/node_modules/preact/debug/test/browser/component-stack-2.test.js
new file mode 100644
index 0000000..a9a75af
--- /dev/null
+++ b/node_modules/preact/debug/test/browser/component-stack-2.test.js
@@ -0,0 +1,54 @@
+import { createElement, render, Component } from 'preact';
+import 'preact/debug';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+
+/** @jsx createElement */
+
+// This test is not part of component-stack.test.js to avoid it being
+// transpiled with '@babel/plugin-transform-react-jsx-source' enabled.
+
+describe('component stack', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	let errors = [];
+	let warnings = [];
+
+	beforeEach(() => {
+		scratch = setupScratch();
+
+		errors = [];
+		warnings = [];
+		sinon.stub(console, 'error').callsFake(e => errors.push(e));
+		sinon.stub(console, 'warn').callsFake(w => warnings.push(w));
+	});
+
+	afterEach(() => {
+		console.error.restore();
+		console.warn.restore();
+		teardown(scratch);
+	});
+
+	it('should print a warning when "@babel/plugin-transform-react-jsx-source" is not installed', () => {
+		function Foo() {
+			return <Thrower />;
+		}
+
+		class Thrower extends Component {
+			constructor(props) {
+				super(props);
+				this.setState({ foo: 1 });
+			}
+
+			render() {
+				return <div>foo</div>;
+			}
+		}
+
+		render(<Foo />, scratch);
+
+		expect(
+			warnings[0].indexOf('@babel/plugin-transform-react-jsx-source') > -1
+		).to.equal(true);
+	});
+});
diff --git a/node_modules/preact/debug/test/browser/component-stack.test.js b/node_modules/preact/debug/test/browser/component-stack.test.js
new file mode 100644
index 0000000..87cd085
--- /dev/null
+++ b/node_modules/preact/debug/test/browser/component-stack.test.js
@@ -0,0 +1,86 @@
+import { createElement, render, Component } from 'preact';
+import 'preact/debug';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+
+/** @jsx createElement */
+
+describe('component stack', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	let errors = [];
+	let warnings = [];
+
+	const getStack = arr => arr[0].split('\n\n')[1];
+
+	beforeEach(() => {
+		scratch = setupScratch();
+
+		errors = [];
+		warnings = [];
+		sinon.stub(console, 'error').callsFake(e => errors.push(e));
+		sinon.stub(console, 'warn').callsFake(w => warnings.push(w));
+	});
+
+	afterEach(() => {
+		console.error.restore();
+		console.warn.restore();
+		teardown(scratch);
+	});
+
+	it('should print component stack', () => {
+		function Foo() {
+			return <Thrower />;
+		}
+
+		class Thrower extends Component {
+			constructor(props) {
+				super(props);
+				this.setState({ foo: 1 });
+			}
+
+			render() {
+				return <div>foo</div>;
+			}
+		}
+
+		render(<Foo />, scratch);
+
+		let lines = getStack(warnings).split('\n');
+		expect(lines[0].indexOf('Thrower') > -1).to.equal(true);
+		expect(lines[1].indexOf('Foo') > -1).to.equal(true);
+	});
+
+	it('should only print owners', () => {
+		function Foo(props) {
+			return <div>{props.children}</div>;
+		}
+
+		function Bar() {
+			return (
+				<Foo>
+					<Thrower />
+				</Foo>
+			);
+		}
+
+		class Thrower extends Component {
+			render() {
+				return (
+					<table>
+						<td>
+							<tr>foo</tr>
+						</td>
+					</table>
+				);
+			}
+		}
+
+		render(<Bar />, scratch);
+
+		let lines = getStack(errors).split('\n');
+		expect(lines[0].indexOf('td') > -1).to.equal(true);
+		expect(lines[1].indexOf('Thrower') > -1).to.equal(true);
+		expect(lines[2].indexOf('Bar') > -1).to.equal(true);
+	});
+});
diff --git a/node_modules/preact/debug/test/browser/debug-compat.test.js b/node_modules/preact/debug/test/browser/debug-compat.test.js
new file mode 100644
index 0000000..623cc2f
--- /dev/null
+++ b/node_modules/preact/debug/test/browser/debug-compat.test.js
@@ -0,0 +1,66 @@
+import { createElement, render, createRef } from 'preact';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+import './fakeDevTools';
+import 'preact/debug';
+import * as PropTypes from 'prop-types';
+
+// eslint-disable-next-line no-duplicate-imports
+import { resetPropWarnings } from 'preact/debug';
+import { forwardRef } from 'preact/compat';
+
+const h = createElement;
+/** @jsx createElement */
+
+describe('debug compat', () => {
+	let scratch;
+	let errors = [];
+	let warnings = [];
+
+	beforeEach(() => {
+		errors = [];
+		warnings = [];
+		scratch = setupScratch();
+		sinon.stub(console, 'error').callsFake(e => errors.push(e));
+		sinon.stub(console, 'warn').callsFake(w => warnings.push(w));
+	});
+
+	afterEach(() => {
+		/** @type {*} */
+		(console.error).restore();
+		console.warn.restore();
+		teardown(scratch);
+	});
+
+	describe('PropTypes', () => {
+		beforeEach(() => {
+			resetPropWarnings();
+		});
+
+		it('should not fail if ref is passed to comp wrapped in forwardRef', () => {
+			// This test ensures compat with airbnb/prop-types-exact, mui exact prop types util, etc.
+
+			const Foo = forwardRef(function Foo(props, ref) {
+				return <h1 ref={ref}>{props.text}</h1>;
+			});
+
+			Foo.propTypes = {
+				text: PropTypes.string.isRequired,
+				ref(props) {
+					if ('ref' in props) {
+						throw new Error(
+							'ref should not be passed to prop-types valiation!'
+						);
+					}
+				}
+			};
+
+			const ref = createRef();
+
+			render(<Foo ref={ref} text="123" />, scratch);
+
+			expect(console.error).not.been.called;
+
+			expect(ref.current).to.not.be.undefined;
+		});
+	});
+});
diff --git a/node_modules/preact/debug/test/browser/debug-hooks.test.js b/node_modules/preact/debug/test/browser/debug-hooks.test.js
new file mode 100644
index 0000000..a566d15
--- /dev/null
+++ b/node_modules/preact/debug/test/browser/debug-hooks.test.js
@@ -0,0 +1,119 @@
+import { createElement, render, Component } from 'preact';
+import { useState, useEffect, useMemo, useCallback } from 'preact/hooks';
+import 'preact/debug';
+import { act } from 'preact/test-utils';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+
+/** @jsx createElement */
+
+describe('debug with hooks', () => {
+	let scratch;
+	let errors = [];
+	let warnings = [];
+
+	beforeEach(() => {
+		errors = [];
+		warnings = [];
+		scratch = setupScratch();
+		sinon.stub(console, 'error').callsFake(e => errors.push(e));
+		sinon.stub(console, 'warn').callsFake(w => warnings.push(w));
+	});
+
+	afterEach(() => {
+		console.error.restore();
+		console.warn.restore();
+		teardown(scratch);
+	});
+
+	// TODO: Fix this test. It only passed before because App was the first component
+	// into render so currentComponent in hooks/index.js wasn't set yet. However,
+	// any children under App wouldn't have thrown the error if they did what App
+	// did because currentComponent would be set to App.
+	// In other words, hooks never clear currentComponent so once it is set, it won't
+	// be unset
+	it.skip('should throw an error when using a hook outside a render', () => {
+		const Foo = props => props.children;
+		class App extends Component {
+			componentWillMount() {
+				useState();
+			}
+
+			render() {
+				return <p>test</p>;
+			}
+		}
+		const fn = () =>
+			act(() =>
+				render(
+					<Foo>
+						<App />
+					</Foo>,
+					scratch
+				)
+			);
+		expect(fn).to.throw(/Hook can only be invoked from render/);
+	});
+
+	it('should throw an error when invoked outside of a component', () => {
+		function foo() {
+			useEffect(() => {}); // Pretend to use a hook
+			return <p>test</p>;
+		}
+
+		const fn = () =>
+			act(() => {
+				render(foo(), scratch);
+			});
+		expect(fn).to.throw(/Hook can only be invoked from render/);
+	});
+
+	it('should throw an error when invoked outside of a component before render', () => {
+		function Foo(props) {
+			useEffect(() => {}); // Pretend to use a hook
+			return props.children;
+		}
+
+		const fn = () =>
+			act(() => {
+				useState();
+				render(<Foo>Hello!</Foo>, scratch);
+			});
+		expect(fn).to.throw(/Hook can only be invoked from render/);
+	});
+
+	it('should throw an error when invoked inside an effect callback', () => {
+		function Foo(props) {
+			useEffect(() => {
+				useState();
+			});
+			return props.children;
+		}
+
+		const fn = () =>
+			act(() => {
+				render(<Foo>Hello!</Foo>, scratch);
+			});
+		expect(fn).to.throw(/Hook can only be invoked from render/);
+	});
+
+	it('should warn for useMemo/useCallback without arguments', () => {
+		const App = () => {
+			const [people] = useState([40, 20, 60, 80]);
+			const retiredPeople = useMemo(() => people.filter(x => x >= 60));
+			const cb = useCallback(() => () => 'test');
+			return <p onClick={cb}>{retiredPeople.map(x => x)}</p>;
+		};
+		render(<App />, scratch);
+		// One more to show the need for @babel/plugin-transform-react-jsx-source
+		expect(warnings.length).to.equal(3);
+	});
+
+	it('should warn when useMemo is called with non-array args', () => {
+		const App = () => {
+			const foo = useMemo(() => 'foo', 12);
+			return <p>{foo}</p>;
+		};
+		render(<App />, scratch);
+		expect(warnings[0]).to.match(/without passing arguments/);
+	});
+});
diff --git a/node_modules/preact/debug/test/browser/debug-suspense.test.js b/node_modules/preact/debug/test/browser/debug-suspense.test.js
new file mode 100644
index 0000000..a436154
--- /dev/null
+++ b/node_modules/preact/debug/test/browser/debug-suspense.test.js
@@ -0,0 +1,190 @@
+import { createElement, render, lazy, Suspense } from 'preact/compat';
+import 'preact/debug';
+import { setupRerender } from 'preact/test-utils';
+import {
+	setupScratch,
+	teardown,
+	serializeHtml
+} from '../../../test/_util/helpers';
+
+/** @jsx createElement */
+
+describe('debug with suspense', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+	let rerender;
+	let errors = [];
+	let warnings = [];
+
+	beforeEach(() => {
+		errors = [];
+		warnings = [];
+		scratch = setupScratch();
+		rerender = setupRerender();
+		sinon.stub(console, 'error').callsFake(e => errors.push(e));
+		sinon.stub(console, 'warn').callsFake(w => warnings.push(w));
+	});
+
+	afterEach(() => {
+		console.error.restore();
+		console.warn.restore();
+		teardown(scratch);
+	});
+
+	it('should throw on missing <Suspense>', () => {
+		function Foo() {
+			throw Promise.resolve();
+		}
+
+		expect(() => render(<Foo />, scratch)).to.throw;
+	});
+
+	it('should throw an error when using lazy and missing Suspense', () => {
+		const Foo = () => <div>Foo</div>;
+		const LazyComp = lazy(
+			() => new Promise(resolve => resolve({ default: Foo }))
+		);
+		const fn = () => {
+			render(<LazyComp />, scratch);
+		};
+
+		expect(fn).to.throw(/Missing Suspense/gi);
+	});
+
+	describe('PropTypes', () => {
+		it('should validate propTypes inside lazy()', () => {
+			function Baz(props) {
+				return <h1>{props.unhappy}</h1>;
+			}
+
+			Baz.propTypes = {
+				unhappy: function alwaysThrows(obj, key) {
+					if (obj[key] === 'signal') throw Error('got prop inside lazy()');
+				}
+			};
+
+			const loader = Promise.resolve({ default: Baz });
+			const LazyBaz = lazy(() => loader);
+
+			const suspense = (
+				<Suspense fallback={<div>fallback...</div>}>
+					<LazyBaz unhappy="signal" />
+				</Suspense>
+			);
+			render(suspense, scratch);
+			rerender(); // render fallback
+
+			expect(console.error).to.not.be.called;
+			expect(serializeHtml(scratch)).to.equal('<div>fallback...</div>');
+
+			return loader.then(() => {
+				rerender();
+				expect(errors.length).to.equal(1);
+				expect(errors[0].includes('got prop')).to.equal(true);
+				expect(serializeHtml(scratch)).to.equal('<h1>signal</h1>');
+			});
+		});
+
+		describe('warn for PropTypes on lazy()', () => {
+			it('should log the function name', () => {
+				const loader = Promise.resolve({
+					default: function MyLazyLoaded() {
+						return <div>Hi there</div>;
+					}
+				});
+				const FakeLazy = lazy(() => loader);
+				FakeLazy.propTypes = {};
+				const suspense = (
+					<Suspense fallback={<div>fallback...</div>}>
+						<FakeLazy />
+					</Suspense>
+				);
+				render(suspense, scratch);
+				rerender(); // Render fallback
+
+				expect(serializeHtml(scratch)).to.equal('<div>fallback...</div>');
+
+				return loader.then(() => {
+					rerender();
+					expect(console.warn).to.be.calledTwice;
+					expect(warnings[1].includes('MyLazyLoaded')).to.equal(true);
+					expect(serializeHtml(scratch)).to.equal('<div>Hi there</div>');
+				});
+			});
+
+			it('should log the displayName', () => {
+				function MyLazyLoadedComponent() {
+					return <div>Hi there</div>;
+				}
+				MyLazyLoadedComponent.displayName = 'HelloLazy';
+				const loader = Promise.resolve({ default: MyLazyLoadedComponent });
+				const FakeLazy = lazy(() => loader);
+				FakeLazy.propTypes = {};
+				const suspense = (
+					<Suspense fallback={<div>fallback...</div>}>
+						<FakeLazy />
+					</Suspense>
+				);
+				render(suspense, scratch);
+				rerender(); // Render fallback
+
+				expect(serializeHtml(scratch)).to.equal('<div>fallback...</div>');
+
+				return loader.then(() => {
+					rerender();
+					expect(console.warn).to.be.calledTwice;
+					expect(warnings[1].includes('HelloLazy')).to.equal(true);
+					expect(serializeHtml(scratch)).to.equal('<div>Hi there</div>');
+				});
+			});
+
+			it("should not log a component if lazy loader's Promise rejects", () => {
+				const loader = Promise.reject(new Error('Hey there'));
+				const FakeLazy = lazy(() => loader);
+				FakeLazy.propTypes = {};
+				render(
+					<Suspense fallback={<div>fallback...</div>}>
+						<FakeLazy />
+					</Suspense>,
+					scratch
+				);
+				rerender(); // Render fallback
+
+				expect(serializeHtml(scratch)).to.equal('<div>fallback...</div>');
+
+				return loader.catch(() => {
+					try {
+						rerender();
+					} catch (e) {
+						// Ignore the loader's bubbling error
+					}
+
+					// Called once on initial render, and again when promise rejects
+					expect(console.warn).to.be.calledTwice;
+				});
+			});
+
+			it("should not log a component if lazy's loader throws", () => {
+				const FakeLazy = lazy(() => {
+					throw new Error('Hello');
+				});
+				FakeLazy.propTypes = {};
+				let error;
+				try {
+					render(
+						<Suspense fallback={<div>fallback...</div>}>
+							<FakeLazy />
+						</Suspense>,
+						scratch
+					);
+				} catch (e) {
+					error = e;
+				}
+
+				expect(console.warn).to.be.calledOnce;
+				expect(error).not.to.be.undefined;
+				expect(error.message).to.eql('Hello');
+			});
+		});
+	});
+});
diff --git a/node_modules/preact/debug/test/browser/debug.options.test.js b/node_modules/preact/debug/test/browser/debug.options.test.js
new file mode 100644
index 0000000..0695196
--- /dev/null
+++ b/node_modules/preact/debug/test/browser/debug.options.test.js
@@ -0,0 +1,126 @@
+import {
+	vnodeSpy,
+	rootSpy,
+	beforeDiffSpy,
+	hookSpy,
+	afterDiffSpy,
+	catchErrorSpy
+} from '../../../test/_util/optionSpies';
+
+import { createElement, render, Component } from 'preact';
+import { useState } from 'preact/hooks';
+import { setupRerender } from 'preact/test-utils';
+import 'preact/debug';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+
+/** @jsx createElement */
+
+describe('debug options', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	/** @type {() => void} */
+	let rerender;
+
+	/** @type {(count: number) => void} */
+	let setCount;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+		rerender = setupRerender();
+
+		vnodeSpy.resetHistory();
+		rootSpy.resetHistory();
+		beforeDiffSpy.resetHistory();
+		hookSpy.resetHistory();
+		afterDiffSpy.resetHistory();
+		catchErrorSpy.resetHistory();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	class ClassApp extends Component {
+		constructor() {
+			super();
+			this.state = { count: 0 };
+			setCount = count => this.setState({ count });
+		}
+
+		render() {
+			return <div>{this.state.count}</div>;
+		}
+	}
+
+	it('should call old options on mount', () => {
+		render(<ClassApp />, scratch);
+
+		expect(vnodeSpy).to.have.been.called;
+		expect(rootSpy).to.have.been.called;
+		expect(beforeDiffSpy).to.have.been.called;
+		expect(afterDiffSpy).to.have.been.called;
+	});
+
+	it('should call old options on update', () => {
+		render(<ClassApp />, scratch);
+
+		setCount(1);
+		rerender();
+
+		expect(vnodeSpy).to.have.been.called;
+		expect(rootSpy).to.have.been.called;
+		expect(beforeDiffSpy).to.have.been.called;
+		expect(afterDiffSpy).to.have.been.called;
+	});
+
+	it('should call old options on unmount', () => {
+		render(<ClassApp />, scratch);
+		render(null, scratch);
+
+		expect(vnodeSpy).to.have.been.called;
+		expect(rootSpy).to.have.been.called;
+		expect(beforeDiffSpy).to.have.been.called;
+		expect(afterDiffSpy).to.have.been.called;
+	});
+
+	it('should call old hook options for hook components', () => {
+		function HookApp() {
+			const [count, realSetCount] = useState(0);
+			setCount = realSetCount;
+			return <div>{count}</div>;
+		}
+
+		render(<HookApp />, scratch);
+
+		expect(hookSpy).to.have.been.called;
+	});
+
+	it('should call old options on error', () => {
+		class ErrorApp extends Component {
+			constructor() {
+				super();
+				this.state = { error: true };
+			}
+			componentDidCatch() {
+				this.setState({ error: false });
+			}
+			render() {
+				return <Throw error={this.state.error} />;
+			}
+		}
+
+		function Throw({ error }) {
+			if (error) {
+				throw new Error('test');
+			} else {
+				return <div>no error</div>;
+			}
+		}
+
+		render(<ErrorApp />, scratch);
+		rerender();
+
+		expect(catchErrorSpy).to.have.been.called;
+	});
+});
diff --git a/node_modules/preact/debug/test/browser/debug.test.js b/node_modules/preact/debug/test/browser/debug.test.js
new file mode 100644
index 0000000..7e75ef3
--- /dev/null
+++ b/node_modules/preact/debug/test/browser/debug.test.js
@@ -0,0 +1,618 @@
+import { createElement, render, createRef, Component, Fragment } from 'preact';
+import {
+	setupScratch,
+	teardown,
+	serializeHtml
+} from '../../../test/_util/helpers';
+import './fakeDevTools';
+import 'preact/debug';
+import * as PropTypes from 'prop-types';
+
+// eslint-disable-next-line no-duplicate-imports
+import { resetPropWarnings } from 'preact/debug';
+
+const h = createElement;
+/** @jsx createElement */
+
+describe('debug', () => {
+	let scratch;
+	let errors = [];
+	let warnings = [];
+
+	beforeEach(() => {
+		errors = [];
+		warnings = [];
+		scratch = setupScratch();
+		sinon.stub(console, 'error').callsFake(e => errors.push(e));
+		sinon.stub(console, 'warn').callsFake(w => warnings.push(w));
+	});
+
+	afterEach(() => {
+		/** @type {*} */
+		(console.error).restore();
+		console.warn.restore();
+		teardown(scratch);
+	});
+
+	it('should initialize devtools', () => {
+		expect(window.__PREACT_DEVTOOLS__.attachPreact).to.have.been.called;
+	});
+
+	it('should print an error on rendering on undefined parent', () => {
+		let fn = () => render(<div />, undefined);
+		expect(fn).to.throw(/render/);
+	});
+
+	it('should print an error on rendering on invalid parent', () => {
+		let fn = () => render(<div />, 6);
+		expect(fn).to.throw(/valid HTML node/);
+		expect(fn).to.throw(/<div/);
+	});
+
+	it('should print an error with (function) component name when available', () => {
+		const App = () => <div />;
+		let fn = () => render(<App />, 6);
+		expect(fn).to.throw(/<App/);
+		expect(fn).to.throw(/6/);
+
+		fn = () => render(<App />, {});
+		expect(fn).to.throw(/<App/);
+		expect(fn).to.throw(/[object Object]/);
+
+		fn = () => render(<Fragment />, 'badroot');
+		expect(fn).to.throw(/<Fragment/);
+		expect(fn).to.throw(/badroot/);
+	});
+
+	it('should print an error with (class) component name when available', () => {
+		class App extends Component {
+			render() {
+				return <div />;
+			}
+		}
+		let fn = () => render(<App />, 6);
+		expect(fn).to.throw(/<App/);
+	});
+
+	it('should print an error on undefined component', () => {
+		let fn = () => render(h(undefined), scratch);
+		expect(fn).to.throw(/createElement/);
+	});
+
+	it('should print an error on invalid object component', () => {
+		let fn = () => render(h({}), scratch);
+		expect(fn).to.throw(/createElement/);
+	});
+
+	it('should print an error when component is an array', () => {
+		let fn = () => render(h([<div />]), scratch);
+		expect(fn).to.throw(/createElement/);
+	});
+
+	it('should print an error on double jsx conversion', () => {
+		let Foo = <div />;
+		let fn = () => render(h(<Foo />), scratch);
+		expect(fn).to.throw(/JSX twice/);
+	});
+
+	it('should add __source to the vnode in debug mode.', () => {
+		const vnode = h('div', {
+			__source: {
+				fileName: 'div.jsx',
+				lineNumber: 3
+			}
+		});
+		expect(vnode.__source).to.deep.equal({
+			fileName: 'div.jsx',
+			lineNumber: 3
+		});
+		expect(vnode.props.__source).to.be.undefined;
+	});
+
+	it('should add __self to the vnode in debug mode.', () => {
+		const vnode = h('div', {
+			__self: {}
+		});
+		expect(vnode.__self).to.deep.equal({});
+		expect(vnode.props.__self).to.be.undefined;
+	});
+
+	it('should warn when accessing certain attributes', () => {
+		const vnode = h('div', null);
+		vnode;
+		vnode.attributes;
+		expect(console.warn).to.be.calledOnce;
+		expect(console.warn.args[0]).to.match(/use vnode.props/);
+		vnode.nodeName;
+		expect(console.warn).to.be.calledTwice;
+		expect(console.warn.args[1]).to.match(/use vnode.type/);
+		vnode.children;
+		expect(console.warn).to.be.calledThrice;
+		expect(console.warn.args[2]).to.match(/use vnode.props.children/);
+
+		// Should only warn once
+		vnode.attributes;
+		expect(console.warn).to.be.calledThrice;
+		vnode.nodeName;
+		expect(console.warn).to.be.calledThrice;
+		vnode.children;
+		expect(console.warn).to.be.calledThrice;
+
+		vnode.attributes = {};
+		expect(console.warn.args[3]).to.match(/use vnode.props/);
+		vnode.nodeName = '';
+		expect(console.warn.args[4]).to.match(/use vnode.type/);
+		vnode.children = [];
+		expect(console.warn.args[5]).to.match(/use vnode.props.children/);
+
+		// Should only warn once
+		vnode.attributes = {};
+		expect(console.warn.args.length).to.equal(6);
+		vnode.nodeName = '';
+		expect(console.warn.args.length).to.equal(6);
+		vnode.children = [];
+		expect(console.warn.args.length).to.equal(6);
+	});
+
+	it('should warn when calling setState inside the constructor', () => {
+		class Foo extends Component {
+			constructor(props) {
+				super(props);
+				this.setState({ foo: true });
+			}
+			render() {
+				return <div>foo</div>;
+			}
+		}
+
+		render(<Foo />, scratch);
+		expect(console.warn).to.be.calledOnce;
+		expect(console.warn.args[0]).to.match(/no-op/);
+	});
+
+	it('should NOT warn when calling setState inside the cWM', () => {
+		class Foo extends Component {
+			componentWillMount() {
+				this.setState({ foo: true });
+			}
+			render() {
+				return <div>foo</div>;
+			}
+		}
+
+		render(<Foo />, scratch);
+		expect(console.warn).to.not.be.called;
+	});
+
+	it('should warn when calling setState on an unmounted Component', () => {
+		let setState;
+
+		class Foo extends Component {
+			constructor(props) {
+				super(props);
+				setState = () => this.setState({ foo: true });
+			}
+			render() {
+				return <div>foo</div>;
+			}
+		}
+
+		render(<Foo />, scratch);
+		expect(console.warn).to.not.be.called;
+
+		render(null, scratch);
+
+		setState();
+		expect(console.warn).to.be.calledOnce;
+		expect(console.warn.args[0]).to.match(/no-op/);
+	});
+
+	it('should warn when calling forceUpdate inside the constructor', () => {
+		class Foo extends Component {
+			constructor(props) {
+				super(props);
+				this.forceUpdate();
+			}
+			render() {
+				return <div>foo</div>;
+			}
+		}
+
+		render(<Foo />, scratch);
+		expect(console.warn).to.be.calledOnce;
+		expect(console.warn.args[0]).to.match(/no-op/);
+	});
+
+	it('should warn when calling forceUpdate on an unmounted Component', () => {
+		let forceUpdate;
+
+		class Foo extends Component {
+			constructor(props) {
+				super(props);
+				forceUpdate = () => this.forceUpdate();
+			}
+			render() {
+				return <div>foo</div>;
+			}
+		}
+
+		render(<Foo />, scratch);
+		forceUpdate();
+		expect(console.warn).to.not.be.called;
+
+		render(null, scratch);
+
+		forceUpdate();
+		expect(console.warn).to.be.calledOnce;
+		expect(console.warn.args[0]).to.match(/no-op/);
+	});
+
+	it('should print an error when child is a plain object', () => {
+		let fn = () => render(<div>{{}}</div>, scratch);
+		expect(fn).to.throw(/not valid/);
+	});
+
+	it('should print an error on invalid refs', () => {
+		let fn = () => render(<div ref="a" />, scratch);
+		expect(fn).to.throw(/createRef/);
+	});
+
+	it('should not print for null as a handler', () => {
+		let fn = () => render(<div onclick={null} />, scratch);
+		expect(fn).not.to.throw();
+	});
+
+	it('should not print for undefined as a handler', () => {
+		let fn = () => render(<div onclick={undefined} />, scratch);
+		expect(fn).not.to.throw();
+	});
+
+	it('should not print for attributes starting with on for Components', () => {
+		const Comp = () => <p>online</p>;
+		let fn = () => render(<Comp online={false} />, scratch);
+		expect(fn).not.to.throw();
+	});
+
+	it('should print an error on invalid handler', () => {
+		let fn = () => render(<div onclick="a" />, scratch);
+		expect(fn).to.throw(/"onclick" property should be a function/);
+	});
+
+	it('should NOT print an error on valid refs', () => {
+		let noop = () => {};
+		render(<div ref={noop} />, scratch);
+
+		let ref = createRef();
+		render(<div ref={ref} />, scratch);
+		expect(console.error).to.not.be.called;
+	});
+
+	describe('duplicate keys', () => {
+		const List = props => <ul>{props.children}</ul>;
+		const ListItem = props => <li>{props.children}</li>;
+
+		it('should print an error on duplicate keys with DOM nodes', () => {
+			render(
+				<div>
+					<span key="a" />
+					<span key="a" />
+				</div>,
+				scratch
+			);
+			expect(console.error).to.be.calledOnce;
+		});
+
+		it('should allow distinct object keys', () => {
+			const A = { is: 'A' };
+			const B = { is: 'B' };
+			render(
+				<div>
+					<span key={A} />
+					<span key={B} />
+				</div>,
+				scratch
+			);
+			expect(console.error).not.to.be.called;
+		});
+
+		it('should print an error for duplicate object keys', () => {
+			const A = { is: 'A' };
+			render(
+				<div>
+					<span key={A} />
+					<span key={A} />
+				</div>,
+				scratch
+			);
+			expect(console.error).to.be.calledOnce;
+		});
+
+		it('should print an error on duplicate keys with Components', () => {
+			function App() {
+				return (
+					<List>
+						<ListItem key="a">a</ListItem>
+						<ListItem key="b">b</ListItem>
+						<ListItem key="b">d</ListItem>
+						<ListItem key="d">d</ListItem>
+					</List>
+				);
+			}
+
+			render(<App />, scratch);
+			expect(console.error).to.be.calledOnce;
+		});
+
+		it('should print an error on duplicate keys with Fragments', () => {
+			function App() {
+				return (
+					<Fragment>
+						<List key="list">
+							<ListItem key="a">a</ListItem>
+							<ListItem key="b">b</ListItem>
+							<Fragment key="b">
+								{/* Should be okay to duplicate keys since these are inside a Fragment */}
+								<ListItem key="a">c</ListItem>
+								<ListItem key="b">d</ListItem>
+								<ListItem key="c">e</ListItem>
+							</Fragment>
+							<ListItem key="f">f</ListItem>
+						</List>
+						<div key="list">sibling</div>
+					</Fragment>
+				);
+			}
+
+			render(<App />, scratch);
+			expect(console.error).to.be.calledTwice;
+		});
+	});
+
+	describe('table markup', () => {
+		it('missing <tbody>/<thead>/<tfoot>/<table>', () => {
+			const Table = () => (
+				<tr>
+					<td>hi</td>
+				</tr>
+			);
+			render(<Table />, scratch);
+			expect(console.error).to.be.calledOnce;
+		});
+
+		it('missing <table> with <thead>', () => {
+			const Table = () => (
+				<thead>
+					<tr>
+						<td>hi</td>
+					</tr>
+				</thead>
+			);
+			render(<Table />, scratch);
+			expect(console.error).to.be.calledOnce;
+		});
+
+		it('missing <table> with <tbody>', () => {
+			const Table = () => (
+				<tbody>
+					<tr>
+						<td>hi</td>
+					</tr>
+				</tbody>
+			);
+			render(<Table />, scratch);
+			expect(console.error).to.be.calledOnce;
+		});
+
+		it('missing <table> with <tfoot>', () => {
+			const Table = () => (
+				<tfoot>
+					<tr>
+						<td>hi</td>
+					</tr>
+				</tfoot>
+			);
+			render(<Table />, scratch);
+			expect(console.error).to.be.calledOnce;
+		});
+
+		it('missing <tr>', () => {
+			const Table = () => (
+				<table>
+					<tbody>
+						<td>Hi</td>
+					</tbody>
+				</table>
+			);
+			render(<Table />, scratch);
+			expect(console.error).to.be.calledOnce;
+		});
+
+		it('missing <tr> with td component', () => {
+			const Cell = ({ children }) => <td>{children}</td>;
+			const Table = () => (
+				<table>
+					<tbody>
+						<Cell>Hi</Cell>
+					</tbody>
+				</table>
+			);
+			render(<Table />, scratch);
+			expect(console.error).to.be.calledOnce;
+		});
+
+		it('missing <tr> with th component', () => {
+			const Cell = ({ children }) => <th>{children}</th>;
+			const Table = () => (
+				<table>
+					<tbody>
+						<Cell>Hi</Cell>
+					</tbody>
+				</table>
+			);
+			render(<Table />, scratch);
+			expect(console.error).to.be.calledOnce;
+		});
+
+		it('Should accept <td> instead of <th> in <thead>', () => {
+			const Table = () => (
+				<table>
+					<thead>
+						<tr>
+							<td>Hi</td>
+						</tr>
+					</thead>
+				</table>
+			);
+			render(<Table />, scratch);
+			expect(console.error).to.not.be.called;
+		});
+
+		it('Accepts well formed table with TD components', () => {
+			const Cell = ({ children }) => <td>{children}</td>;
+			const Table = () => (
+				<table>
+					<thead>
+						<tr>
+							<th>Head</th>
+						</tr>
+					</thead>
+					<tbody>
+						<tr>
+							<td>Body</td>
+						</tr>
+					</tbody>
+					<tfoot>
+						<tr>
+							<Cell>Body</Cell>
+						</tr>
+					</tfoot>
+				</table>
+			);
+			render(<Table />, scratch);
+			expect(console.error).to.not.be.called;
+		});
+
+		it('Accepts well formed table', () => {
+			const Table = () => (
+				<table>
+					<thead>
+						<tr>
+							<th>Head</th>
+						</tr>
+					</thead>
+					<tbody>
+						<tr>
+							<td>Body</td>
+						</tr>
+					</tbody>
+					<tfoot>
+						<tr>
+							<td>Body</td>
+						</tr>
+					</tfoot>
+				</table>
+			);
+			render(<Table />, scratch);
+			expect(console.error).to.not.be.called;
+		});
+
+		it('Accepts minimal well formed table', () => {
+			const Table = () => (
+				<table>
+					<tr>
+						<th>Head</th>
+					</tr>
+					<tr>
+						<td>Body</td>
+					</tr>
+				</table>
+			);
+			render(<Table />, scratch);
+			expect(console.error).to.not.be.called;
+		});
+	});
+
+	describe('PropTypes', () => {
+		beforeEach(() => {
+			resetPropWarnings();
+		});
+
+		it("should fail if props don't match prop-types", () => {
+			function Foo(props) {
+				return <h1>{props.text}</h1>;
+			}
+
+			Foo.propTypes = {
+				text: PropTypes.string.isRequired
+			};
+
+			render(<Foo text={123} />, scratch);
+
+			expect(console.error).to.be.calledOnce;
+
+			// The message here may change when the "prop-types" library is updated,
+			// but we check it exactly to make sure all parameters were supplied
+			// correctly.
+			expect(console.error).to.have.been.calledOnceWith(
+				sinon.match(
+					/^Failed prop type: Invalid prop `text` of type `number` supplied to `Foo`, expected `string`\.\n {2}in Foo \(at (.*)\/debug\/test\/browser\/debug\.test\.js:[0-9]+\)$/m
+				)
+			);
+		});
+
+		it('should only log a given prop type error once', () => {
+			function Foo(props) {
+				return <h1>{props.text}</h1>;
+			}
+
+			Foo.propTypes = {
+				text: PropTypes.string.isRequired,
+				count: PropTypes.number
+			};
+
+			// Trigger the same error twice. The error should only be logged
+			// once.
+			render(<Foo text={123} />, scratch);
+			render(<Foo text={123} />, scratch);
+
+			expect(console.error).to.be.calledOnce;
+
+			// Trigger a different error. This should result in a new log
+			// message.
+			console.error.resetHistory();
+			render(<Foo text="ok" count="123" />, scratch);
+			expect(console.error).to.be.calledOnce;
+		});
+
+		it('should render with error logged when validator gets signal and throws exception', () => {
+			function Baz(props) {
+				return <h1>{props.unhappy}</h1>;
+			}
+
+			Baz.propTypes = {
+				unhappy: function alwaysThrows(obj, key) {
+					if (obj[key] === 'signal') throw Error('got prop');
+				}
+			};
+
+			render(<Baz unhappy={'signal'} />, scratch);
+
+			expect(console.error).to.be.calledOnce;
+			expect(errors[0].includes('got prop')).to.equal(true);
+			expect(serializeHtml(scratch)).to.equal('<h1>signal</h1>');
+		});
+
+		it('should not print to console when types are correct', () => {
+			function Bar(props) {
+				return <h1>{props.text}</h1>;
+			}
+
+			Bar.propTypes = {
+				text: PropTypes.string.isRequired
+			};
+
+			render(<Bar text="foo" />, scratch);
+			expect(console.error).to.not.be.called;
+		});
+	});
+});
diff --git a/node_modules/preact/debug/test/browser/fakeDevTools.js b/node_modules/preact/debug/test/browser/fakeDevTools.js
new file mode 100644
index 0000000..e611df3
--- /dev/null
+++ b/node_modules/preact/debug/test/browser/fakeDevTools.js
@@ -0,0 +1 @@
+window.__PREACT_DEVTOOLS__ = { attachPreact: sinon.spy() };
diff --git a/node_modules/preact/debug/test/browser/serializeVNode.test.js b/node_modules/preact/debug/test/browser/serializeVNode.test.js
new file mode 100644
index 0000000..354d526
--- /dev/null
+++ b/node_modules/preact/debug/test/browser/serializeVNode.test.js
@@ -0,0 +1,62 @@
+import { createElement, Component } from 'preact';
+import { serializeVNode } from '../../src/debug';
+
+/** @jsx createElement */
+
+describe('serializeVNode', () => {
+	it("should prefer a function component's displayName", () => {
+		function Foo() {
+			return <div />;
+		}
+		Foo.displayName = 'Bar';
+
+		expect(serializeVNode(<Foo />)).to.equal('<Bar />');
+	});
+
+	it("should prefer a class component's displayName", () => {
+		class Bar extends Component {
+			render() {
+				return <div />;
+			}
+		}
+		Bar.displayName = 'Foo';
+
+		expect(serializeVNode(<Bar />)).to.equal('<Foo />');
+	});
+
+	it('should serialize vnodes without children', () => {
+		expect(serializeVNode(<br />)).to.equal('<br />');
+	});
+
+	it('should serialize vnodes with children', () => {
+		expect(serializeVNode(<div>Hello World</div>)).to.equal('<div>..</div>');
+	});
+
+	it('should serialize components', () => {
+		function Foo() {
+			return <div />;
+		}
+		expect(serializeVNode(<Foo />)).to.equal('<Foo />');
+	});
+
+	it('should serialize props', () => {
+		expect(serializeVNode(<div class="foo" />)).to.equal('<div class="foo" />');
+
+		let noop = () => {};
+		expect(serializeVNode(<div onClick={noop} />)).to.equal(
+			'<div onClick="function noop() {}" />'
+		);
+
+		function Foo(props) {
+			return props.foo;
+		}
+
+		expect(serializeVNode(<Foo foo={[1, 2, 3]} />)).to.equal(
+			'<Foo foo="1,2,3" />'
+		);
+
+		expect(serializeVNode(<div prop={Object.create(null)} />)).to.equal(
+			'<div prop="[object Object]" />'
+		);
+	});
+});
diff --git a/node_modules/preact/devtools/mangle.json b/node_modules/preact/devtools/mangle.json
new file mode 100644
index 0000000..506a6a4
--- /dev/null
+++ b/node_modules/preact/devtools/mangle.json
@@ -0,0 +1,21 @@
+{
+  "help": {
+    "what is this file?": "It controls protected/private property mangling so that minified builds have consistent property names.",
+    "why are there duplicate minified properties?": "Most properties are only used on one type of objects, so they can have the same name since they will never collide. Doing this reduces size."
+  },
+  "minify": {
+    "mangle": {
+      "properties": {
+        "regex": "^_[^_]",
+        "reserved": [
+          "__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED",
+          "__REACT_DEVTOOLS_GLOBAL_HOOK__",
+          "__PREACT_DEVTOOLS__",
+          "_renderers",
+          "__source",
+          "__self"
+        ]
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/node_modules/preact/dist/preact.js b/node_modules/preact/dist/preact.js
index e4d3165..89b840e 100644
--- a/node_modules/preact/dist/preact.js
+++ b/node_modules/preact/dist/preact.js
@@ -1,2 +1,2 @@
-var n,l,u,t,i,o,r,f={},e=[],c=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function s(n,l){for(var u in l)n[u]=l[u];return n}function a(n){var l=n.parentNode;l&&l.removeChild(n)}function p(n,l,u){var t,i,o,r=arguments,f={};for(o in l)"key"==o?t=l[o]:"ref"==o?i=l[o]:f[o]=l[o];if(arguments.length>3)for(u=[u],o=3;o<arguments.length;o++)u.push(r[o]);if(null!=u&&(f.children=u),"function"==typeof n&&null!=n.defaultProps)for(o in n.defaultProps)void 0===f[o]&&(f[o]=n.defaultProps[o]);return v(n,f,t,i,null)}function v(l,u,t,i,o){var r={type:l,props:u,key:t,ref:i,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,constructor:void 0,__v:o};return null==o&&(r.__v=r),null!=n.vnode&&n.vnode(r),r}function h(n){return n.children}function y(n,l){this.props=n,this.context=l}function d(n,l){if(null==l)return n.__?d(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return"function"==typeof n.type?d(n):null}function _(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return _(n)}}function w(l){(!l.__d&&(l.__d=!0)&&u.push(l)&&!x.__r++||i!==n.debounceRendering)&&((i=n.debounceRendering)||t)(x)}function x(){for(var n;x.__r=u.length;)n=u.sort(function(n,l){return n.__v.__b-l.__v.__b}),u=[],n.some(function(n){var l,u,t,i,o,r,f;n.__d&&(r=(o=(l=n).__v).__e,(f=l.__P)&&(u=[],(t=s({},o)).__v=t,i=z(f,o,t,l.__n,void 0!==f.ownerSVGElement,null,u,null==r?d(o):r),N(u,o),i!=r&&_(o)))})}function k(n,l,u,t,i,o,r,c,s,p){var y,_,w,x,k,g,b,A=t&&t.__k||e,P=A.length;for(s==f&&(s=null!=r?r[0]:P?d(t,0):null),u.__k=[],y=0;y<l.length;y++)if(null!=(x=u.__k[y]=null==(x=l[y])||"boolean"==typeof x?null:"string"==typeof x||"number"==typeof x?v(null,x,null,null,x):Array.isArray(x)?v(h,{children:x},null,null,null):null!=x.__e||null!=x.__c?v(x.type,x.props,x.key,null,x.__v):x)){if(x.__=u,x.__b=u.__b+1,null===(w=A[y])||w&&x.key==w.key&&x.type===w.type)A[y]=void 0;else for(_=0;_<P;_++){if((w=A[_])&&x.key==w.key&&x.type===w.type){A[_]=void 0;break}w=null}k=z(n,x,w=w||f,i,o,r,c,s,p),(_=x.ref)&&w.ref!=_&&(b||(b=[]),w.ref&&b.push(w.ref,null,x),b.push(_,x.__c||k,x)),null!=k?(null==g&&(g=k),s=m(n,x,w,A,r,k,s),p||"option"!=u.type?"function"==typeof u.type&&(u.__d=s):n.value=""):s&&w.__e==s&&s.parentNode!=n&&(s=d(w))}if(u.__e=g,null!=r&&"function"!=typeof u.type)for(y=r.length;y--;)null!=r[y]&&a(r[y]);for(y=P;y--;)null!=A[y]&&j(A[y],A[y]);if(b)for(y=0;y<b.length;y++)$(b[y],b[++y],b[++y])}function m(n,l,u,t,i,o,r){var f,e,c;if(void 0!==l.__d)f=l.__d,l.__d=void 0;else if(i==u||o!=r||null==o.parentNode)n:if(null==r||r.parentNode!==n)n.appendChild(o),f=null;else{for(e=r,c=0;(e=e.nextSibling)&&c<t.length;c+=2)if(e==o)break n;n.insertBefore(o,r),f=r}return void 0!==f?f:o.nextSibling}function g(n,l,u,t,i){var o;for(o in u)"children"===o||"key"===o||o in l||A(n,o,null,u[o],t);for(o in l)i&&"function"!=typeof l[o]||"children"===o||"key"===o||"value"===o||"checked"===o||u[o]===l[o]||A(n,o,l[o],u[o],t)}function b(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]=null==u?"":"number"!=typeof u||c.test(l)?u:u+"px"}function A(n,l,u,t,i){var o,r;if(i&&"className"==l&&(l="class"),"style"===l)if("string"==typeof u)n.style=u;else{if("string"==typeof t&&(n.style=t=""),t)for(l in t)u&&l in u||b(n.style,l,"");if(u)for(l in u)t&&u[l]===t[l]||b(n.style,l,u[l])}else"o"===l[0]&&"n"===l[1]?(o=l!==(l=l.replace(/Capture$/,"")),(r=l.toLowerCase())in n&&(l=r),l=l.slice(2),n.l||(n.l={}),n.l[l]=u,u?t||n.addEventListener(l,P,o):n.removeEventListener(l,P,o)):"list"!==l&&"tagName"!==l&&"form"!==l&&"type"!==l&&"size"!==l&&"download"!==l&&"href"!==l&&!i&&l in n?n[l]=null==u?"":u:"function"!=typeof u&&"dangerouslySetInnerHTML"!==l&&(l!==(l=l.replace(/xlink:?/,""))?null==u||!1===u?n.removeAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase()):n.setAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase(),u):null==u||!1===u&&!/^ar/.test(l)?n.removeAttribute(l):n.setAttribute(l,u))}function P(l){this.l[l.type](n.event?n.event(l):l)}function C(n,l,u){var t,i;for(t=0;t<n.__k.length;t++)(i=n.__k[t])&&(i.__=n,i.__e&&("function"==typeof i.type&&i.__k.length>1&&C(i,l,u),l=m(u,i,i,n.__k,null,i.__e,l),"function"==typeof n.type&&(n.__d=l)))}function z(l,u,t,i,o,r,f,e,c){var a,p,v,d,_,w,x,m,g,b,A,P=u.type;if(void 0!==u.constructor)return null;(a=n.__b)&&a(u);try{n:if("function"==typeof P){if(m=u.props,g=(a=P.contextType)&&i[a.__c],b=a?g?g.props.value:a.__:i,t.__c?x=(p=u.__c=t.__c).__=p.__E:("prototype"in P&&P.prototype.render?u.__c=p=new P(m,b):(u.__c=p=new y(m,b),p.constructor=P,p.render=H),g&&g.sub(p),p.props=m,p.state||(p.state={}),p.context=b,p.__n=i,v=p.__d=!0,p.__h=[]),null==p.__s&&(p.__s=p.state),null!=P.getDerivedStateFromProps&&(p.__s==p.state&&(p.__s=s({},p.__s)),s(p.__s,P.getDerivedStateFromProps(m,p.__s))),d=p.props,_=p.state,v)null==P.getDerivedStateFromProps&&null!=p.componentWillMount&&p.componentWillMount(),null!=p.componentDidMount&&p.__h.push(p.componentDidMount);else{if(null==P.getDerivedStateFromProps&&m!==d&&null!=p.componentWillReceiveProps&&p.componentWillReceiveProps(m,b),!p.__e&&null!=p.shouldComponentUpdate&&!1===p.shouldComponentUpdate(m,p.__s,b)||u.__v===t.__v){p.props=m,p.state=p.__s,u.__v!==t.__v&&(p.__d=!1),p.__v=u,u.__e=t.__e,u.__k=t.__k,p.__h.length&&f.push(p),C(u,e,l);break n}null!=p.componentWillUpdate&&p.componentWillUpdate(m,p.__s,b),null!=p.componentDidUpdate&&p.__h.push(function(){p.componentDidUpdate(d,_,w)})}p.context=b,p.props=m,p.state=p.__s,(a=n.__r)&&a(u),p.__d=!1,p.__v=u,p.__P=l,a=p.render(p.props,p.state,p.context),p.state=p.__s,null!=p.getChildContext&&(i=s(s({},i),p.getChildContext())),v||null==p.getSnapshotBeforeUpdate||(w=p.getSnapshotBeforeUpdate(d,_)),A=null!=a&&a.type==h&&null==a.key?a.props.children:a,k(l,Array.isArray(A)?A:[A],u,t,i,o,r,f,e,c),p.base=u.__e,p.__h.length&&f.push(p),x&&(p.__E=p.__=null),p.__e=!1}else null==r&&u.__v===t.__v?(u.__k=t.__k,u.__e=t.__e):u.__e=T(t.__e,u,t,i,o,r,f,c);(a=n.diffed)&&a(u)}catch(l){u.__v=null,n.__e(l,u,t)}return u.__e}function N(l,u){n.__c&&n.__c(u,l),l.some(function(u){try{l=u.__h,u.__h=[],l.some(function(n){n.call(u)})}catch(l){n.__e(l,u.__v)}})}function T(n,l,u,t,i,o,r,c){var s,a,p,v,h,y=u.props,d=l.props;if(i="svg"===l.type||i,null!=o)for(s=0;s<o.length;s++)if(null!=(a=o[s])&&((null===l.type?3===a.nodeType:a.localName===l.type)||n==a)){n=a,o[s]=null;break}if(null==n){if(null===l.type)return document.createTextNode(d);n=i?document.createElementNS("http://www.w3.org/2000/svg",l.type):document.createElement(l.type,d.is&&{is:d.is}),o=null,c=!1}if(null===l.type)y!==d&&n.data!==d&&(n.data=d);else{if(null!=o&&(o=e.slice.call(n.childNodes)),p=(y=u.props||f).dangerouslySetInnerHTML,v=d.dangerouslySetInnerHTML,!c){if(null!=o)for(y={},h=0;h<n.attributes.length;h++)y[n.attributes[h].name]=n.attributes[h].value;(v||p)&&(v&&p&&v.__html==p.__html||(n.innerHTML=v&&v.__html||""))}g(n,d,y,i,c),v?l.__k=[]:(s=l.props.children,k(n,Array.isArray(s)?s:[s],l,u,t,"foreignObject"!==l.type&&i,o,r,f,c)),c||("value"in d&&void 0!==(s=d.value)&&s!==n.value&&A(n,"value",s,y.value,!1),"checked"in d&&void 0!==(s=d.checked)&&s!==n.checked&&A(n,"checked",s,y.checked,!1))}return n}function $(l,u,t){try{"function"==typeof l?l(u):l.current=u}catch(l){n.__e(l,t)}}function j(l,u,t){var i,o,r;if(n.unmount&&n.unmount(l),(i=l.ref)&&(i.current&&i.current!==l.__e||$(i,null,u)),t||"function"==typeof l.type||(t=null!=(o=l.__e)),l.__e=l.__d=void 0,null!=(i=l.__c)){if(i.componentWillUnmount)try{i.componentWillUnmount()}catch(l){n.__e(l,u)}i.base=i.__P=null}if(i=l.__k)for(r=0;r<i.length;r++)i[r]&&j(i[r],u,t);null!=o&&a(o)}function H(n,l,u){return this.constructor(n,u)}function I(l,u,t){var i,r,c;n.__&&n.__(l,u),r=(i=t===o)?null:t&&t.__k||u.__k,l=p(h,null,[l]),c=[],z(u,(i?u:t||u).__k=l,r||f,f,void 0!==u.ownerSVGElement,t&&!i?[t]:r?null:u.childNodes.length?e.slice.call(u.childNodes):null,c,t||f,i),N(c,l)}n={__e:function(n,l){for(var u,t;l=l.__;)if((u=l.__c)&&!u.__)try{if(u.constructor&&null!=u.constructor.getDerivedStateFromError&&(t=!0,u.setState(u.constructor.getDerivedStateFromError(n))),null!=u.componentDidCatch&&(t=!0,u.componentDidCatch(n)),t)return w(u.__E=u)}catch(l){n=l}throw n}},l=function(n){return null!=n&&void 0===n.constructor},y.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=s({},this.state),"function"==typeof n&&(n=n(s({},u),this.props)),n&&s(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),w(this))},y.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),w(this))},y.prototype.render=h,u=[],t="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,x.__r=0,o=f,r=0,exports.render=I,exports.hydrate=function(n,l){I(n,l,o)},exports.createElement=p,exports.h=p,exports.Fragment=h,exports.createRef=function(){return{current:null}},exports.isValidElement=l,exports.Component=y,exports.cloneElement=function(n,l,u){var t,i,o,r=arguments,f=s({},n.props);for(o in l)"key"==o?t=l[o]:"ref"==o?i=l[o]:f[o]=l[o];if(arguments.length>3)for(u=[u],o=3;o<arguments.length;o++)u.push(r[o]);return null!=u&&(f.children=u),v(n.type,f,t||n.key,i||n.ref,null)},exports.createContext=function(n,l){var u={__c:l="__cC"+r++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n,u,t){return this.getChildContext||(u=[],(t={})[l]=this,this.getChildContext=function(){return t},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(w)},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u},exports.toChildArray=function n(l,u){return u=u||[],null==l||"boolean"==typeof l||(Array.isArray(l)?l.some(function(l){n(l,u)}):u.push(l)),u},exports.__u=j,exports.options=n;
+var n,l,u,t,i,o,r,f={},e=[],c=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function s(n,l){for(var u in l)n[u]=l[u];return n}function a(n){var l=n.parentNode;l&&l.removeChild(n)}function p(n,l,u){var t,i,o,r=arguments,f={};for(o in l)"key"==o?t=l[o]:"ref"==o?i=l[o]:f[o]=l[o];if(arguments.length>3)for(u=[u],o=3;o<arguments.length;o++)u.push(r[o]);if(null!=u&&(f.children=u),"function"==typeof n&&null!=n.defaultProps)for(o in n.defaultProps)void 0===f[o]&&(f[o]=n.defaultProps[o]);return v(n,f,t,i,null)}function v(l,u,t,i,o){var r={type:l,props:u,key:t,ref:i,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,constructor:void 0,__v:o};return null==o&&(r.__v=r),null!=n.vnode&&n.vnode(r),r}function h(n){return n.children}function y(n,l){this.props=n,this.context=l}function d(n,l){if(null==l)return n.__?d(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return"function"==typeof n.type?d(n):null}function _(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return _(n)}}function w(l){(!l.__d&&(l.__d=!0)&&u.push(l)&&!x.__r++||i!==n.debounceRendering)&&((i=n.debounceRendering)||t)(x)}function x(){for(var n;x.__r=u.length;)n=u.sort(function(n,l){return n.__v.__b-l.__v.__b}),u=[],n.some(function(n){var l,u,t,i,o,r,f;n.__d&&(r=(o=(l=n).__v).__e,(f=l.__P)&&(u=[],(t=s({},o)).__v=t,i=N(f,o,t,l.__n,void 0!==f.ownerSVGElement,null,u,null==r?d(o):r),T(u,o),i!=r&&_(o)))})}function k(n,l,u,t,i,o,r,c,s,p){var y,_,w,x,k,g,b,A=t&&t.__k||e,P=A.length;for(s==f&&(s=null!=r?r[0]:P?d(t,0):null),u.__k=[],y=0;y<l.length;y++)if(null!=(x=u.__k[y]=null==(x=l[y])||"boolean"==typeof x?null:"string"==typeof x||"number"==typeof x?v(null,x,null,null,x):Array.isArray(x)?v(h,{children:x},null,null,null):null!=x.__e||null!=x.__c?v(x.type,x.props,x.key,null,x.__v):x)){if(x.__=u,x.__b=u.__b+1,null===(w=A[y])||w&&x.key==w.key&&x.type===w.type)A[y]=void 0;else for(_=0;_<P;_++){if((w=A[_])&&x.key==w.key&&x.type===w.type){A[_]=void 0;break}w=null}k=N(n,x,w=w||f,i,o,r,c,s,p),(_=x.ref)&&w.ref!=_&&(b||(b=[]),w.ref&&b.push(w.ref,null,x),b.push(_,x.__c||k,x)),null!=k?(null==g&&(g=k),s=m(n,x,w,A,r,k,s),p||"option"!=u.type?"function"==typeof u.type&&(u.__d=s):n.value=""):s&&w.__e==s&&s.parentNode!=n&&(s=d(w))}if(u.__e=g,null!=r&&"function"!=typeof u.type)for(y=r.length;y--;)null!=r[y]&&a(r[y]);for(y=P;y--;)null!=A[y]&&H(A[y],A[y]);if(b)for(y=0;y<b.length;y++)j(b[y],b[++y],b[++y])}function m(n,l,u,t,i,o,r){var f,e,c;if(void 0!==l.__d)f=l.__d,l.__d=void 0;else if(i==u||o!=r||null==o.parentNode)n:if(null==r||r.parentNode!==n)n.appendChild(o),f=null;else{for(e=r,c=0;(e=e.nextSibling)&&c<t.length;c+=2)if(e==o)break n;n.insertBefore(o,r),f=r}return void 0!==f?f:o.nextSibling}function g(n,l,u,t,i){var o;for(o in u)"children"===o||"key"===o||o in l||A(n,o,null,u[o],t);for(o in l)i&&"function"!=typeof l[o]||"children"===o||"key"===o||"value"===o||"checked"===o||u[o]===l[o]||A(n,o,l[o],u[o],t)}function b(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]=null==u?"":"number"!=typeof u||c.test(l)?u:u+"px"}function A(n,l,u,t,i){var o,r,f;if(i&&"className"==l&&(l="class"),"style"===l)if("string"==typeof u)n.style.cssText=u;else{if("string"==typeof t&&(n.style.cssText=t=""),t)for(l in t)u&&l in u||b(n.style,l,"");if(u)for(l in u)t&&u[l]===t[l]||b(n.style,l,u[l])}else"o"===l[0]&&"n"===l[1]?(o=l!==(l=l.replace(/Capture$/,"")),(r=l.toLowerCase())in n&&(l=r),l=l.slice(2),n.l||(n.l={}),n.l[l+o]=u,f=o?C:P,u?t||n.addEventListener(l,f,o):n.removeEventListener(l,f,o)):"list"!==l&&"tagName"!==l&&"form"!==l&&"type"!==l&&"size"!==l&&"download"!==l&&"href"!==l&&!i&&l in n?n[l]=null==u?"":u:"function"!=typeof u&&"dangerouslySetInnerHTML"!==l&&(l!==(l=l.replace(/xlink:?/,""))?null==u||!1===u?n.removeAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase()):n.setAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase(),u):null==u||!1===u&&!/^ar/.test(l)?n.removeAttribute(l):n.setAttribute(l,u))}function P(l){this.l[l.type+!1](n.event?n.event(l):l)}function C(l){this.l[l.type+!0](n.event?n.event(l):l)}function z(n,l,u){var t,i;for(t=0;t<n.__k.length;t++)(i=n.__k[t])&&(i.__=n,i.__e&&("function"==typeof i.type&&i.__k.length>1&&z(i,l,u),l=m(u,i,i,n.__k,null,i.__e,l),"function"==typeof n.type&&(n.__d=l)))}function N(l,u,t,i,o,r,f,e,c){var a,p,v,d,_,w,x,m,g,b,A,P=u.type;if(void 0!==u.constructor)return null;(a=n.__b)&&a(u);try{n:if("function"==typeof P){if(m=u.props,g=(a=P.contextType)&&i[a.__c],b=a?g?g.props.value:a.__:i,t.__c?x=(p=u.__c=t.__c).__=p.__E:("prototype"in P&&P.prototype.render?u.__c=p=new P(m,b):(u.__c=p=new y(m,b),p.constructor=P,p.render=I),g&&g.sub(p),p.props=m,p.state||(p.state={}),p.context=b,p.__n=i,v=p.__d=!0,p.__h=[]),null==p.__s&&(p.__s=p.state),null!=P.getDerivedStateFromProps&&(p.__s==p.state&&(p.__s=s({},p.__s)),s(p.__s,P.getDerivedStateFromProps(m,p.__s))),d=p.props,_=p.state,v)null==P.getDerivedStateFromProps&&null!=p.componentWillMount&&p.componentWillMount(),null!=p.componentDidMount&&p.__h.push(p.componentDidMount);else{if(null==P.getDerivedStateFromProps&&m!==d&&null!=p.componentWillReceiveProps&&p.componentWillReceiveProps(m,b),!p.__e&&null!=p.shouldComponentUpdate&&!1===p.shouldComponentUpdate(m,p.__s,b)||u.__v===t.__v){p.props=m,p.state=p.__s,u.__v!==t.__v&&(p.__d=!1),p.__v=u,u.__e=t.__e,u.__k=t.__k,p.__h.length&&f.push(p),z(u,e,l);break n}null!=p.componentWillUpdate&&p.componentWillUpdate(m,p.__s,b),null!=p.componentDidUpdate&&p.__h.push(function(){p.componentDidUpdate(d,_,w)})}p.context=b,p.props=m,p.state=p.__s,(a=n.__r)&&a(u),p.__d=!1,p.__v=u,p.__P=l,a=p.render(p.props,p.state,p.context),p.state=p.__s,null!=p.getChildContext&&(i=s(s({},i),p.getChildContext())),v||null==p.getSnapshotBeforeUpdate||(w=p.getSnapshotBeforeUpdate(d,_)),A=null!=a&&a.type==h&&null==a.key?a.props.children:a,k(l,Array.isArray(A)?A:[A],u,t,i,o,r,f,e,c),p.base=u.__e,p.__h.length&&f.push(p),x&&(p.__E=p.__=null),p.__e=!1}else null==r&&u.__v===t.__v?(u.__k=t.__k,u.__e=t.__e):u.__e=$(t.__e,u,t,i,o,r,f,c);(a=n.diffed)&&a(u)}catch(l){u.__v=null,n.__e(l,u,t)}return u.__e}function T(l,u){n.__c&&n.__c(u,l),l.some(function(u){try{l=u.__h,u.__h=[],l.some(function(n){n.call(u)})}catch(l){n.__e(l,u.__v)}})}function $(n,l,u,t,i,o,r,c){var s,a,p,v,h,y=u.props,d=l.props;if(i="svg"===l.type||i,null!=o)for(s=0;s<o.length;s++)if(null!=(a=o[s])&&((null===l.type?3===a.nodeType:a.localName===l.type)||n==a)){n=a,o[s]=null;break}if(null==n){if(null===l.type)return document.createTextNode(d);n=i?document.createElementNS("http://www.w3.org/2000/svg",l.type):document.createElement(l.type,d.is&&{is:d.is}),o=null,c=!1}if(null===l.type)y!==d&&n.data!==d&&(n.data=d);else{if(null!=o&&(o=e.slice.call(n.childNodes)),p=(y=u.props||f).dangerouslySetInnerHTML,v=d.dangerouslySetInnerHTML,!c){if(null!=o)for(y={},h=0;h<n.attributes.length;h++)y[n.attributes[h].name]=n.attributes[h].value;(v||p)&&(v&&(p&&v.__html==p.__html||v.__html===n.innerHTML)||(n.innerHTML=v&&v.__html||""))}g(n,d,y,i,c),v?l.__k=[]:(s=l.props.children,k(n,Array.isArray(s)?s:[s],l,u,t,"foreignObject"!==l.type&&i,o,r,f,c)),c||("value"in d&&void 0!==(s=d.value)&&s!==n.value&&A(n,"value",s,y.value,!1),"checked"in d&&void 0!==(s=d.checked)&&s!==n.checked&&A(n,"checked",s,y.checked,!1))}return n}function j(l,u,t){try{"function"==typeof l?l(u):l.current=u}catch(l){n.__e(l,t)}}function H(l,u,t){var i,o,r;if(n.unmount&&n.unmount(l),(i=l.ref)&&(i.current&&i.current!==l.__e||j(i,null,u)),t||"function"==typeof l.type||(t=null!=(o=l.__e)),l.__e=l.__d=void 0,null!=(i=l.__c)){if(i.componentWillUnmount)try{i.componentWillUnmount()}catch(l){n.__e(l,u)}i.base=i.__P=null}if(i=l.__k)for(r=0;r<i.length;r++)i[r]&&H(i[r],u,t);null!=o&&a(o)}function I(n,l,u){return this.constructor(n,u)}function L(l,u,t){var i,r,c;n.__&&n.__(l,u),r=(i=t===o)?null:t&&t.__k||u.__k,l=p(h,null,[l]),c=[],N(u,(i?u:t||u).__k=l,r||f,f,void 0!==u.ownerSVGElement,t&&!i?[t]:r?null:u.childNodes.length?e.slice.call(u.childNodes):null,c,t||f,i),T(c,l)}n={__e:function(n,l){for(var u,t;l=l.__;)if((u=l.__c)&&!u.__)try{if(u.constructor&&null!=u.constructor.getDerivedStateFromError&&(t=!0,u.setState(u.constructor.getDerivedStateFromError(n))),null!=u.componentDidCatch&&(t=!0,u.componentDidCatch(n)),t)return w(u.__E=u)}catch(l){n=l}throw n}},l=function(n){return null!=n&&void 0===n.constructor},y.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=s({},this.state),"function"==typeof n&&(n=n(s({},u),this.props)),n&&s(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),w(this))},y.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),w(this))},y.prototype.render=h,u=[],t="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,x.__r=0,o=f,r=0,exports.render=L,exports.hydrate=function(n,l){L(n,l,o)},exports.createElement=p,exports.h=p,exports.Fragment=h,exports.createRef=function(){return{current:null}},exports.isValidElement=l,exports.Component=y,exports.cloneElement=function(n,l,u){var t,i,o,r=arguments,f=s({},n.props);for(o in l)"key"==o?t=l[o]:"ref"==o?i=l[o]:f[o]=l[o];if(arguments.length>3)for(u=[u],o=3;o<arguments.length;o++)u.push(r[o]);return null!=u&&(f.children=u),v(n.type,f,t||n.key,i||n.ref,null)},exports.createContext=function(n,l){var u={__c:l="__cC"+r++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n,u,t){return this.getChildContext||(u=[],(t={})[l]=this,this.getChildContext=function(){return t},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(w)},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u},exports.toChildArray=function n(l,u){return u=u||[],null==l||"boolean"==typeof l||(Array.isArray(l)?l.some(function(l){n(l,u)}):u.push(l)),u},exports.__u=H,exports.options=n;
 //# sourceMappingURL=preact.js.map
diff --git a/node_modules/preact/dist/preact.js.map b/node_modules/preact/dist/preact.js.map
index 920e586..880e8c1 100644
--- a/node_modules/preact/dist/preact.js.map
+++ b/node_modules/preact/dist/preact.js.map
@@ -1 +1 @@
-{"version":3,"file":"preact.js","sources":["../src/constants.js","../src/options.js","../src/create-element.js","../src/component.js","../src/render.js","../src/create-context.js","../src/util.js","../src/diff/children.js","../src/diff/props.js","../src/diff/index.js","../src/diff/catch-error.js","../src/clone-element.js"],"sourcesContent":["export const EMPTY_OBJ = {};\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n","import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n","import options from './options';\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * constructor for this virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\t// https://github.com/preactjs/preact/issues/1916\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\tif (children != null) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != null) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === undefined) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, null);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t// _nextDom must be initialized to undefined b/c it will eventually\n\t\t// be set to dom.nextSibling which can return `null` and it is important\n\t\t// to be able to distinguish between an uninitialized _nextDom and\n\t\t// a _nextDom that has been set to `null`\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\tconstructor: undefined,\n\t\t_original: original\n\t};\n\n\tif (original == null) vnode._original = vnode;\n\tif (options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is import('./internal').VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor === undefined;\n","import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function Component(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nComponent.prototype.setState = function(update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._vnode) {\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nComponent.prototype.forceUpdate = function(callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {import('./index').ComponentChildren | void}\n */\nComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._parent._children.indexOf(vnode) + 1)\n\t\t\t: null;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != null && sibling._dom != null) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : null;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {import('./internal').Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet vnode = component._vnode,\n\t\toldDom = vnode._dom,\n\t\tparentDom = component._parentDom;\n\n\tif (parentDom) {\n\t\tlet commitQueue = [];\n\t\tconst oldVNode = assign({}, vnode);\n\t\toldVNode._original = oldVNode;\n\n\t\tlet newDom = diff(\n\t\t\tparentDom,\n\t\t\tvnode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tparentDom.ownerSVGElement !== undefined,\n\t\t\tnull,\n\t\t\tcommitQueue,\n\t\t\toldDom == null ? getDomSibling(vnode) : oldDom\n\t\t);\n\t\tcommitRoot(commitQueue, vnode);\n\n\t\tif (newDom != oldDom) {\n\t\t\tupdateParentDomPointers(vnode);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./internal').VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != null && vnode._component != null) {\n\t\tvnode._dom = vnode._component.base = null;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != null && child._dom != null) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Component>}\n */\nlet rerenderQueue = [];\n\n/**\n * Asynchronously schedule a callback\n * @type {(cb: () => void) => void}\n */\n/* istanbul ignore next */\n// Note the following line isn't tree-shaken by rollup cuz of rollup/rollup#2566\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\n/**\n * Enqueue a rerender of a component\n * @param {import('./internal').Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet queue;\n\twhile ((process._rerenderCount = rerenderQueue.length)) {\n\t\tqueue = rerenderQueue.sort((a, b) => a._vnode._depth - b._vnode._depth);\n\t\trerenderQueue = [];\n\t\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t\t// process() calls from getting scheduled while `queue` is still being consumed.\n\t\tqueue.some(c => {\n\t\t\tif (c._dirty) renderComponent(c);\n\t\t});\n\t}\n}\nprocess._rerenderCount = 0;\n","import { EMPTY_OBJ, EMPTY_ARR } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\n\nconst IS_HYDRATE = EMPTY_OBJ;\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./index').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * render into\n * @param {Element | Text} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we\n\t// are in hydration mode or not by passing `IS_HYDRATE` instead of a\n\t// DOM element.\n\tlet isHydrating = replaceNode === IS_HYDRATE;\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? null\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\tvnode = createElement(Fragment, null, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\t((isHydrating ? parentDom : replaceNode || parentDom)._children = vnode),\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.ownerSVGElement !== undefined,\n\t\treplaceNode && !isHydrating\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t? null\n\t\t\t: parentDom.childNodes.length\n\t\t\t? EMPTY_ARR.slice.call(parentDom.childNodes)\n\t\t\t: null,\n\t\tcommitQueue,\n\t\treplaceNode || EMPTY_OBJ,\n\t\tisHydrating\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./index').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, IS_HYDRATE);\n}\n","import { enqueueRender } from './component';\n\nexport let i = 0;\n\nexport function createContext(defaultValue, contextId) {\n\tcontextId = '__cC' + i++;\n\n\tconst context = {\n\t\t_id: contextId,\n\t\t_defaultValue: defaultValue,\n\t\tConsumer(props, contextValue) {\n\t\t\t// return props.children(\n\t\t\t// \tcontext[contextId] ? context[contextId].props.value : defaultValue\n\t\t\t// );\n\t\t\treturn props.children(contextValue);\n\t\t},\n\t\tProvider(props, subs, ctx) {\n\t\t\tif (!this.getChildContext) {\n\t\t\t\tsubs = [];\n\t\t\t\tctx = {};\n\t\t\t\tctx[contextId] = this;\n\n\t\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\t\tthis.shouldComponentUpdate = function(_props) {\n\t\t\t\t\tif (this.props.value !== _props.value) {\n\t\t\t\t\t\t// I think the forced value propagation here was only needed when `options.debounceRendering` was being bypassed:\n\t\t\t\t\t\t// https://github.com/preactjs/preact/commit/4d339fb803bea09e9f198abf38ca1bf8ea4b7771#diff-54682ce380935a717e41b8bfc54737f6R358\n\t\t\t\t\t\t// In those cases though, even with the value corrected, we're double-rendering all nodes.\n\t\t\t\t\t\t// It might be better to just tell folks not to use force-sync mode.\n\t\t\t\t\t\t// Currently, using `useContext()` in a class component will overwrite its `this.context` value.\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context[contextId] = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\t\t\t\t\t\tsubs.some(enqueueRender);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.sub = c => {\n\t\t\t\t\tsubs.push(c);\n\t\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\t\tsubs.splice(subs.indexOf(c), 1);\n\t\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn props.children;\n\t\t}\n\t};\n\n\t// Devtools needs access to the context object when it\n\t// encounters a Provider. This is necessary to support\n\t// setting `displayName` on the context object instead\n\t// of on the component itself. See:\n\t// https://reactjs.org/docs/context.html#contextdisplayname\n\n\treturn (context.Provider._contextRef = context.Consumer.contextType = context);\n}\n","/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {Node} node The node to remove\n */\nexport function removeNode(node) {\n\tlet parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n","import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { removeNode } from '../util';\nimport { getDomSibling } from '../component';\n\n/**\n * Diff the children of a virtual node\n * @param {import('../internal').PreactElement} parentDom The DOM element whose\n * children are being diffed\n * @param {import('../index').ComponentChildren[]} renderResult\n * @param {import('../internal').VNode} newParentVNode The new virtual\n * node whose children should be diff'ed against oldParentVNode\n * @param {import('../internal').VNode} oldParentVNode The old virtual\n * node whose children should be diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by getChildContext\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {Node | Text} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet i, j, oldVNode, childVNode, newDom, firstChildDom, refs;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet oldChildrenLength = oldChildren.length;\n\n\t// Only in very specific places should this logic be invoked (top level `render` and `diffElementNodes`).\n\t// I'm using `EMPTY_OBJ` to signal when `diffChildren` is invoked in these situations. I can't use `null`\n\t// for this purpose, because `null` is a valid value for `oldDom` which can mean to skip to this logic\n\t// (e.g. if mounting a new tree in which the old DOM should be ignored (usually for Fragments).\n\tif (oldDom == EMPTY_OBJ) {\n\t\tif (excessDomChildren != null) {\n\t\t\toldDom = excessDomChildren[0];\n\t\t} else if (oldChildrenLength) {\n\t\t\toldDom = getDomSibling(oldParentVNode, 0);\n\t\t} else {\n\t\t\toldDom = null;\n\t\t}\n\t}\n\n\tnewParentVNode._children = [];\n\tfor (i = 0; i < renderResult.length; i++) {\n\t\tchildVNode = renderResult[i];\n\n\t\tif (childVNode == null || typeof childVNode == 'boolean') {\n\t\t\tchildVNode = newParentVNode._children[i] = null;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (typeof childVNode == 'string' || typeof childVNode == 'number') {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tnull,\n\t\t\t\tchildVNode,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t} else if (Array.isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (childVNode._dom != null || childVNode._component != null) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tnull,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\t// Terser removes the `continue` here and wraps the loop body\n\t\t// in a `if (childVNode) { ... } condition\n\t\tif (childVNode == null) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\t// Check if we find a corresponding element in oldChildren.\n\t\t// If found, delete the array item by setting to `undefined`.\n\t\t// We use `undefined`, as `null` is reserved for empty placeholders\n\t\t// (holes).\n\t\toldVNode = oldChildren[i];\n\n\t\tif (\n\t\t\toldVNode === null ||\n\t\t\t(oldVNode &&\n\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\tchildVNode.type === oldVNode.type)\n\t\t) {\n\t\t\toldChildren[i] = undefined;\n\t\t} else {\n\t\t\t// Either oldVNode === undefined or oldChildrenLength > 0,\n\t\t\t// so after this loop oldVNode == null or oldVNode is a valid value.\n\t\t\tfor (j = 0; j < oldChildrenLength; j++) {\n\t\t\t\toldVNode = oldChildren[j];\n\t\t\t\t// If childVNode is unkeyed, we only match similarly unkeyed nodes, otherwise we match by key.\n\t\t\t\t// We always match by type (in either case).\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\t\tchildVNode.type === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\toldChildren[j] = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\toldVNode = null;\n\t\t\t}\n\t\t}\n\n\t\toldVNode = oldVNode || EMPTY_OBJ;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tnewDom = diff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tisSvg,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating\n\t\t);\n\n\t\tif ((j = childVNode.ref) && oldVNode.ref != j) {\n\t\t\tif (!refs) refs = [];\n\t\t\tif (oldVNode.ref) refs.push(oldVNode.ref, null, childVNode);\n\t\t\trefs.push(j, childVNode._component || newDom, childVNode);\n\t\t}\n\n\t\tif (newDom != null) {\n\t\t\tif (firstChildDom == null) {\n\t\t\t\tfirstChildDom = newDom;\n\t\t\t}\n\n\t\t\toldDom = placeChild(\n\t\t\t\tparentDom,\n\t\t\t\tchildVNode,\n\t\t\t\toldVNode,\n\t\t\t\toldChildren,\n\t\t\t\texcessDomChildren,\n\t\t\t\tnewDom,\n\t\t\t\toldDom\n\t\t\t);\n\n\t\t\t// Browsers will infer an option's `value` from `textContent` when\n\t\t\t// no value is present. This essentially bypasses our code to set it\n\t\t\t// later in `diff()`. It works fine in all browsers except for IE11\n\t\t\t// where it breaks setting `select.value`. There it will be always set\n\t\t\t// to an empty string. Re-applying an options value will fix that, so\n\t\t\t// there are probably some internal data structures that aren't\n\t\t\t// updated properly.\n\t\t\t//\n\t\t\t// To fix it we make sure to reset the inferred value, so that our own\n\t\t\t// value check in `diff()` won't be skipped.\n\t\t\tif (!isHydrating && newParentVNode.type == 'option') {\n\t\t\t\tparentDom.value = '';\n\t\t\t} else if (typeof newParentVNode.type == 'function') {\n\t\t\t\t// Because the newParentVNode is Fragment-like, we need to set it's\n\t\t\t\t// _nextDom property to the nextSibling of its last child DOM node.\n\t\t\t\t//\n\t\t\t\t// `oldDom` contains the correct value here because if the last child\n\t\t\t\t// is a Fragment-like, then oldDom has already been set to that child's _nextDom.\n\t\t\t\t// If the last child is a DOM VNode, then oldDom will be set to that DOM\n\t\t\t\t// node's nextSibling.\n\t\t\t\tnewParentVNode._nextDom = oldDom;\n\t\t\t}\n\t\t} else if (\n\t\t\toldDom &&\n\t\t\toldVNode._dom == oldDom &&\n\t\t\toldDom.parentNode != parentDom\n\t\t) {\n\t\t\t// The above condition is to handle null placeholders. See test in placeholder.test.js:\n\t\t\t// `efficiently replace null placeholders in parent rerenders`\n\t\t\toldDom = getDomSibling(oldVNode);\n\t\t}\n\t}\n\n\tnewParentVNode._dom = firstChildDom;\n\n\t// Remove children that are not part of any vnode.\n\tif (excessDomChildren != null && typeof newParentVNode.type != 'function') {\n\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\tif (excessDomChildren[i] != null) removeNode(excessDomChildren[i]);\n\t\t}\n\t}\n\n\t// Remove remaining oldChildren if there are any.\n\tfor (i = oldChildrenLength; i--; ) {\n\t\tif (oldChildren[i] != null) unmount(oldChildren[i], oldChildren[i]);\n\t}\n\n\t// Set refs only after unmount\n\tif (refs) {\n\t\tfor (i = 0; i < refs.length; i++) {\n\t\t\tapplyRef(refs[i], refs[++i], refs[++i]);\n\t\t}\n\t}\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {import('../index').ComponentChildren} children The unflattened\n * children of a virtual node\n * @returns {import('../internal').VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (Array.isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\nexport function placeChild(\n\tparentDom,\n\tchildVNode,\n\toldVNode,\n\toldChildren,\n\texcessDomChildren,\n\tnewDom,\n\toldDom\n) {\n\tlet nextDom;\n\tif (childVNode._nextDom !== undefined) {\n\t\t// Only Fragments or components that return Fragment like VNodes will\n\t\t// have a non-undefined _nextDom. Continue the diff from the sibling\n\t\t// of last DOM child of this child VNode\n\t\tnextDom = childVNode._nextDom;\n\n\t\t// Eagerly cleanup _nextDom. We don't need to persist the value because\n\t\t// it is only used by `diffChildren` to determine where to resume the diff after\n\t\t// diffing Components and Fragments. Once we store it the nextDOM local var, we\n\t\t// can clean up the property\n\t\tchildVNode._nextDom = undefined;\n\t} else if (\n\t\texcessDomChildren == oldVNode ||\n\t\tnewDom != oldDom ||\n\t\tnewDom.parentNode == null\n\t) {\n\t\t// NOTE: excessDomChildren==oldVNode above:\n\t\t// This is a compression of excessDomChildren==null && oldVNode==null!\n\t\t// The values only have the same type when `null`.\n\n\t\touter: if (oldDom == null || oldDom.parentNode !== parentDom) {\n\t\t\tparentDom.appendChild(newDom);\n\t\t\tnextDom = null;\n\t\t} else {\n\t\t\t// `j<oldChildrenLength; j+=2` is an alternative to `j++<oldChildrenLength/2`\n\t\t\tfor (\n\t\t\t\tlet sibDom = oldDom, j = 0;\n\t\t\t\t(sibDom = sibDom.nextSibling) && j < oldChildren.length;\n\t\t\t\tj += 2\n\t\t\t) {\n\t\t\t\tif (sibDom == newDom) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparentDom.insertBefore(newDom, oldDom);\n\t\t\tnextDom = oldDom;\n\t\t}\n\t}\n\n\t// If we have pre-calculated the nextDOM node, use it. Else calculate it now\n\t// Strictly check for `undefined` here cuz `null` is a valid value of `nextDom`.\n\t// See more detail in create-element.js:createVNode\n\tif (nextDom !== undefined) {\n\t\toldDom = nextDom;\n\t} else {\n\t\toldDom = newDom.nextSibling;\n\t}\n\n\treturn oldDom;\n}\n","import { IS_NON_DIMENSIONAL } from '../constants';\nimport options from '../options';\n\n/**\n * Diff the old and new properties of a VNode and apply changes to the DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to apply\n * changes to\n * @param {object} newProps The new props\n * @param {object} oldProps The old props\n * @param {boolean} isSvg Whether or not this node is an SVG node\n * @param {boolean} hydrate Whether or not we are in hydration mode\n */\nexport function diffProps(dom, newProps, oldProps, isSvg, hydrate) {\n\tlet i;\n\n\tfor (i in oldProps) {\n\t\tif (i !== 'children' && i !== 'key' && !(i in newProps)) {\n\t\t\tsetProperty(dom, i, null, oldProps[i], isSvg);\n\t\t}\n\t}\n\n\tfor (i in newProps) {\n\t\tif (\n\t\t\t(!hydrate || typeof newProps[i] == 'function') &&\n\t\t\ti !== 'children' &&\n\t\t\ti !== 'key' &&\n\t\t\ti !== 'value' &&\n\t\t\ti !== 'checked' &&\n\t\t\toldProps[i] !== newProps[i]\n\t\t) {\n\t\t\tsetProperty(dom, i, newProps[i], oldProps[i], isSvg);\n\t\t}\n\t}\n}\n\nfunction setStyle(style, key, value) {\n\t// if (!(key in style)) {  // -3b\n\t// if (key < '.') {  // -1b\n\tif (key[0] === '-') {\n\t\tstyle.setProperty(key, value);\n\t} else if (value == null) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, isSvg) {\n\tlet useCapture, nameLower;\n\n\tif (isSvg && name == 'className') name = 'class';\n\n\t// if (isSvg) {\n\t// \tif (name === 'className') name = 'class';\n\t// } else if (name === 'class') name += 'Name';\n\n\tif (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture = name !== (name = name.replace(/Capture$/, ''));\n\t\tnameLower = name.toLowerCase();\n\t\tif (nameLower in dom) name = nameLower;\n\t\tname = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) dom.addEventListener(name, eventProxy, useCapture);\n\t\t} else {\n\t\t\tdom.removeEventListener(name, eventProxy, useCapture);\n\t\t}\n\t} else if (\n\t\tname !== 'list' &&\n\t\tname !== 'tagName' &&\n\t\t// HTMLButtonElement.form and HTMLInputElement.form are read-only but can be set using\n\t\t// setAttribute\n\t\tname !== 'form' &&\n\t\tname !== 'type' &&\n\t\tname !== 'size' &&\n\t\tname !== 'download' &&\n\t\tname !== 'href' &&\n\t\t!isSvg &&\n\t\tname in dom\n\t) {\n\t\tdom[name] = value == null ? '' : value;\n\t} else if (typeof value != 'function' && name !== 'dangerouslySetInnerHTML') {\n\t\tif (name !== (name = name.replace(/xlink:?/, ''))) {\n\t\t\tif (value == null || value === false) {\n\t\t\t\tdom.removeAttributeNS(\n\t\t\t\t\t'http://www.w3.org/1999/xlink',\n\t\t\t\t\tname.toLowerCase()\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tdom.setAttributeNS(\n\t\t\t\t\t'http://www.w3.org/1999/xlink',\n\t\t\t\t\tname.toLowerCase(),\n\t\t\t\t\tvalue\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (\n\t\t\tvalue == null ||\n\t\t\t(value === false &&\n\t\t\t\t// ARIA-attributes have a different notion of boolean values.\n\t\t\t\t// The value `false` is different from the attribute not\n\t\t\t\t// existing on the DOM, so we can't remove it. For non-boolean\n\t\t\t\t// ARIA-attributes we could treat false as a removal, but the\n\t\t\t\t// amount of exceptions would cost us too many bytes. On top of\n\t\t\t\t// that other VDOM frameworks also always stringify `false`.\n\t\t\t\t!/^ar/.test(name))\n\t\t) {\n\t\t\tdom.removeAttribute(name);\n\t\t} else {\n\t\t\tdom.setAttribute(name, value);\n\t\t}\n\t}\n}\n\n/**\n * Proxy an event to hooked event handlers\n * @param {Event} e The event object from the browser\n * @private\n */\nfunction eventProxy(e) {\n\tthis._listeners[e.type](options.event ? options.event(e) : e);\n}\n","import { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { Component } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren, placeChild } from './children';\nimport { diffProps, setProperty } from './props';\nimport { assign, removeNode } from '../util';\nimport options from '../options';\n\nfunction reorderChildren(newVNode, oldDom, parentDom) {\n\tfor (let tmp = 0; tmp < newVNode._children.length; tmp++) {\n\t\tconst vnode = newVNode._children[tmp];\n\t\tif (vnode) {\n\t\t\tvnode._parent = newVNode;\n\n\t\t\tif (vnode._dom) {\n\t\t\t\tif (typeof vnode.type == 'function' && vnode._children.length > 1) {\n\t\t\t\t\treorderChildren(vnode, oldDom, parentDom);\n\t\t\t\t}\n\n\t\t\t\toldDom = placeChild(\n\t\t\t\t\tparentDom,\n\t\t\t\t\tvnode,\n\t\t\t\t\tvnode,\n\t\t\t\t\tnewVNode._children,\n\t\t\t\t\tnull,\n\t\t\t\t\tvnode._dom,\n\t\t\t\t\toldDom\n\t\t\t\t);\n\n\t\t\t\tif (typeof newVNode.type == 'function') {\n\t\t\t\t\tnewVNode._nextDom = oldDom;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').PreactElement} parentDom The parent of the DOM element\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by getChildContext\n * @param {boolean} isSvg Whether or not this element is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {Element | Text} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} [isHydrating] Whether or not we are in hydration\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== undefined) return null;\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\ttry {\n\t\touter: if (typeof newType == 'function') {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif ('prototype' in newType && newType.prototype.render) {\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\tnewVNode._component = c = new Component(newProps, componentContext);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (c._nextState == null) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\t\t\tif (newType.getDerivedStateFromProps != null) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tc.componentWillMount != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidMount != null) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(!c._force &&\n\t\t\t\t\t\tc.shouldComponentUpdate != null &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\tnewVNode._original === oldVNode._original\n\t\t\t\t) {\n\t\t\t\t\tc.props = newProps;\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original !== oldVNode._original) c._dirty = false;\n\t\t\t\t\tc._vnode = newVNode;\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\treorderChildren(newVNode, oldDom, parentDom);\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != null) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidUpdate != null) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc.state = c._nextState;\n\n\t\t\tif ((tmp = options._render)) tmp(newVNode);\n\n\t\t\tc._dirty = false;\n\t\t\tc._vnode = newVNode;\n\t\t\tc._parentDom = parentDom;\n\n\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != null) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (!isNew && c.getSnapshotBeforeUpdate != null) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != null && tmp.type == Fragment && tmp.key == null;\n\t\t\tlet renderResult = isTopLevelFragment ? tmp.props.children : tmp;\n\n\t\t\tdiffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tArray.isArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = null;\n\t\t\t}\n\n\t\t\tc._force = false;\n\t\t} else if (\n\t\t\texcessDomChildren == null &&\n\t\t\tnewVNode._original === oldVNode._original\n\t\t) {\n\t\t\tnewVNode._children = oldVNode._children;\n\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t} else {\n\t\t\tnewVNode._dom = diffElementNodes(\n\t\t\t\toldVNode._dom,\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\tif ((tmp = options.diffed)) tmp(newVNode);\n\t} catch (e) {\n\t\tnewVNode._original = null;\n\t\toptions._catchError(e, newVNode, oldVNode);\n\t}\n\n\treturn newVNode._dom;\n}\n\n/**\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').VNode} root\n */\nexport function commitRoot(commitQueue, root) {\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {import('../internal').PreactElement} dom The DOM element representing\n * the virtual nodes being diffed\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {*} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @returns {import('../internal').PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating\n) {\n\tlet i;\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\n\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\tisSvg = newVNode.type === 'svg' || isSvg;\n\n\tif (excessDomChildren != null) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tconst child = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tchild != null &&\n\t\t\t\t((newVNode.type === null\n\t\t\t\t\t? child.nodeType === 3\n\t\t\t\t\t: child.localName === newVNode.type) ||\n\t\t\t\t\tdom == child)\n\t\t\t) {\n\t\t\t\tdom = child;\n\t\t\t\texcessDomChildren[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == null) {\n\t\tif (newVNode.type === null) {\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tdom = isSvg\n\t\t\t? document.createElementNS('http://www.w3.org/2000/svg', newVNode.type)\n\t\t\t: document.createElement(\n\t\t\t\t\tnewVNode.type,\n\t\t\t\t\tnewProps.is && { is: newProps.is }\n\t\t\t  );\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = null;\n\t\t// we are creating a new node, so we can assume this is a new subtree (in case we are hydrating), this deopts the hydrate\n\t\tisHydrating = false;\n\t}\n\n\tif (newVNode.type === null) {\n\t\tif (oldProps !== newProps && dom.data !== newProps) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\tif (excessDomChildren != null) {\n\t\t\texcessDomChildren = EMPTY_ARR.slice.call(dom.childNodes);\n\t\t}\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\tlet oldHtml = oldProps.dangerouslySetInnerHTML;\n\t\tlet newHtml = newProps.dangerouslySetInnerHTML;\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tif (!isHydrating) {\n\t\t\t// But, if we are in a situation where we are using existing DOM (e.g. replaceNode)\n\t\t\t// we should read the existing DOM attributes to diff them\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\toldProps = {};\n\t\t\t\tfor (let i = 0; i < dom.attributes.length; i++) {\n\t\t\t\t\toldProps[dom.attributes[i].name] = dom.attributes[i].value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (newHtml || oldHtml) {\n\t\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\t\tif (!newHtml || !oldHtml || newHtml.__html != oldHtml.__html) {\n\t\t\t\t\tdom.innerHTML = (newHtml && newHtml.__html) || '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdiffProps(dom, newProps, oldProps, isSvg, isHydrating);\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\ti = newVNode.props.children;\n\t\t\tdiffChildren(\n\t\t\t\tdom,\n\t\t\t\tArray.isArray(i) ? i : [i],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnewVNode.type === 'foreignObject' ? false : isSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tEMPTY_OBJ,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\t// (as above, don't diff props during hydration)\n\t\tif (!isHydrating) {\n\t\t\tif (\n\t\t\t\t'value' in newProps &&\n\t\t\t\t(i = newProps.value) !== undefined &&\n\t\t\t\ti !== dom.value\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'value', i, oldProps.value, false);\n\t\t\t}\n\t\t\tif (\n\t\t\t\t'checked' in newProps &&\n\t\t\t\t(i = newProps.checked) !== undefined &&\n\t\t\t\ti !== dom.checked\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'checked', i, oldProps.checked, false);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {object|function} ref\n * @param {any} value\n * @param {import('../internal').VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') ref(value);\n\t\telse ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {import('../internal').VNode} vnode The virtual node to unmount\n * @param {import('../internal').VNode} parentVNode The parent of the VNode that\n * initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current === vnode._dom) applyRef(r, null, parentVNode);\n\t}\n\n\tlet dom;\n\tif (!skipRemove && typeof vnode.type != 'function') {\n\t\tskipRemove = (dom = vnode._dom) != null;\n\t}\n\n\t// Must be set to `undefined` to properly clean up `_nextDom`\n\t// for which `null` is a valid value. See comment in `create-element.js`\n\tvnode._dom = vnode._nextDom = undefined;\n\n\tif ((r = vnode._component) != null) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = null;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) unmount(r[i], parentVNode, skipRemove);\n\t\t}\n\t}\n\n\tif (dom != null) removeNode(dom);\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n","import { enqueueRender } from '../component';\n\n/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').VNode} vnode The vnode that threw\n * the error that was caught (except for unmounting when this parameter\n * is the highest parent that was being unmounted)\n */\nexport function _catchError(error, vnode) {\n\t/** @type {import('../internal').Component} */\n\tlet component, hasCaught;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tif (\n\t\t\t\t\tcomponent.constructor &&\n\t\t\t\t\tcomponent.constructor.getDerivedStateFromError != null\n\t\t\t\t) {\n\t\t\t\t\thasCaught = true;\n\t\t\t\t\tcomponent.setState(\n\t\t\t\t\t\tcomponent.constructor.getDerivedStateFromError(error)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != null) {\n\t\t\t\t\thasCaught = true;\n\t\t\t\t\tcomponent.componentDidCatch(error);\n\t\t\t\t}\n\n\t\t\t\tif (hasCaught)\n\t\t\t\t\treturn enqueueRender((component._pendingError = component));\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n","import { assign } from './util';\nimport { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./index').ComponentChildren>} rest Any additional arguments will be used as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\tif (children != null) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tnull\n\t);\n}\n"],"names":["options","isValidElement","rerenderQueue","defer","prevDebounce","IS_HYDRATE","i","EMPTY_OBJ","EMPTY_ARR","IS_NON_DIMENSIONAL","assign","obj","props","removeNode","node","parentNode","removeChild","createElement","type","children","key","ref","normalizedProps","arguments","length","push","defaultProps","undefined","createVNode","original","vnode","constructor","Fragment","Component","context","getDomSibling","childIndex","indexOf","sibling","updateParentDomPointers","child","base","enqueueRender","c","process","debounceRendering","queue","sort","a","b","some","component","commitQueue","oldVNode","newDom","oldDom","parentDom","diff","ownerSVGElement","commitRoot","diffChildren","renderResult","newParentVNode","oldParentVNode","globalContext","isSvg","excessDomChildren","isHydrating","j","childVNode","firstChildDom","refs","oldChildren","oldChildrenLength","Array","isArray","placeChild","value","unmount","applyRef","nextDom","sibDom","outer","appendChild","nextSibling","insertBefore","diffProps","dom","newProps","oldProps","hydrate","setProperty","setStyle","style","test","name","oldValue","useCapture","nameLower","replace","toLowerCase","slice","_listeners","addEventListener","eventProxy","removeEventListener","removeAttributeNS","setAttributeNS","removeAttribute","setAttribute","e","event","reorderChildren","newVNode","tmp","isNew","oldState","snapshot","clearProcessingException","provider","componentContext","newType","contextType","prototype","render","doRender","sub","state","getDerivedStateFromProps","componentWillMount","componentDidMount","componentWillReceiveProps","shouldComponentUpdate","componentWillUpdate","componentDidUpdate","getChildContext","getSnapshotBeforeUpdate","diffElementNodes","diffed","root","cb","call","oldHtml","newHtml","nodeType","localName","document","createTextNode","createElementNS","is","data","childNodes","dangerouslySetInnerHTML","attributes","innerHTML","checked","current","parentVNode","skipRemove","r","componentWillUnmount","this","replaceNode","error","hasCaught","getDerivedStateFromError","setState","componentDidCatch","update","callback","s","forceUpdate","Promise","then","bind","resolve","setTimeout","defaultValue","contextId","Consumer","contextValue","Provider","subs","ctx","_props","old","splice","toChildArray","out"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"preact.js","sources":["../src/constants.js","../src/options.js","../src/create-element.js","../src/component.js","../src/render.js","../src/create-context.js","../src/util.js","../src/diff/children.js","../src/diff/props.js","../src/diff/index.js","../src/diff/catch-error.js","../src/clone-element.js"],"sourcesContent":["export const EMPTY_OBJ = {};\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n","import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n","import options from './options';\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * constructor for this virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\t// https://github.com/preactjs/preact/issues/1916\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\tif (children != null) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != null) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === undefined) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, null);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t// _nextDom must be initialized to undefined b/c it will eventually\n\t\t// be set to dom.nextSibling which can return `null` and it is important\n\t\t// to be able to distinguish between an uninitialized _nextDom and\n\t\t// a _nextDom that has been set to `null`\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\tconstructor: undefined,\n\t\t_original: original\n\t};\n\n\tif (original == null) vnode._original = vnode;\n\tif (options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is import('./internal').VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor === undefined;\n","import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function Component(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nComponent.prototype.setState = function(update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._vnode) {\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nComponent.prototype.forceUpdate = function(callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {import('./index').ComponentChildren | void}\n */\nComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._parent._children.indexOf(vnode) + 1)\n\t\t\t: null;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != null && sibling._dom != null) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : null;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {import('./internal').Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet vnode = component._vnode,\n\t\toldDom = vnode._dom,\n\t\tparentDom = component._parentDom;\n\n\tif (parentDom) {\n\t\tlet commitQueue = [];\n\t\tconst oldVNode = assign({}, vnode);\n\t\toldVNode._original = oldVNode;\n\n\t\tlet newDom = diff(\n\t\t\tparentDom,\n\t\t\tvnode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tparentDom.ownerSVGElement !== undefined,\n\t\t\tnull,\n\t\t\tcommitQueue,\n\t\t\toldDom == null ? getDomSibling(vnode) : oldDom\n\t\t);\n\t\tcommitRoot(commitQueue, vnode);\n\n\t\tif (newDom != oldDom) {\n\t\t\tupdateParentDomPointers(vnode);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./internal').VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != null && vnode._component != null) {\n\t\tvnode._dom = vnode._component.base = null;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != null && child._dom != null) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Component>}\n */\nlet rerenderQueue = [];\n\n/**\n * Asynchronously schedule a callback\n * @type {(cb: () => void) => void}\n */\n/* istanbul ignore next */\n// Note the following line isn't tree-shaken by rollup cuz of rollup/rollup#2566\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\n/**\n * Enqueue a rerender of a component\n * @param {import('./internal').Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet queue;\n\twhile ((process._rerenderCount = rerenderQueue.length)) {\n\t\tqueue = rerenderQueue.sort((a, b) => a._vnode._depth - b._vnode._depth);\n\t\trerenderQueue = [];\n\t\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t\t// process() calls from getting scheduled while `queue` is still being consumed.\n\t\tqueue.some(c => {\n\t\t\tif (c._dirty) renderComponent(c);\n\t\t});\n\t}\n}\nprocess._rerenderCount = 0;\n","import { EMPTY_OBJ, EMPTY_ARR } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\n\nconst IS_HYDRATE = EMPTY_OBJ;\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./index').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * render into\n * @param {Element | Text} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we\n\t// are in hydration mode or not by passing `IS_HYDRATE` instead of a\n\t// DOM element.\n\tlet isHydrating = replaceNode === IS_HYDRATE;\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? null\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\tvnode = createElement(Fragment, null, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\t((isHydrating ? parentDom : replaceNode || parentDom)._children = vnode),\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.ownerSVGElement !== undefined,\n\t\treplaceNode && !isHydrating\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t? null\n\t\t\t: parentDom.childNodes.length\n\t\t\t? EMPTY_ARR.slice.call(parentDom.childNodes)\n\t\t\t: null,\n\t\tcommitQueue,\n\t\treplaceNode || EMPTY_OBJ,\n\t\tisHydrating\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./index').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, IS_HYDRATE);\n}\n","import { enqueueRender } from './component';\n\nexport let i = 0;\n\nexport function createContext(defaultValue, contextId) {\n\tcontextId = '__cC' + i++;\n\n\tconst context = {\n\t\t_id: contextId,\n\t\t_defaultValue: defaultValue,\n\t\tConsumer(props, contextValue) {\n\t\t\t// return props.children(\n\t\t\t// \tcontext[contextId] ? context[contextId].props.value : defaultValue\n\t\t\t// );\n\t\t\treturn props.children(contextValue);\n\t\t},\n\t\tProvider(props, subs, ctx) {\n\t\t\tif (!this.getChildContext) {\n\t\t\t\tsubs = [];\n\t\t\t\tctx = {};\n\t\t\t\tctx[contextId] = this;\n\n\t\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\t\tthis.shouldComponentUpdate = function(_props) {\n\t\t\t\t\tif (this.props.value !== _props.value) {\n\t\t\t\t\t\t// I think the forced value propagation here was only needed when `options.debounceRendering` was being bypassed:\n\t\t\t\t\t\t// https://github.com/preactjs/preact/commit/4d339fb803bea09e9f198abf38ca1bf8ea4b7771#diff-54682ce380935a717e41b8bfc54737f6R358\n\t\t\t\t\t\t// In those cases though, even with the value corrected, we're double-rendering all nodes.\n\t\t\t\t\t\t// It might be better to just tell folks not to use force-sync mode.\n\t\t\t\t\t\t// Currently, using `useContext()` in a class component will overwrite its `this.context` value.\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context[contextId] = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\t\t\t\t\t\tsubs.some(enqueueRender);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.sub = c => {\n\t\t\t\t\tsubs.push(c);\n\t\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\t\tsubs.splice(subs.indexOf(c), 1);\n\t\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn props.children;\n\t\t}\n\t};\n\n\t// Devtools needs access to the context object when it\n\t// encounters a Provider. This is necessary to support\n\t// setting `displayName` on the context object instead\n\t// of on the component itself. See:\n\t// https://reactjs.org/docs/context.html#contextdisplayname\n\n\treturn (context.Provider._contextRef = context.Consumer.contextType = context);\n}\n","/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {Node} node The node to remove\n */\nexport function removeNode(node) {\n\tlet parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n","import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { removeNode } from '../util';\nimport { getDomSibling } from '../component';\n\n/**\n * Diff the children of a virtual node\n * @param {import('../internal').PreactElement} parentDom The DOM element whose\n * children are being diffed\n * @param {import('../index').ComponentChildren[]} renderResult\n * @param {import('../internal').VNode} newParentVNode The new virtual\n * node whose children should be diff'ed against oldParentVNode\n * @param {import('../internal').VNode} oldParentVNode The old virtual\n * node whose children should be diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by getChildContext\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {Node | Text} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet i, j, oldVNode, childVNode, newDom, firstChildDom, refs;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet oldChildrenLength = oldChildren.length;\n\n\t// Only in very specific places should this logic be invoked (top level `render` and `diffElementNodes`).\n\t// I'm using `EMPTY_OBJ` to signal when `diffChildren` is invoked in these situations. I can't use `null`\n\t// for this purpose, because `null` is a valid value for `oldDom` which can mean to skip to this logic\n\t// (e.g. if mounting a new tree in which the old DOM should be ignored (usually for Fragments).\n\tif (oldDom == EMPTY_OBJ) {\n\t\tif (excessDomChildren != null) {\n\t\t\toldDom = excessDomChildren[0];\n\t\t} else if (oldChildrenLength) {\n\t\t\toldDom = getDomSibling(oldParentVNode, 0);\n\t\t} else {\n\t\t\toldDom = null;\n\t\t}\n\t}\n\n\tnewParentVNode._children = [];\n\tfor (i = 0; i < renderResult.length; i++) {\n\t\tchildVNode = renderResult[i];\n\n\t\tif (childVNode == null || typeof childVNode == 'boolean') {\n\t\t\tchildVNode = newParentVNode._children[i] = null;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (typeof childVNode == 'string' || typeof childVNode == 'number') {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tnull,\n\t\t\t\tchildVNode,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t} else if (Array.isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (childVNode._dom != null || childVNode._component != null) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tnull,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\t// Terser removes the `continue` here and wraps the loop body\n\t\t// in a `if (childVNode) { ... } condition\n\t\tif (childVNode == null) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\t// Check if we find a corresponding element in oldChildren.\n\t\t// If found, delete the array item by setting to `undefined`.\n\t\t// We use `undefined`, as `null` is reserved for empty placeholders\n\t\t// (holes).\n\t\toldVNode = oldChildren[i];\n\n\t\tif (\n\t\t\toldVNode === null ||\n\t\t\t(oldVNode &&\n\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\tchildVNode.type === oldVNode.type)\n\t\t) {\n\t\t\toldChildren[i] = undefined;\n\t\t} else {\n\t\t\t// Either oldVNode === undefined or oldChildrenLength > 0,\n\t\t\t// so after this loop oldVNode == null or oldVNode is a valid value.\n\t\t\tfor (j = 0; j < oldChildrenLength; j++) {\n\t\t\t\toldVNode = oldChildren[j];\n\t\t\t\t// If childVNode is unkeyed, we only match similarly unkeyed nodes, otherwise we match by key.\n\t\t\t\t// We always match by type (in either case).\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\t\tchildVNode.type === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\toldChildren[j] = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\toldVNode = null;\n\t\t\t}\n\t\t}\n\n\t\toldVNode = oldVNode || EMPTY_OBJ;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tnewDom = diff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tisSvg,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating\n\t\t);\n\n\t\tif ((j = childVNode.ref) && oldVNode.ref != j) {\n\t\t\tif (!refs) refs = [];\n\t\t\tif (oldVNode.ref) refs.push(oldVNode.ref, null, childVNode);\n\t\t\trefs.push(j, childVNode._component || newDom, childVNode);\n\t\t}\n\n\t\tif (newDom != null) {\n\t\t\tif (firstChildDom == null) {\n\t\t\t\tfirstChildDom = newDom;\n\t\t\t}\n\n\t\t\toldDom = placeChild(\n\t\t\t\tparentDom,\n\t\t\t\tchildVNode,\n\t\t\t\toldVNode,\n\t\t\t\toldChildren,\n\t\t\t\texcessDomChildren,\n\t\t\t\tnewDom,\n\t\t\t\toldDom\n\t\t\t);\n\n\t\t\t// Browsers will infer an option's `value` from `textContent` when\n\t\t\t// no value is present. This essentially bypasses our code to set it\n\t\t\t// later in `diff()`. It works fine in all browsers except for IE11\n\t\t\t// where it breaks setting `select.value`. There it will be always set\n\t\t\t// to an empty string. Re-applying an options value will fix that, so\n\t\t\t// there are probably some internal data structures that aren't\n\t\t\t// updated properly.\n\t\t\t//\n\t\t\t// To fix it we make sure to reset the inferred value, so that our own\n\t\t\t// value check in `diff()` won't be skipped.\n\t\t\tif (!isHydrating && newParentVNode.type == 'option') {\n\t\t\t\tparentDom.value = '';\n\t\t\t} else if (typeof newParentVNode.type == 'function') {\n\t\t\t\t// Because the newParentVNode is Fragment-like, we need to set it's\n\t\t\t\t// _nextDom property to the nextSibling of its last child DOM node.\n\t\t\t\t//\n\t\t\t\t// `oldDom` contains the correct value here because if the last child\n\t\t\t\t// is a Fragment-like, then oldDom has already been set to that child's _nextDom.\n\t\t\t\t// If the last child is a DOM VNode, then oldDom will be set to that DOM\n\t\t\t\t// node's nextSibling.\n\t\t\t\tnewParentVNode._nextDom = oldDom;\n\t\t\t}\n\t\t} else if (\n\t\t\toldDom &&\n\t\t\toldVNode._dom == oldDom &&\n\t\t\toldDom.parentNode != parentDom\n\t\t) {\n\t\t\t// The above condition is to handle null placeholders. See test in placeholder.test.js:\n\t\t\t// `efficiently replace null placeholders in parent rerenders`\n\t\t\toldDom = getDomSibling(oldVNode);\n\t\t}\n\t}\n\n\tnewParentVNode._dom = firstChildDom;\n\n\t// Remove children that are not part of any vnode.\n\tif (excessDomChildren != null && typeof newParentVNode.type != 'function') {\n\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\tif (excessDomChildren[i] != null) removeNode(excessDomChildren[i]);\n\t\t}\n\t}\n\n\t// Remove remaining oldChildren if there are any.\n\tfor (i = oldChildrenLength; i--; ) {\n\t\tif (oldChildren[i] != null) unmount(oldChildren[i], oldChildren[i]);\n\t}\n\n\t// Set refs only after unmount\n\tif (refs) {\n\t\tfor (i = 0; i < refs.length; i++) {\n\t\t\tapplyRef(refs[i], refs[++i], refs[++i]);\n\t\t}\n\t}\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {import('../index').ComponentChildren} children The unflattened\n * children of a virtual node\n * @returns {import('../internal').VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (Array.isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\nexport function placeChild(\n\tparentDom,\n\tchildVNode,\n\toldVNode,\n\toldChildren,\n\texcessDomChildren,\n\tnewDom,\n\toldDom\n) {\n\tlet nextDom;\n\tif (childVNode._nextDom !== undefined) {\n\t\t// Only Fragments or components that return Fragment like VNodes will\n\t\t// have a non-undefined _nextDom. Continue the diff from the sibling\n\t\t// of last DOM child of this child VNode\n\t\tnextDom = childVNode._nextDom;\n\n\t\t// Eagerly cleanup _nextDom. We don't need to persist the value because\n\t\t// it is only used by `diffChildren` to determine where to resume the diff after\n\t\t// diffing Components and Fragments. Once we store it the nextDOM local var, we\n\t\t// can clean up the property\n\t\tchildVNode._nextDom = undefined;\n\t} else if (\n\t\texcessDomChildren == oldVNode ||\n\t\tnewDom != oldDom ||\n\t\tnewDom.parentNode == null\n\t) {\n\t\t// NOTE: excessDomChildren==oldVNode above:\n\t\t// This is a compression of excessDomChildren==null && oldVNode==null!\n\t\t// The values only have the same type when `null`.\n\n\t\touter: if (oldDom == null || oldDom.parentNode !== parentDom) {\n\t\t\tparentDom.appendChild(newDom);\n\t\t\tnextDom = null;\n\t\t} else {\n\t\t\t// `j<oldChildrenLength; j+=2` is an alternative to `j++<oldChildrenLength/2`\n\t\t\tfor (\n\t\t\t\tlet sibDom = oldDom, j = 0;\n\t\t\t\t(sibDom = sibDom.nextSibling) && j < oldChildren.length;\n\t\t\t\tj += 2\n\t\t\t) {\n\t\t\t\tif (sibDom == newDom) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparentDom.insertBefore(newDom, oldDom);\n\t\t\tnextDom = oldDom;\n\t\t}\n\t}\n\n\t// If we have pre-calculated the nextDOM node, use it. Else calculate it now\n\t// Strictly check for `undefined` here cuz `null` is a valid value of `nextDom`.\n\t// See more detail in create-element.js:createVNode\n\tif (nextDom !== undefined) {\n\t\toldDom = nextDom;\n\t} else {\n\t\toldDom = newDom.nextSibling;\n\t}\n\n\treturn oldDom;\n}\n","import { IS_NON_DIMENSIONAL } from '../constants';\nimport options from '../options';\n\n/**\n * Diff the old and new properties of a VNode and apply changes to the DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to apply\n * changes to\n * @param {object} newProps The new props\n * @param {object} oldProps The old props\n * @param {boolean} isSvg Whether or not this node is an SVG node\n * @param {boolean} hydrate Whether or not we are in hydration mode\n */\nexport function diffProps(dom, newProps, oldProps, isSvg, hydrate) {\n\tlet i;\n\n\tfor (i in oldProps) {\n\t\tif (i !== 'children' && i !== 'key' && !(i in newProps)) {\n\t\t\tsetProperty(dom, i, null, oldProps[i], isSvg);\n\t\t}\n\t}\n\n\tfor (i in newProps) {\n\t\tif (\n\t\t\t(!hydrate || typeof newProps[i] == 'function') &&\n\t\t\ti !== 'children' &&\n\t\t\ti !== 'key' &&\n\t\t\ti !== 'value' &&\n\t\t\ti !== 'checked' &&\n\t\t\toldProps[i] !== newProps[i]\n\t\t) {\n\t\t\tsetProperty(dom, i, newProps[i], oldProps[i], isSvg);\n\t\t}\n\t}\n}\n\nfunction setStyle(style, key, value) {\n\tif (key[0] === '-') {\n\t\tstyle.setProperty(key, value);\n\t} else if (value == null) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, isSvg) {\n\tlet useCapture, nameLower, proxy;\n\n\tif (isSvg && name == 'className') name = 'class';\n\n\t// if (isSvg) {\n\t// \tif (name === 'className') name = 'class';\n\t// } else if (name === 'class') name += 'Name';\n\n\tif (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture = name !== (name = name.replace(/Capture$/, ''));\n\t\tnameLower = name.toLowerCase();\n\t\tif (nameLower in dom) name = nameLower;\n\t\tname = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tproxy = useCapture ? eventProxyCapture : eventProxy;\n\t\tif (value) {\n\t\t\tif (!oldValue) dom.addEventListener(name, proxy, useCapture);\n\t\t} else {\n\t\t\tdom.removeEventListener(name, proxy, useCapture);\n\t\t}\n\t} else if (\n\t\tname !== 'list' &&\n\t\tname !== 'tagName' &&\n\t\t// HTMLButtonElement.form and HTMLInputElement.form are read-only but can be set using\n\t\t// setAttribute\n\t\tname !== 'form' &&\n\t\tname !== 'type' &&\n\t\tname !== 'size' &&\n\t\tname !== 'download' &&\n\t\tname !== 'href' &&\n\t\t!isSvg &&\n\t\tname in dom\n\t) {\n\t\tdom[name] = value == null ? '' : value;\n\t} else if (typeof value != 'function' && name !== 'dangerouslySetInnerHTML') {\n\t\tif (name !== (name = name.replace(/xlink:?/, ''))) {\n\t\t\tif (value == null || value === false) {\n\t\t\t\tdom.removeAttributeNS(\n\t\t\t\t\t'http://www.w3.org/1999/xlink',\n\t\t\t\t\tname.toLowerCase()\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tdom.setAttributeNS(\n\t\t\t\t\t'http://www.w3.org/1999/xlink',\n\t\t\t\t\tname.toLowerCase(),\n\t\t\t\t\tvalue\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (\n\t\t\tvalue == null ||\n\t\t\t(value === false &&\n\t\t\t\t// ARIA-attributes have a different notion of boolean values.\n\t\t\t\t// The value `false` is different from the attribute not\n\t\t\t\t// existing on the DOM, so we can't remove it. For non-boolean\n\t\t\t\t// ARIA-attributes we could treat false as a removal, but the\n\t\t\t\t// amount of exceptions would cost us too many bytes. On top of\n\t\t\t\t// that other VDOM frameworks also always stringify `false`.\n\t\t\t\t!/^ar/.test(name))\n\t\t) {\n\t\t\tdom.removeAttribute(name);\n\t\t} else {\n\t\t\tdom.setAttribute(name, value);\n\t\t}\n\t}\n}\n\n/**\n * Proxy an event to hooked event handlers\n * @param {Event} e The event object from the browser\n * @private\n */\nfunction eventProxy(e) {\n\tthis._listeners[e.type + false](options.event ? options.event(e) : e);\n}\n\nfunction eventProxyCapture(e) {\n\tthis._listeners[e.type + true](options.event ? options.event(e) : e);\n}\n","import { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { Component } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren, placeChild } from './children';\nimport { diffProps, setProperty } from './props';\nimport { assign, removeNode } from '../util';\nimport options from '../options';\n\nfunction reorderChildren(newVNode, oldDom, parentDom) {\n\tfor (let tmp = 0; tmp < newVNode._children.length; tmp++) {\n\t\tconst vnode = newVNode._children[tmp];\n\t\tif (vnode) {\n\t\t\tvnode._parent = newVNode;\n\n\t\t\tif (vnode._dom) {\n\t\t\t\tif (typeof vnode.type == 'function' && vnode._children.length > 1) {\n\t\t\t\t\treorderChildren(vnode, oldDom, parentDom);\n\t\t\t\t}\n\n\t\t\t\toldDom = placeChild(\n\t\t\t\t\tparentDom,\n\t\t\t\t\tvnode,\n\t\t\t\t\tvnode,\n\t\t\t\t\tnewVNode._children,\n\t\t\t\t\tnull,\n\t\t\t\t\tvnode._dom,\n\t\t\t\t\toldDom\n\t\t\t\t);\n\n\t\t\t\tif (typeof newVNode.type == 'function') {\n\t\t\t\t\tnewVNode._nextDom = oldDom;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').PreactElement} parentDom The parent of the DOM element\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by getChildContext\n * @param {boolean} isSvg Whether or not this element is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {Element | Text} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} [isHydrating] Whether or not we are in hydration\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== undefined) return null;\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\ttry {\n\t\touter: if (typeof newType == 'function') {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif ('prototype' in newType && newType.prototype.render) {\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\tnewVNode._component = c = new Component(newProps, componentContext);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (c._nextState == null) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\t\t\tif (newType.getDerivedStateFromProps != null) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tc.componentWillMount != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidMount != null) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(!c._force &&\n\t\t\t\t\t\tc.shouldComponentUpdate != null &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\tnewVNode._original === oldVNode._original\n\t\t\t\t) {\n\t\t\t\t\tc.props = newProps;\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original !== oldVNode._original) c._dirty = false;\n\t\t\t\t\tc._vnode = newVNode;\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\treorderChildren(newVNode, oldDom, parentDom);\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != null) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidUpdate != null) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc.state = c._nextState;\n\n\t\t\tif ((tmp = options._render)) tmp(newVNode);\n\n\t\t\tc._dirty = false;\n\t\t\tc._vnode = newVNode;\n\t\t\tc._parentDom = parentDom;\n\n\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != null) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (!isNew && c.getSnapshotBeforeUpdate != null) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != null && tmp.type == Fragment && tmp.key == null;\n\t\t\tlet renderResult = isTopLevelFragment ? tmp.props.children : tmp;\n\n\t\t\tdiffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tArray.isArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = null;\n\t\t\t}\n\n\t\t\tc._force = false;\n\t\t} else if (\n\t\t\texcessDomChildren == null &&\n\t\t\tnewVNode._original === oldVNode._original\n\t\t) {\n\t\t\tnewVNode._children = oldVNode._children;\n\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t} else {\n\t\t\tnewVNode._dom = diffElementNodes(\n\t\t\t\toldVNode._dom,\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\tif ((tmp = options.diffed)) tmp(newVNode);\n\t} catch (e) {\n\t\tnewVNode._original = null;\n\t\toptions._catchError(e, newVNode, oldVNode);\n\t}\n\n\treturn newVNode._dom;\n}\n\n/**\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').VNode} root\n */\nexport function commitRoot(commitQueue, root) {\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {import('../internal').PreactElement} dom The DOM element representing\n * the virtual nodes being diffed\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {*} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @returns {import('../internal').PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating\n) {\n\tlet i;\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\n\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\tisSvg = newVNode.type === 'svg' || isSvg;\n\n\tif (excessDomChildren != null) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tconst child = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tchild != null &&\n\t\t\t\t((newVNode.type === null\n\t\t\t\t\t? child.nodeType === 3\n\t\t\t\t\t: child.localName === newVNode.type) ||\n\t\t\t\t\tdom == child)\n\t\t\t) {\n\t\t\t\tdom = child;\n\t\t\t\texcessDomChildren[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == null) {\n\t\tif (newVNode.type === null) {\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tdom = isSvg\n\t\t\t? document.createElementNS('http://www.w3.org/2000/svg', newVNode.type)\n\t\t\t: document.createElement(\n\t\t\t\t\tnewVNode.type,\n\t\t\t\t\tnewProps.is && { is: newProps.is }\n\t\t\t  );\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = null;\n\t\t// we are creating a new node, so we can assume this is a new subtree (in case we are hydrating), this deopts the hydrate\n\t\tisHydrating = false;\n\t}\n\n\tif (newVNode.type === null) {\n\t\tif (oldProps !== newProps && dom.data !== newProps) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\tif (excessDomChildren != null) {\n\t\t\texcessDomChildren = EMPTY_ARR.slice.call(dom.childNodes);\n\t\t}\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\tlet oldHtml = oldProps.dangerouslySetInnerHTML;\n\t\tlet newHtml = newProps.dangerouslySetInnerHTML;\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tif (!isHydrating) {\n\t\t\t// But, if we are in a situation where we are using existing DOM (e.g. replaceNode)\n\t\t\t// we should read the existing DOM attributes to diff them\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\toldProps = {};\n\t\t\t\tfor (let i = 0; i < dom.attributes.length; i++) {\n\t\t\t\t\toldProps[dom.attributes[i].name] = dom.attributes[i].value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (newHtml || oldHtml) {\n\t\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\t\tif (\n\t\t\t\t\t!newHtml ||\n\t\t\t\t\t((!oldHtml || newHtml.__html != oldHtml.__html) &&\n\t\t\t\t\t\tnewHtml.__html !== dom.innerHTML)\n\t\t\t\t) {\n\t\t\t\t\tdom.innerHTML = (newHtml && newHtml.__html) || '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdiffProps(dom, newProps, oldProps, isSvg, isHydrating);\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\ti = newVNode.props.children;\n\t\t\tdiffChildren(\n\t\t\t\tdom,\n\t\t\t\tArray.isArray(i) ? i : [i],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnewVNode.type === 'foreignObject' ? false : isSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tEMPTY_OBJ,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\t// (as above, don't diff props during hydration)\n\t\tif (!isHydrating) {\n\t\t\tif (\n\t\t\t\t'value' in newProps &&\n\t\t\t\t(i = newProps.value) !== undefined &&\n\t\t\t\ti !== dom.value\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'value', i, oldProps.value, false);\n\t\t\t}\n\t\t\tif (\n\t\t\t\t'checked' in newProps &&\n\t\t\t\t(i = newProps.checked) !== undefined &&\n\t\t\t\ti !== dom.checked\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'checked', i, oldProps.checked, false);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {object|function} ref\n * @param {any} value\n * @param {import('../internal').VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') ref(value);\n\t\telse ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {import('../internal').VNode} vnode The virtual node to unmount\n * @param {import('../internal').VNode} parentVNode The parent of the VNode that\n * initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current === vnode._dom) applyRef(r, null, parentVNode);\n\t}\n\n\tlet dom;\n\tif (!skipRemove && typeof vnode.type != 'function') {\n\t\tskipRemove = (dom = vnode._dom) != null;\n\t}\n\n\t// Must be set to `undefined` to properly clean up `_nextDom`\n\t// for which `null` is a valid value. See comment in `create-element.js`\n\tvnode._dom = vnode._nextDom = undefined;\n\n\tif ((r = vnode._component) != null) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = null;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) unmount(r[i], parentVNode, skipRemove);\n\t\t}\n\t}\n\n\tif (dom != null) removeNode(dom);\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n","import { enqueueRender } from '../component';\n\n/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').VNode} vnode The vnode that threw\n * the error that was caught (except for unmounting when this parameter\n * is the highest parent that was being unmounted)\n */\nexport function _catchError(error, vnode) {\n\t/** @type {import('../internal').Component} */\n\tlet component, hasCaught;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tif (\n\t\t\t\t\tcomponent.constructor &&\n\t\t\t\t\tcomponent.constructor.getDerivedStateFromError != null\n\t\t\t\t) {\n\t\t\t\t\thasCaught = true;\n\t\t\t\t\tcomponent.setState(\n\t\t\t\t\t\tcomponent.constructor.getDerivedStateFromError(error)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != null) {\n\t\t\t\t\thasCaught = true;\n\t\t\t\t\tcomponent.componentDidCatch(error);\n\t\t\t\t}\n\n\t\t\t\tif (hasCaught)\n\t\t\t\t\treturn enqueueRender((component._pendingError = component));\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n","import { assign } from './util';\nimport { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./index').ComponentChildren>} rest Any additional arguments will be used as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\tif (children != null) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tnull\n\t);\n}\n"],"names":["options","isValidElement","rerenderQueue","defer","prevDebounce","IS_HYDRATE","i","EMPTY_OBJ","EMPTY_ARR","IS_NON_DIMENSIONAL","assign","obj","props","removeNode","node","parentNode","removeChild","createElement","type","children","key","ref","normalizedProps","arguments","length","push","defaultProps","undefined","createVNode","original","vnode","constructor","Fragment","Component","context","getDomSibling","childIndex","indexOf","sibling","updateParentDomPointers","child","base","enqueueRender","c","process","debounceRendering","queue","sort","a","b","some","component","commitQueue","oldVNode","newDom","oldDom","parentDom","diff","ownerSVGElement","commitRoot","diffChildren","renderResult","newParentVNode","oldParentVNode","globalContext","isSvg","excessDomChildren","isHydrating","j","childVNode","firstChildDom","refs","oldChildren","oldChildrenLength","Array","isArray","placeChild","value","unmount","applyRef","nextDom","sibDom","outer","appendChild","nextSibling","insertBefore","diffProps","dom","newProps","oldProps","hydrate","setProperty","setStyle","style","test","name","oldValue","useCapture","nameLower","proxy","cssText","replace","toLowerCase","slice","_listeners","eventProxyCapture","eventProxy","addEventListener","removeEventListener","removeAttributeNS","setAttributeNS","removeAttribute","setAttribute","e","event","reorderChildren","newVNode","tmp","isNew","oldState","snapshot","clearProcessingException","provider","componentContext","newType","contextType","prototype","render","doRender","sub","state","getDerivedStateFromProps","componentWillMount","componentDidMount","componentWillReceiveProps","shouldComponentUpdate","componentWillUpdate","componentDidUpdate","getChildContext","getSnapshotBeforeUpdate","diffElementNodes","diffed","root","cb","call","oldHtml","newHtml","nodeType","localName","document","createTextNode","createElementNS","is","data","childNodes","dangerouslySetInnerHTML","attributes","innerHTML","checked","current","parentVNode","skipRemove","r","componentWillUnmount","this","replaceNode","error","hasCaught","getDerivedStateFromError","setState","componentDidCatch","update","callback","s","forceUpdate","Promise","then","bind","resolve","setTimeout","defaultValue","contextId","Consumer","contextValue","Provider","subs","ctx","_props","old","splice","toChildArray","out"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/preact/dist/preact.min.js b/node_modules/preact/dist/preact.min.js
index 8b1eb67..b8979a4 100644
--- a/node_modules/preact/dist/preact.min.js
+++ b/node_modules/preact/dist/preact.min.js
@@ -1,2 +1,2 @@
-!function(){var n,l,u,t,i,o,r,f,e={},c=[],a=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function s(n,l){for(var u in l)n[u]=l[u];return n}function h(n){var l=n.parentNode;l&&l.removeChild(n)}function v(n,l,u){var t,i,o,r=arguments,f={};for(o in l)"key"==o?t=l[o]:"ref"==o?i=l[o]:f[o]=l[o];if(arguments.length>3)for(u=[u],o=3;o<arguments.length;o++)u.push(r[o]);if(null!=u&&(f.children=u),"function"==typeof n&&null!=n.defaultProps)for(o in n.defaultProps)void 0===f[o]&&(f[o]=n.defaultProps[o]);return y(n,f,t,i,null)}function y(l,u,t,i,o){var r={type:l,props:u,key:t,ref:i,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,constructor:void 0,__v:o};return null==o&&(r.__v=r),null!=n.vnode&&n.vnode(r),r}function d(n){return n.children}function p(n,l){this.props=n,this.context=l}function _(n,l){if(null==l)return n.__?_(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return"function"==typeof n.type?_(n):null}function m(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return m(n)}}function w(l){(!l.__d&&(l.__d=!0)&&u.push(l)&&!k.__r++||i!==n.debounceRendering)&&((i=n.debounceRendering)||t)(k)}function k(){for(var n;k.__r=u.length;)n=u.sort(function(n,l){return n.__v.__b-l.__v.__b}),u=[],n.some(function(n){var l,u,t,i,o,r,f;n.__d&&(r=(o=(l=n).__v).__e,(f=l.__P)&&(u=[],(t=s({},o)).__v=t,i=z(f,o,t,l.__n,void 0!==f.ownerSVGElement,null,u,null==r?_(o):r),N(u,o),i!=r&&m(o)))})}function g(n,l,u,t,i,o,r,f,a,s){var v,p,m,w,k,g,x,C=t&&t.__k||c,A=C.length;for(a==e&&(a=null!=r?r[0]:A?_(t,0):null),u.__k=[],v=0;v<l.length;v++)if(null!=(w=u.__k[v]=null==(w=l[v])||"boolean"==typeof w?null:"string"==typeof w||"number"==typeof w?y(null,w,null,null,w):Array.isArray(w)?y(d,{children:w},null,null,null):null!=w.__e||null!=w.__c?y(w.type,w.props,w.key,null,w.__v):w)){if(w.__=u,w.__b=u.__b+1,null===(m=C[v])||m&&w.key==m.key&&w.type===m.type)C[v]=void 0;else for(p=0;p<A;p++){if((m=C[p])&&w.key==m.key&&w.type===m.type){C[p]=void 0;break}m=null}k=z(n,w,m=m||e,i,o,r,f,a,s),(p=w.ref)&&m.ref!=p&&(x||(x=[]),m.ref&&x.push(m.ref,null,w),x.push(p,w.__c||k,w)),null!=k?(null==g&&(g=k),a=b(n,w,m,C,r,k,a),s||"option"!=u.type?"function"==typeof u.type&&(u.__d=a):n.value=""):a&&m.__e==a&&a.parentNode!=n&&(a=_(m))}if(u.__e=g,null!=r&&"function"!=typeof u.type)for(v=r.length;v--;)null!=r[v]&&h(r[v]);for(v=A;v--;)null!=C[v]&&j(C[v],C[v]);if(x)for(v=0;v<x.length;v++)$(x[v],x[++v],x[++v])}function b(n,l,u,t,i,o,r){var f,e,c;if(void 0!==l.__d)f=l.__d,l.__d=void 0;else if(i==u||o!=r||null==o.parentNode)n:if(null==r||r.parentNode!==n)n.appendChild(o),f=null;else{for(e=r,c=0;(e=e.nextSibling)&&c<t.length;c+=2)if(e==o)break n;n.insertBefore(o,r),f=r}return void 0!==f?f:o.nextSibling}function x(n,l,u,t,i){var o;for(o in u)"children"===o||"key"===o||o in l||A(n,o,null,u[o],t);for(o in l)i&&"function"!=typeof l[o]||"children"===o||"key"===o||"value"===o||"checked"===o||u[o]===l[o]||A(n,o,l[o],u[o],t)}function C(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]=null==u?"":"number"!=typeof u||a.test(l)?u:u+"px"}function A(n,l,u,t,i){var o,r;if(i&&"className"==l&&(l="class"),"style"===l)if("string"==typeof u)n.style=u;else{if("string"==typeof t&&(n.style=t=""),t)for(l in t)u&&l in u||C(n.style,l,"");if(u)for(l in u)t&&u[l]===t[l]||C(n.style,l,u[l])}else"o"===l[0]&&"n"===l[1]?(o=l!==(l=l.replace(/Capture$/,"")),(r=l.toLowerCase())in n&&(l=r),l=l.slice(2),n.l||(n.l={}),n.l[l]=u,u?t||n.addEventListener(l,P,o):n.removeEventListener(l,P,o)):"list"!==l&&"tagName"!==l&&"form"!==l&&"type"!==l&&"size"!==l&&"download"!==l&&"href"!==l&&!i&&l in n?n[l]=null==u?"":u:"function"!=typeof u&&"dangerouslySetInnerHTML"!==l&&(l!==(l=l.replace(/xlink:?/,""))?null==u||!1===u?n.removeAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase()):n.setAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase(),u):null==u||!1===u&&!/^ar/.test(l)?n.removeAttribute(l):n.setAttribute(l,u))}function P(l){this.l[l.type](n.event?n.event(l):l)}function E(n,l,u){var t,i;for(t=0;t<n.__k.length;t++)(i=n.__k[t])&&(i.__=n,i.__e&&("function"==typeof i.type&&i.__k.length>1&&E(i,l,u),l=b(u,i,i,n.__k,null,i.__e,l),"function"==typeof n.type&&(n.__d=l)))}function z(l,u,t,i,o,r,f,e,c){var a,h,v,y,_,m,w,k,b,x,C,A=u.type;if(void 0!==u.constructor)return null;(a=n.__b)&&a(u);try{n:if("function"==typeof A){if(k=u.props,b=(a=A.contextType)&&i[a.__c],x=a?b?b.props.value:a.__:i,t.__c?w=(h=u.__c=t.__c).__=h.__E:("prototype"in A&&A.prototype.render?u.__c=h=new A(k,x):(u.__c=h=new p(k,x),h.constructor=A,h.render=F),b&&b.sub(h),h.props=k,h.state||(h.state={}),h.context=x,h.__n=i,v=h.__d=!0,h.__h=[]),null==h.__s&&(h.__s=h.state),null!=A.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=s({},h.__s)),s(h.__s,A.getDerivedStateFromProps(k,h.__s))),y=h.props,_=h.state,v)null==A.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else{if(null==A.getDerivedStateFromProps&&k!==y&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(k,x),!h.__e&&null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(k,h.__s,x)||u.__v===t.__v){h.props=k,h.state=h.__s,u.__v!==t.__v&&(h.__d=!1),h.__v=u,u.__e=t.__e,u.__k=t.__k,h.__h.length&&f.push(h),E(u,e,l);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(k,h.__s,x),null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(y,_,m)})}h.context=x,h.props=k,h.state=h.__s,(a=n.__r)&&a(u),h.__d=!1,h.__v=u,h.__P=l,a=h.render(h.props,h.state,h.context),h.state=h.__s,null!=h.getChildContext&&(i=s(s({},i),h.getChildContext())),v||null==h.getSnapshotBeforeUpdate||(m=h.getSnapshotBeforeUpdate(y,_)),C=null!=a&&a.type==d&&null==a.key?a.props.children:a,g(l,Array.isArray(C)?C:[C],u,t,i,o,r,f,e,c),h.base=u.__e,h.__h.length&&f.push(h),w&&(h.__E=h.__=null),h.__e=!1}else null==r&&u.__v===t.__v?(u.__k=t.__k,u.__e=t.__e):u.__e=T(t.__e,u,t,i,o,r,f,c);(a=n.diffed)&&a(u)}catch(l){u.__v=null,n.__e(l,u,t)}return u.__e}function N(l,u){n.__c&&n.__c(u,l),l.some(function(u){try{l=u.__h,u.__h=[],l.some(function(n){n.call(u)})}catch(l){n.__e(l,u.__v)}})}function T(n,l,u,t,i,o,r,f){var a,s,h,v,y,d=u.props,p=l.props;if(i="svg"===l.type||i,null!=o)for(a=0;a<o.length;a++)if(null!=(s=o[a])&&((null===l.type?3===s.nodeType:s.localName===l.type)||n==s)){n=s,o[a]=null;break}if(null==n){if(null===l.type)return document.createTextNode(p);n=i?document.createElementNS("http://www.w3.org/2000/svg",l.type):document.createElement(l.type,p.is&&{is:p.is}),o=null,f=!1}if(null===l.type)d!==p&&n.data!==p&&(n.data=p);else{if(null!=o&&(o=c.slice.call(n.childNodes)),h=(d=u.props||e).dangerouslySetInnerHTML,v=p.dangerouslySetInnerHTML,!f){if(null!=o)for(d={},y=0;y<n.attributes.length;y++)d[n.attributes[y].name]=n.attributes[y].value;(v||h)&&(v&&h&&v.__html==h.__html||(n.innerHTML=v&&v.__html||""))}x(n,p,d,i,f),v?l.__k=[]:(a=l.props.children,g(n,Array.isArray(a)?a:[a],l,u,t,"foreignObject"!==l.type&&i,o,r,e,f)),f||("value"in p&&void 0!==(a=p.value)&&a!==n.value&&A(n,"value",a,d.value,!1),"checked"in p&&void 0!==(a=p.checked)&&a!==n.checked&&A(n,"checked",a,d.checked,!1))}return n}function $(l,u,t){try{"function"==typeof l?l(u):l.current=u}catch(l){n.__e(l,t)}}function j(l,u,t){var i,o,r;if(n.unmount&&n.unmount(l),(i=l.ref)&&(i.current&&i.current!==l.__e||$(i,null,u)),t||"function"==typeof l.type||(t=null!=(o=l.__e)),l.__e=l.__d=void 0,null!=(i=l.__c)){if(i.componentWillUnmount)try{i.componentWillUnmount()}catch(l){n.__e(l,u)}i.base=i.__P=null}if(i=l.__k)for(r=0;r<i.length;r++)i[r]&&j(i[r],u,t);null!=o&&h(o)}function F(n,l,u){return this.constructor(n,u)}function H(l,u,t){var i,r,f;n.__&&n.__(l,u),r=(i=t===o)?null:t&&t.__k||u.__k,l=v(d,null,[l]),f=[],z(u,(i?u:t||u).__k=l,r||e,e,void 0!==u.ownerSVGElement,t&&!i?[t]:r?null:u.childNodes.length?c.slice.call(u.childNodes):null,f,t||e,i),N(f,l)}n={__e:function(n,l){for(var u,t;l=l.__;)if((u=l.__c)&&!u.__)try{if(u.constructor&&null!=u.constructor.getDerivedStateFromError&&(t=!0,u.setState(u.constructor.getDerivedStateFromError(n))),null!=u.componentDidCatch&&(t=!0,u.componentDidCatch(n)),t)return w(u.__E=u)}catch(l){n=l}throw n}},l=function(n){return null!=n&&void 0===n.constructor},p.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=s({},this.state),"function"==typeof n&&(n=n(s({},u),this.props)),n&&s(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),w(this))},p.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),w(this))},p.prototype.render=d,u=[],t="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,k.__r=0,o=e,r=0,f={render:H,hydrate:function(n,l){H(n,l,o)},createElement:v,h:v,Fragment:d,createRef:function(){return{current:null}},isValidElement:l,Component:p,cloneElement:function(n,l,u){var t,i,o,r=arguments,f=s({},n.props);for(o in l)"key"==o?t=l[o]:"ref"==o?i=l[o]:f[o]=l[o];if(arguments.length>3)for(u=[u],o=3;o<arguments.length;o++)u.push(r[o]);return null!=u&&(f.children=u),y(n.type,f,t||n.key,i||n.ref,null)},createContext:function(n,l){var u={__c:l="__cC"+r++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n,u,t){return this.getChildContext||(u=[],(t={})[l]=this,this.getChildContext=function(){return t},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(w)},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u},toChildArray:function n(l,u){return u=u||[],null==l||"boolean"==typeof l||(Array.isArray(l)?l.some(function(l){n(l,u)}):u.push(l)),u},__u:j,options:n},typeof module<"u"?module.exports=f:self.preact=f}();
+!function(){var n,l,u,t,i,o,r,f,e={},c=[],a=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function s(n,l){for(var u in l)n[u]=l[u];return n}function h(n){var l=n.parentNode;l&&l.removeChild(n)}function v(n,l,u){var t,i,o,r=arguments,f={};for(o in l)"key"==o?t=l[o]:"ref"==o?i=l[o]:f[o]=l[o];if(arguments.length>3)for(u=[u],o=3;o<arguments.length;o++)u.push(r[o]);if(null!=u&&(f.children=u),"function"==typeof n&&null!=n.defaultProps)for(o in n.defaultProps)void 0===f[o]&&(f[o]=n.defaultProps[o]);return y(n,f,t,i,null)}function y(l,u,t,i,o){var r={type:l,props:u,key:t,ref:i,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,constructor:void 0,__v:o};return null==o&&(r.__v=r),null!=n.vnode&&n.vnode(r),r}function d(n){return n.children}function p(n,l){this.props=n,this.context=l}function _(n,l){if(null==l)return n.__?_(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return"function"==typeof n.type?_(n):null}function m(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return m(n)}}function w(l){(!l.__d&&(l.__d=!0)&&u.push(l)&&!k.__r++||i!==n.debounceRendering)&&((i=n.debounceRendering)||t)(k)}function k(){for(var n;k.__r=u.length;)n=u.sort(function(n,l){return n.__v.__b-l.__v.__b}),u=[],n.some(function(n){var l,u,t,i,o,r,f;n.__d&&(r=(o=(l=n).__v).__e,(f=l.__P)&&(u=[],(t=s({},o)).__v=t,i=N(f,o,t,l.__n,void 0!==f.ownerSVGElement,null,u,null==r?_(o):r),T(u,o),i!=r&&m(o)))})}function g(n,l,u,t,i,o,r,f,a,s){var v,p,m,w,k,g,x,C=t&&t.__k||c,A=C.length;for(a==e&&(a=null!=r?r[0]:A?_(t,0):null),u.__k=[],v=0;v<l.length;v++)if(null!=(w=u.__k[v]=null==(w=l[v])||"boolean"==typeof w?null:"string"==typeof w||"number"==typeof w?y(null,w,null,null,w):Array.isArray(w)?y(d,{children:w},null,null,null):null!=w.__e||null!=w.__c?y(w.type,w.props,w.key,null,w.__v):w)){if(w.__=u,w.__b=u.__b+1,null===(m=C[v])||m&&w.key==m.key&&w.type===m.type)C[v]=void 0;else for(p=0;p<A;p++){if((m=C[p])&&w.key==m.key&&w.type===m.type){C[p]=void 0;break}m=null}k=N(n,w,m=m||e,i,o,r,f,a,s),(p=w.ref)&&m.ref!=p&&(x||(x=[]),m.ref&&x.push(m.ref,null,w),x.push(p,w.__c||k,w)),null!=k?(null==g&&(g=k),a=b(n,w,m,C,r,k,a),s||"option"!=u.type?"function"==typeof u.type&&(u.__d=a):n.value=""):a&&m.__e==a&&a.parentNode!=n&&(a=_(m))}if(u.__e=g,null!=r&&"function"!=typeof u.type)for(v=r.length;v--;)null!=r[v]&&h(r[v]);for(v=A;v--;)null!=C[v]&&F(C[v],C[v]);if(x)for(v=0;v<x.length;v++)j(x[v],x[++v],x[++v])}function b(n,l,u,t,i,o,r){var f,e,c;if(void 0!==l.__d)f=l.__d,l.__d=void 0;else if(i==u||o!=r||null==o.parentNode)n:if(null==r||r.parentNode!==n)n.appendChild(o),f=null;else{for(e=r,c=0;(e=e.nextSibling)&&c<t.length;c+=2)if(e==o)break n;n.insertBefore(o,r),f=r}return void 0!==f?f:o.nextSibling}function x(n,l,u,t,i){var o;for(o in u)"children"===o||"key"===o||o in l||A(n,o,null,u[o],t);for(o in l)i&&"function"!=typeof l[o]||"children"===o||"key"===o||"value"===o||"checked"===o||u[o]===l[o]||A(n,o,l[o],u[o],t)}function C(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]=null==u?"":"number"!=typeof u||a.test(l)?u:u+"px"}function A(n,l,u,t,i){var o,r,f;if(i&&"className"==l&&(l="class"),"style"===l)if("string"==typeof u)n.style.cssText=u;else{if("string"==typeof t&&(n.style.cssText=t=""),t)for(l in t)u&&l in u||C(n.style,l,"");if(u)for(l in u)t&&u[l]===t[l]||C(n.style,l,u[l])}else"o"===l[0]&&"n"===l[1]?(o=l!==(l=l.replace(/Capture$/,"")),(r=l.toLowerCase())in n&&(l=r),l=l.slice(2),n.l||(n.l={}),n.l[l+o]=u,f=o?E:P,u?t||n.addEventListener(l,f,o):n.removeEventListener(l,f,o)):"list"!==l&&"tagName"!==l&&"form"!==l&&"type"!==l&&"size"!==l&&"download"!==l&&"href"!==l&&!i&&l in n?n[l]=null==u?"":u:"function"!=typeof u&&"dangerouslySetInnerHTML"!==l&&(l!==(l=l.replace(/xlink:?/,""))?null==u||!1===u?n.removeAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase()):n.setAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase(),u):null==u||!1===u&&!/^ar/.test(l)?n.removeAttribute(l):n.setAttribute(l,u))}function P(l){this.l[l.type+!1](n.event?n.event(l):l)}function E(l){this.l[l.type+!0](n.event?n.event(l):l)}function z(n,l,u){var t,i;for(t=0;t<n.__k.length;t++)(i=n.__k[t])&&(i.__=n,i.__e&&("function"==typeof i.type&&i.__k.length>1&&z(i,l,u),l=b(u,i,i,n.__k,null,i.__e,l),"function"==typeof n.type&&(n.__d=l)))}function N(l,u,t,i,o,r,f,e,c){var a,h,v,y,_,m,w,k,b,x,C,A=u.type;if(void 0!==u.constructor)return null;(a=n.__b)&&a(u);try{n:if("function"==typeof A){if(k=u.props,b=(a=A.contextType)&&i[a.__c],x=a?b?b.props.value:a.__:i,t.__c?w=(h=u.__c=t.__c).__=h.__E:("prototype"in A&&A.prototype.render?u.__c=h=new A(k,x):(u.__c=h=new p(k,x),h.constructor=A,h.render=H),b&&b.sub(h),h.props=k,h.state||(h.state={}),h.context=x,h.__n=i,v=h.__d=!0,h.__h=[]),null==h.__s&&(h.__s=h.state),null!=A.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=s({},h.__s)),s(h.__s,A.getDerivedStateFromProps(k,h.__s))),y=h.props,_=h.state,v)null==A.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else{if(null==A.getDerivedStateFromProps&&k!==y&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(k,x),!h.__e&&null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(k,h.__s,x)||u.__v===t.__v){h.props=k,h.state=h.__s,u.__v!==t.__v&&(h.__d=!1),h.__v=u,u.__e=t.__e,u.__k=t.__k,h.__h.length&&f.push(h),z(u,e,l);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(k,h.__s,x),null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(y,_,m)})}h.context=x,h.props=k,h.state=h.__s,(a=n.__r)&&a(u),h.__d=!1,h.__v=u,h.__P=l,a=h.render(h.props,h.state,h.context),h.state=h.__s,null!=h.getChildContext&&(i=s(s({},i),h.getChildContext())),v||null==h.getSnapshotBeforeUpdate||(m=h.getSnapshotBeforeUpdate(y,_)),C=null!=a&&a.type==d&&null==a.key?a.props.children:a,g(l,Array.isArray(C)?C:[C],u,t,i,o,r,f,e,c),h.base=u.__e,h.__h.length&&f.push(h),w&&(h.__E=h.__=null),h.__e=!1}else null==r&&u.__v===t.__v?(u.__k=t.__k,u.__e=t.__e):u.__e=$(t.__e,u,t,i,o,r,f,c);(a=n.diffed)&&a(u)}catch(l){u.__v=null,n.__e(l,u,t)}return u.__e}function T(l,u){n.__c&&n.__c(u,l),l.some(function(u){try{l=u.__h,u.__h=[],l.some(function(n){n.call(u)})}catch(l){n.__e(l,u.__v)}})}function $(n,l,u,t,i,o,r,f){var a,s,h,v,y,d=u.props,p=l.props;if(i="svg"===l.type||i,null!=o)for(a=0;a<o.length;a++)if(null!=(s=o[a])&&((null===l.type?3===s.nodeType:s.localName===l.type)||n==s)){n=s,o[a]=null;break}if(null==n){if(null===l.type)return document.createTextNode(p);n=i?document.createElementNS("http://www.w3.org/2000/svg",l.type):document.createElement(l.type,p.is&&{is:p.is}),o=null,f=!1}if(null===l.type)d!==p&&n.data!==p&&(n.data=p);else{if(null!=o&&(o=c.slice.call(n.childNodes)),h=(d=u.props||e).dangerouslySetInnerHTML,v=p.dangerouslySetInnerHTML,!f){if(null!=o)for(d={},y=0;y<n.attributes.length;y++)d[n.attributes[y].name]=n.attributes[y].value;(v||h)&&(v&&(h&&v.__html==h.__html||v.__html===n.innerHTML)||(n.innerHTML=v&&v.__html||""))}x(n,p,d,i,f),v?l.__k=[]:(a=l.props.children,g(n,Array.isArray(a)?a:[a],l,u,t,"foreignObject"!==l.type&&i,o,r,e,f)),f||("value"in p&&void 0!==(a=p.value)&&a!==n.value&&A(n,"value",a,d.value,!1),"checked"in p&&void 0!==(a=p.checked)&&a!==n.checked&&A(n,"checked",a,d.checked,!1))}return n}function j(l,u,t){try{"function"==typeof l?l(u):l.current=u}catch(l){n.__e(l,t)}}function F(l,u,t){var i,o,r;if(n.unmount&&n.unmount(l),(i=l.ref)&&(i.current&&i.current!==l.__e||j(i,null,u)),t||"function"==typeof l.type||(t=null!=(o=l.__e)),l.__e=l.__d=void 0,null!=(i=l.__c)){if(i.componentWillUnmount)try{i.componentWillUnmount()}catch(l){n.__e(l,u)}i.base=i.__P=null}if(i=l.__k)for(r=0;r<i.length;r++)i[r]&&F(i[r],u,t);null!=o&&h(o)}function H(n,l,u){return this.constructor(n,u)}function I(l,u,t){var i,r,f;n.__&&n.__(l,u),r=(i=t===o)?null:t&&t.__k||u.__k,l=v(d,null,[l]),f=[],N(u,(i?u:t||u).__k=l,r||e,e,void 0!==u.ownerSVGElement,t&&!i?[t]:r?null:u.childNodes.length?c.slice.call(u.childNodes):null,f,t||e,i),T(f,l)}n={__e:function(n,l){for(var u,t;l=l.__;)if((u=l.__c)&&!u.__)try{if(u.constructor&&null!=u.constructor.getDerivedStateFromError&&(t=!0,u.setState(u.constructor.getDerivedStateFromError(n))),null!=u.componentDidCatch&&(t=!0,u.componentDidCatch(n)),t)return w(u.__E=u)}catch(l){n=l}throw n}},l=function(n){return null!=n&&void 0===n.constructor},p.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=s({},this.state),"function"==typeof n&&(n=n(s({},u),this.props)),n&&s(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),w(this))},p.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),w(this))},p.prototype.render=d,u=[],t="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,k.__r=0,o=e,r=0,f={render:I,hydrate:function(n,l){I(n,l,o)},createElement:v,h:v,Fragment:d,createRef:function(){return{current:null}},isValidElement:l,Component:p,cloneElement:function(n,l,u){var t,i,o,r=arguments,f=s({},n.props);for(o in l)"key"==o?t=l[o]:"ref"==o?i=l[o]:f[o]=l[o];if(arguments.length>3)for(u=[u],o=3;o<arguments.length;o++)u.push(r[o]);return null!=u&&(f.children=u),y(n.type,f,t||n.key,i||n.ref,null)},createContext:function(n,l){var u={__c:l="__cC"+r++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n,u,t){return this.getChildContext||(u=[],(t={})[l]=this,this.getChildContext=function(){return t},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(w)},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u},toChildArray:function n(l,u){return u=u||[],null==l||"boolean"==typeof l||(Array.isArray(l)?l.some(function(l){n(l,u)}):u.push(l)),u},__u:F,options:n},typeof module<"u"?module.exports=f:self.preact=f}();
 //# sourceMappingURL=preact.min.js.map
diff --git a/node_modules/preact/dist/preact.min.js.map b/node_modules/preact/dist/preact.min.js.map
index 344ae7a..f0ae08f 100644
--- a/node_modules/preact/dist/preact.min.js.map
+++ b/node_modules/preact/dist/preact.min.js.map
@@ -1 +1 @@
-{"version":3,"file":"preact.min.js","sources":["../src/options.js","../src/create-element.js","../src/component.js","../src/render.js","../src/create-context.js","../src/constants.js","../src/util.js","../src/diff/children.js","../src/diff/props.js","../src/diff/index.js","../src/diff/catch-error.js","../src/clone-element.js","../src/cjs.js"],"sourcesContent":["import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n","import options from './options';\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * constructor for this virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\t// https://github.com/preactjs/preact/issues/1916\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\tif (children != null) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != null) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === undefined) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, null);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t// _nextDom must be initialized to undefined b/c it will eventually\n\t\t// be set to dom.nextSibling which can return `null` and it is important\n\t\t// to be able to distinguish between an uninitialized _nextDom and\n\t\t// a _nextDom that has been set to `null`\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\tconstructor: undefined,\n\t\t_original: original\n\t};\n\n\tif (original == null) vnode._original = vnode;\n\tif (options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is import('./internal').VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor === undefined;\n","import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function Component(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nComponent.prototype.setState = function(update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._vnode) {\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nComponent.prototype.forceUpdate = function(callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {import('./index').ComponentChildren | void}\n */\nComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._parent._children.indexOf(vnode) + 1)\n\t\t\t: null;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != null && sibling._dom != null) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : null;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {import('./internal').Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet vnode = component._vnode,\n\t\toldDom = vnode._dom,\n\t\tparentDom = component._parentDom;\n\n\tif (parentDom) {\n\t\tlet commitQueue = [];\n\t\tconst oldVNode = assign({}, vnode);\n\t\toldVNode._original = oldVNode;\n\n\t\tlet newDom = diff(\n\t\t\tparentDom,\n\t\t\tvnode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tparentDom.ownerSVGElement !== undefined,\n\t\t\tnull,\n\t\t\tcommitQueue,\n\t\t\toldDom == null ? getDomSibling(vnode) : oldDom\n\t\t);\n\t\tcommitRoot(commitQueue, vnode);\n\n\t\tif (newDom != oldDom) {\n\t\t\tupdateParentDomPointers(vnode);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./internal').VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != null && vnode._component != null) {\n\t\tvnode._dom = vnode._component.base = null;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != null && child._dom != null) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Component>}\n */\nlet rerenderQueue = [];\n\n/**\n * Asynchronously schedule a callback\n * @type {(cb: () => void) => void}\n */\n/* istanbul ignore next */\n// Note the following line isn't tree-shaken by rollup cuz of rollup/rollup#2566\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\n/**\n * Enqueue a rerender of a component\n * @param {import('./internal').Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet queue;\n\twhile ((process._rerenderCount = rerenderQueue.length)) {\n\t\tqueue = rerenderQueue.sort((a, b) => a._vnode._depth - b._vnode._depth);\n\t\trerenderQueue = [];\n\t\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t\t// process() calls from getting scheduled while `queue` is still being consumed.\n\t\tqueue.some(c => {\n\t\t\tif (c._dirty) renderComponent(c);\n\t\t});\n\t}\n}\nprocess._rerenderCount = 0;\n","import { EMPTY_OBJ, EMPTY_ARR } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\n\nconst IS_HYDRATE = EMPTY_OBJ;\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./index').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * render into\n * @param {Element | Text} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we\n\t// are in hydration mode or not by passing `IS_HYDRATE` instead of a\n\t// DOM element.\n\tlet isHydrating = replaceNode === IS_HYDRATE;\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? null\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\tvnode = createElement(Fragment, null, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\t((isHydrating ? parentDom : replaceNode || parentDom)._children = vnode),\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.ownerSVGElement !== undefined,\n\t\treplaceNode && !isHydrating\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t? null\n\t\t\t: parentDom.childNodes.length\n\t\t\t? EMPTY_ARR.slice.call(parentDom.childNodes)\n\t\t\t: null,\n\t\tcommitQueue,\n\t\treplaceNode || EMPTY_OBJ,\n\t\tisHydrating\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./index').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, IS_HYDRATE);\n}\n","import { enqueueRender } from './component';\n\nexport let i = 0;\n\nexport function createContext(defaultValue, contextId) {\n\tcontextId = '__cC' + i++;\n\n\tconst context = {\n\t\t_id: contextId,\n\t\t_defaultValue: defaultValue,\n\t\tConsumer(props, contextValue) {\n\t\t\t// return props.children(\n\t\t\t// \tcontext[contextId] ? context[contextId].props.value : defaultValue\n\t\t\t// );\n\t\t\treturn props.children(contextValue);\n\t\t},\n\t\tProvider(props, subs, ctx) {\n\t\t\tif (!this.getChildContext) {\n\t\t\t\tsubs = [];\n\t\t\t\tctx = {};\n\t\t\t\tctx[contextId] = this;\n\n\t\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\t\tthis.shouldComponentUpdate = function(_props) {\n\t\t\t\t\tif (this.props.value !== _props.value) {\n\t\t\t\t\t\t// I think the forced value propagation here was only needed when `options.debounceRendering` was being bypassed:\n\t\t\t\t\t\t// https://github.com/preactjs/preact/commit/4d339fb803bea09e9f198abf38ca1bf8ea4b7771#diff-54682ce380935a717e41b8bfc54737f6R358\n\t\t\t\t\t\t// In those cases though, even with the value corrected, we're double-rendering all nodes.\n\t\t\t\t\t\t// It might be better to just tell folks not to use force-sync mode.\n\t\t\t\t\t\t// Currently, using `useContext()` in a class component will overwrite its `this.context` value.\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context[contextId] = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\t\t\t\t\t\tsubs.some(enqueueRender);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.sub = c => {\n\t\t\t\t\tsubs.push(c);\n\t\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\t\tsubs.splice(subs.indexOf(c), 1);\n\t\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn props.children;\n\t\t}\n\t};\n\n\t// Devtools needs access to the context object when it\n\t// encounters a Provider. This is necessary to support\n\t// setting `displayName` on the context object instead\n\t// of on the component itself. See:\n\t// https://reactjs.org/docs/context.html#contextdisplayname\n\n\treturn (context.Provider._contextRef = context.Consumer.contextType = context);\n}\n","export const EMPTY_OBJ = {};\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n","/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {Node} node The node to remove\n */\nexport function removeNode(node) {\n\tlet parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n","import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { removeNode } from '../util';\nimport { getDomSibling } from '../component';\n\n/**\n * Diff the children of a virtual node\n * @param {import('../internal').PreactElement} parentDom The DOM element whose\n * children are being diffed\n * @param {import('../index').ComponentChildren[]} renderResult\n * @param {import('../internal').VNode} newParentVNode The new virtual\n * node whose children should be diff'ed against oldParentVNode\n * @param {import('../internal').VNode} oldParentVNode The old virtual\n * node whose children should be diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by getChildContext\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {Node | Text} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet i, j, oldVNode, childVNode, newDom, firstChildDom, refs;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet oldChildrenLength = oldChildren.length;\n\n\t// Only in very specific places should this logic be invoked (top level `render` and `diffElementNodes`).\n\t// I'm using `EMPTY_OBJ` to signal when `diffChildren` is invoked in these situations. I can't use `null`\n\t// for this purpose, because `null` is a valid value for `oldDom` which can mean to skip to this logic\n\t// (e.g. if mounting a new tree in which the old DOM should be ignored (usually for Fragments).\n\tif (oldDom == EMPTY_OBJ) {\n\t\tif (excessDomChildren != null) {\n\t\t\toldDom = excessDomChildren[0];\n\t\t} else if (oldChildrenLength) {\n\t\t\toldDom = getDomSibling(oldParentVNode, 0);\n\t\t} else {\n\t\t\toldDom = null;\n\t\t}\n\t}\n\n\tnewParentVNode._children = [];\n\tfor (i = 0; i < renderResult.length; i++) {\n\t\tchildVNode = renderResult[i];\n\n\t\tif (childVNode == null || typeof childVNode == 'boolean') {\n\t\t\tchildVNode = newParentVNode._children[i] = null;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (typeof childVNode == 'string' || typeof childVNode == 'number') {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tnull,\n\t\t\t\tchildVNode,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t} else if (Array.isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (childVNode._dom != null || childVNode._component != null) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tnull,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\t// Terser removes the `continue` here and wraps the loop body\n\t\t// in a `if (childVNode) { ... } condition\n\t\tif (childVNode == null) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\t// Check if we find a corresponding element in oldChildren.\n\t\t// If found, delete the array item by setting to `undefined`.\n\t\t// We use `undefined`, as `null` is reserved for empty placeholders\n\t\t// (holes).\n\t\toldVNode = oldChildren[i];\n\n\t\tif (\n\t\t\toldVNode === null ||\n\t\t\t(oldVNode &&\n\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\tchildVNode.type === oldVNode.type)\n\t\t) {\n\t\t\toldChildren[i] = undefined;\n\t\t} else {\n\t\t\t// Either oldVNode === undefined or oldChildrenLength > 0,\n\t\t\t// so after this loop oldVNode == null or oldVNode is a valid value.\n\t\t\tfor (j = 0; j < oldChildrenLength; j++) {\n\t\t\t\toldVNode = oldChildren[j];\n\t\t\t\t// If childVNode is unkeyed, we only match similarly unkeyed nodes, otherwise we match by key.\n\t\t\t\t// We always match by type (in either case).\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\t\tchildVNode.type === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\toldChildren[j] = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\toldVNode = null;\n\t\t\t}\n\t\t}\n\n\t\toldVNode = oldVNode || EMPTY_OBJ;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tnewDom = diff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tisSvg,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating\n\t\t);\n\n\t\tif ((j = childVNode.ref) && oldVNode.ref != j) {\n\t\t\tif (!refs) refs = [];\n\t\t\tif (oldVNode.ref) refs.push(oldVNode.ref, null, childVNode);\n\t\t\trefs.push(j, childVNode._component || newDom, childVNode);\n\t\t}\n\n\t\tif (newDom != null) {\n\t\t\tif (firstChildDom == null) {\n\t\t\t\tfirstChildDom = newDom;\n\t\t\t}\n\n\t\t\toldDom = placeChild(\n\t\t\t\tparentDom,\n\t\t\t\tchildVNode,\n\t\t\t\toldVNode,\n\t\t\t\toldChildren,\n\t\t\t\texcessDomChildren,\n\t\t\t\tnewDom,\n\t\t\t\toldDom\n\t\t\t);\n\n\t\t\t// Browsers will infer an option's `value` from `textContent` when\n\t\t\t// no value is present. This essentially bypasses our code to set it\n\t\t\t// later in `diff()`. It works fine in all browsers except for IE11\n\t\t\t// where it breaks setting `select.value`. There it will be always set\n\t\t\t// to an empty string. Re-applying an options value will fix that, so\n\t\t\t// there are probably some internal data structures that aren't\n\t\t\t// updated properly.\n\t\t\t//\n\t\t\t// To fix it we make sure to reset the inferred value, so that our own\n\t\t\t// value check in `diff()` won't be skipped.\n\t\t\tif (!isHydrating && newParentVNode.type == 'option') {\n\t\t\t\tparentDom.value = '';\n\t\t\t} else if (typeof newParentVNode.type == 'function') {\n\t\t\t\t// Because the newParentVNode is Fragment-like, we need to set it's\n\t\t\t\t// _nextDom property to the nextSibling of its last child DOM node.\n\t\t\t\t//\n\t\t\t\t// `oldDom` contains the correct value here because if the last child\n\t\t\t\t// is a Fragment-like, then oldDom has already been set to that child's _nextDom.\n\t\t\t\t// If the last child is a DOM VNode, then oldDom will be set to that DOM\n\t\t\t\t// node's nextSibling.\n\t\t\t\tnewParentVNode._nextDom = oldDom;\n\t\t\t}\n\t\t} else if (\n\t\t\toldDom &&\n\t\t\toldVNode._dom == oldDom &&\n\t\t\toldDom.parentNode != parentDom\n\t\t) {\n\t\t\t// The above condition is to handle null placeholders. See test in placeholder.test.js:\n\t\t\t// `efficiently replace null placeholders in parent rerenders`\n\t\t\toldDom = getDomSibling(oldVNode);\n\t\t}\n\t}\n\n\tnewParentVNode._dom = firstChildDom;\n\n\t// Remove children that are not part of any vnode.\n\tif (excessDomChildren != null && typeof newParentVNode.type != 'function') {\n\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\tif (excessDomChildren[i] != null) removeNode(excessDomChildren[i]);\n\t\t}\n\t}\n\n\t// Remove remaining oldChildren if there are any.\n\tfor (i = oldChildrenLength; i--; ) {\n\t\tif (oldChildren[i] != null) unmount(oldChildren[i], oldChildren[i]);\n\t}\n\n\t// Set refs only after unmount\n\tif (refs) {\n\t\tfor (i = 0; i < refs.length; i++) {\n\t\t\tapplyRef(refs[i], refs[++i], refs[++i]);\n\t\t}\n\t}\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {import('../index').ComponentChildren} children The unflattened\n * children of a virtual node\n * @returns {import('../internal').VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (Array.isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\nexport function placeChild(\n\tparentDom,\n\tchildVNode,\n\toldVNode,\n\toldChildren,\n\texcessDomChildren,\n\tnewDom,\n\toldDom\n) {\n\tlet nextDom;\n\tif (childVNode._nextDom !== undefined) {\n\t\t// Only Fragments or components that return Fragment like VNodes will\n\t\t// have a non-undefined _nextDom. Continue the diff from the sibling\n\t\t// of last DOM child of this child VNode\n\t\tnextDom = childVNode._nextDom;\n\n\t\t// Eagerly cleanup _nextDom. We don't need to persist the value because\n\t\t// it is only used by `diffChildren` to determine where to resume the diff after\n\t\t// diffing Components and Fragments. Once we store it the nextDOM local var, we\n\t\t// can clean up the property\n\t\tchildVNode._nextDom = undefined;\n\t} else if (\n\t\texcessDomChildren == oldVNode ||\n\t\tnewDom != oldDom ||\n\t\tnewDom.parentNode == null\n\t) {\n\t\t// NOTE: excessDomChildren==oldVNode above:\n\t\t// This is a compression of excessDomChildren==null && oldVNode==null!\n\t\t// The values only have the same type when `null`.\n\n\t\touter: if (oldDom == null || oldDom.parentNode !== parentDom) {\n\t\t\tparentDom.appendChild(newDom);\n\t\t\tnextDom = null;\n\t\t} else {\n\t\t\t// `j<oldChildrenLength; j+=2` is an alternative to `j++<oldChildrenLength/2`\n\t\t\tfor (\n\t\t\t\tlet sibDom = oldDom, j = 0;\n\t\t\t\t(sibDom = sibDom.nextSibling) && j < oldChildren.length;\n\t\t\t\tj += 2\n\t\t\t) {\n\t\t\t\tif (sibDom == newDom) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparentDom.insertBefore(newDom, oldDom);\n\t\t\tnextDom = oldDom;\n\t\t}\n\t}\n\n\t// If we have pre-calculated the nextDOM node, use it. Else calculate it now\n\t// Strictly check for `undefined` here cuz `null` is a valid value of `nextDom`.\n\t// See more detail in create-element.js:createVNode\n\tif (nextDom !== undefined) {\n\t\toldDom = nextDom;\n\t} else {\n\t\toldDom = newDom.nextSibling;\n\t}\n\n\treturn oldDom;\n}\n","import { IS_NON_DIMENSIONAL } from '../constants';\nimport options from '../options';\n\n/**\n * Diff the old and new properties of a VNode and apply changes to the DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to apply\n * changes to\n * @param {object} newProps The new props\n * @param {object} oldProps The old props\n * @param {boolean} isSvg Whether or not this node is an SVG node\n * @param {boolean} hydrate Whether or not we are in hydration mode\n */\nexport function diffProps(dom, newProps, oldProps, isSvg, hydrate) {\n\tlet i;\n\n\tfor (i in oldProps) {\n\t\tif (i !== 'children' && i !== 'key' && !(i in newProps)) {\n\t\t\tsetProperty(dom, i, null, oldProps[i], isSvg);\n\t\t}\n\t}\n\n\tfor (i in newProps) {\n\t\tif (\n\t\t\t(!hydrate || typeof newProps[i] == 'function') &&\n\t\t\ti !== 'children' &&\n\t\t\ti !== 'key' &&\n\t\t\ti !== 'value' &&\n\t\t\ti !== 'checked' &&\n\t\t\toldProps[i] !== newProps[i]\n\t\t) {\n\t\t\tsetProperty(dom, i, newProps[i], oldProps[i], isSvg);\n\t\t}\n\t}\n}\n\nfunction setStyle(style, key, value) {\n\t// if (!(key in style)) {  // -3b\n\t// if (key < '.') {  // -1b\n\tif (key[0] === '-') {\n\t\tstyle.setProperty(key, value);\n\t} else if (value == null) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, isSvg) {\n\tlet useCapture, nameLower;\n\n\tif (isSvg && name == 'className') name = 'class';\n\n\t// if (isSvg) {\n\t// \tif (name === 'className') name = 'class';\n\t// } else if (name === 'class') name += 'Name';\n\n\tif (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture = name !== (name = name.replace(/Capture$/, ''));\n\t\tnameLower = name.toLowerCase();\n\t\tif (nameLower in dom) name = nameLower;\n\t\tname = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) dom.addEventListener(name, eventProxy, useCapture);\n\t\t} else {\n\t\t\tdom.removeEventListener(name, eventProxy, useCapture);\n\t\t}\n\t} else if (\n\t\tname !== 'list' &&\n\t\tname !== 'tagName' &&\n\t\t// HTMLButtonElement.form and HTMLInputElement.form are read-only but can be set using\n\t\t// setAttribute\n\t\tname !== 'form' &&\n\t\tname !== 'type' &&\n\t\tname !== 'size' &&\n\t\tname !== 'download' &&\n\t\tname !== 'href' &&\n\t\t!isSvg &&\n\t\tname in dom\n\t) {\n\t\tdom[name] = value == null ? '' : value;\n\t} else if (typeof value != 'function' && name !== 'dangerouslySetInnerHTML') {\n\t\tif (name !== (name = name.replace(/xlink:?/, ''))) {\n\t\t\tif (value == null || value === false) {\n\t\t\t\tdom.removeAttributeNS(\n\t\t\t\t\t'http://www.w3.org/1999/xlink',\n\t\t\t\t\tname.toLowerCase()\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tdom.setAttributeNS(\n\t\t\t\t\t'http://www.w3.org/1999/xlink',\n\t\t\t\t\tname.toLowerCase(),\n\t\t\t\t\tvalue\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (\n\t\t\tvalue == null ||\n\t\t\t(value === false &&\n\t\t\t\t// ARIA-attributes have a different notion of boolean values.\n\t\t\t\t// The value `false` is different from the attribute not\n\t\t\t\t// existing on the DOM, so we can't remove it. For non-boolean\n\t\t\t\t// ARIA-attributes we could treat false as a removal, but the\n\t\t\t\t// amount of exceptions would cost us too many bytes. On top of\n\t\t\t\t// that other VDOM frameworks also always stringify `false`.\n\t\t\t\t!/^ar/.test(name))\n\t\t) {\n\t\t\tdom.removeAttribute(name);\n\t\t} else {\n\t\t\tdom.setAttribute(name, value);\n\t\t}\n\t}\n}\n\n/**\n * Proxy an event to hooked event handlers\n * @param {Event} e The event object from the browser\n * @private\n */\nfunction eventProxy(e) {\n\tthis._listeners[e.type](options.event ? options.event(e) : e);\n}\n","import { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { Component } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren, placeChild } from './children';\nimport { diffProps, setProperty } from './props';\nimport { assign, removeNode } from '../util';\nimport options from '../options';\n\nfunction reorderChildren(newVNode, oldDom, parentDom) {\n\tfor (let tmp = 0; tmp < newVNode._children.length; tmp++) {\n\t\tconst vnode = newVNode._children[tmp];\n\t\tif (vnode) {\n\t\t\tvnode._parent = newVNode;\n\n\t\t\tif (vnode._dom) {\n\t\t\t\tif (typeof vnode.type == 'function' && vnode._children.length > 1) {\n\t\t\t\t\treorderChildren(vnode, oldDom, parentDom);\n\t\t\t\t}\n\n\t\t\t\toldDom = placeChild(\n\t\t\t\t\tparentDom,\n\t\t\t\t\tvnode,\n\t\t\t\t\tvnode,\n\t\t\t\t\tnewVNode._children,\n\t\t\t\t\tnull,\n\t\t\t\t\tvnode._dom,\n\t\t\t\t\toldDom\n\t\t\t\t);\n\n\t\t\t\tif (typeof newVNode.type == 'function') {\n\t\t\t\t\tnewVNode._nextDom = oldDom;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').PreactElement} parentDom The parent of the DOM element\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by getChildContext\n * @param {boolean} isSvg Whether or not this element is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {Element | Text} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} [isHydrating] Whether or not we are in hydration\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== undefined) return null;\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\ttry {\n\t\touter: if (typeof newType == 'function') {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif ('prototype' in newType && newType.prototype.render) {\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\tnewVNode._component = c = new Component(newProps, componentContext);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (c._nextState == null) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\t\t\tif (newType.getDerivedStateFromProps != null) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tc.componentWillMount != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidMount != null) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(!c._force &&\n\t\t\t\t\t\tc.shouldComponentUpdate != null &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\tnewVNode._original === oldVNode._original\n\t\t\t\t) {\n\t\t\t\t\tc.props = newProps;\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original !== oldVNode._original) c._dirty = false;\n\t\t\t\t\tc._vnode = newVNode;\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\treorderChildren(newVNode, oldDom, parentDom);\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != null) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidUpdate != null) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc.state = c._nextState;\n\n\t\t\tif ((tmp = options._render)) tmp(newVNode);\n\n\t\t\tc._dirty = false;\n\t\t\tc._vnode = newVNode;\n\t\t\tc._parentDom = parentDom;\n\n\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != null) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (!isNew && c.getSnapshotBeforeUpdate != null) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != null && tmp.type == Fragment && tmp.key == null;\n\t\t\tlet renderResult = isTopLevelFragment ? tmp.props.children : tmp;\n\n\t\t\tdiffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tArray.isArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = null;\n\t\t\t}\n\n\t\t\tc._force = false;\n\t\t} else if (\n\t\t\texcessDomChildren == null &&\n\t\t\tnewVNode._original === oldVNode._original\n\t\t) {\n\t\t\tnewVNode._children = oldVNode._children;\n\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t} else {\n\t\t\tnewVNode._dom = diffElementNodes(\n\t\t\t\toldVNode._dom,\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\tif ((tmp = options.diffed)) tmp(newVNode);\n\t} catch (e) {\n\t\tnewVNode._original = null;\n\t\toptions._catchError(e, newVNode, oldVNode);\n\t}\n\n\treturn newVNode._dom;\n}\n\n/**\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').VNode} root\n */\nexport function commitRoot(commitQueue, root) {\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {import('../internal').PreactElement} dom The DOM element representing\n * the virtual nodes being diffed\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {*} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @returns {import('../internal').PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating\n) {\n\tlet i;\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\n\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\tisSvg = newVNode.type === 'svg' || isSvg;\n\n\tif (excessDomChildren != null) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tconst child = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tchild != null &&\n\t\t\t\t((newVNode.type === null\n\t\t\t\t\t? child.nodeType === 3\n\t\t\t\t\t: child.localName === newVNode.type) ||\n\t\t\t\t\tdom == child)\n\t\t\t) {\n\t\t\t\tdom = child;\n\t\t\t\texcessDomChildren[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == null) {\n\t\tif (newVNode.type === null) {\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tdom = isSvg\n\t\t\t? document.createElementNS('http://www.w3.org/2000/svg', newVNode.type)\n\t\t\t: document.createElement(\n\t\t\t\t\tnewVNode.type,\n\t\t\t\t\tnewProps.is && { is: newProps.is }\n\t\t\t  );\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = null;\n\t\t// we are creating a new node, so we can assume this is a new subtree (in case we are hydrating), this deopts the hydrate\n\t\tisHydrating = false;\n\t}\n\n\tif (newVNode.type === null) {\n\t\tif (oldProps !== newProps && dom.data !== newProps) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\tif (excessDomChildren != null) {\n\t\t\texcessDomChildren = EMPTY_ARR.slice.call(dom.childNodes);\n\t\t}\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\tlet oldHtml = oldProps.dangerouslySetInnerHTML;\n\t\tlet newHtml = newProps.dangerouslySetInnerHTML;\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tif (!isHydrating) {\n\t\t\t// But, if we are in a situation where we are using existing DOM (e.g. replaceNode)\n\t\t\t// we should read the existing DOM attributes to diff them\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\toldProps = {};\n\t\t\t\tfor (let i = 0; i < dom.attributes.length; i++) {\n\t\t\t\t\toldProps[dom.attributes[i].name] = dom.attributes[i].value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (newHtml || oldHtml) {\n\t\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\t\tif (!newHtml || !oldHtml || newHtml.__html != oldHtml.__html) {\n\t\t\t\t\tdom.innerHTML = (newHtml && newHtml.__html) || '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdiffProps(dom, newProps, oldProps, isSvg, isHydrating);\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\ti = newVNode.props.children;\n\t\t\tdiffChildren(\n\t\t\t\tdom,\n\t\t\t\tArray.isArray(i) ? i : [i],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnewVNode.type === 'foreignObject' ? false : isSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tEMPTY_OBJ,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\t// (as above, don't diff props during hydration)\n\t\tif (!isHydrating) {\n\t\t\tif (\n\t\t\t\t'value' in newProps &&\n\t\t\t\t(i = newProps.value) !== undefined &&\n\t\t\t\ti !== dom.value\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'value', i, oldProps.value, false);\n\t\t\t}\n\t\t\tif (\n\t\t\t\t'checked' in newProps &&\n\t\t\t\t(i = newProps.checked) !== undefined &&\n\t\t\t\ti !== dom.checked\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'checked', i, oldProps.checked, false);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {object|function} ref\n * @param {any} value\n * @param {import('../internal').VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') ref(value);\n\t\telse ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {import('../internal').VNode} vnode The virtual node to unmount\n * @param {import('../internal').VNode} parentVNode The parent of the VNode that\n * initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current === vnode._dom) applyRef(r, null, parentVNode);\n\t}\n\n\tlet dom;\n\tif (!skipRemove && typeof vnode.type != 'function') {\n\t\tskipRemove = (dom = vnode._dom) != null;\n\t}\n\n\t// Must be set to `undefined` to properly clean up `_nextDom`\n\t// for which `null` is a valid value. See comment in `create-element.js`\n\tvnode._dom = vnode._nextDom = undefined;\n\n\tif ((r = vnode._component) != null) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = null;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) unmount(r[i], parentVNode, skipRemove);\n\t\t}\n\t}\n\n\tif (dom != null) removeNode(dom);\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n","import { enqueueRender } from '../component';\n\n/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').VNode} vnode The vnode that threw\n * the error that was caught (except for unmounting when this parameter\n * is the highest parent that was being unmounted)\n */\nexport function _catchError(error, vnode) {\n\t/** @type {import('../internal').Component} */\n\tlet component, hasCaught;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tif (\n\t\t\t\t\tcomponent.constructor &&\n\t\t\t\t\tcomponent.constructor.getDerivedStateFromError != null\n\t\t\t\t) {\n\t\t\t\t\thasCaught = true;\n\t\t\t\t\tcomponent.setState(\n\t\t\t\t\t\tcomponent.constructor.getDerivedStateFromError(error)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != null) {\n\t\t\t\t\thasCaught = true;\n\t\t\t\t\tcomponent.componentDidCatch(error);\n\t\t\t\t}\n\n\t\t\t\tif (hasCaught)\n\t\t\t\t\treturn enqueueRender((component._pendingError = component));\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n","import { assign } from './util';\nimport { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./index').ComponentChildren>} rest Any additional arguments will be used as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\tif (children != null) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tnull\n\t);\n}\n","import * as preact from './index.js';\nif (typeof module < 'u') module.exports = preact;\nelse self.preact = preact;\n"],"names":["options","isValidElement","rerenderQueue","defer","prevDebounce","IS_HYDRATE","i","EMPTY_OBJ","EMPTY_ARR","IS_NON_DIMENSIONAL","assign","obj","props","removeNode","node","parentNode","removeChild","createElement","type","children","key","ref","normalizedProps","arguments","length","push","defaultProps","undefined","createVNode","original","vnode","constructor","Fragment","Component","context","getDomSibling","childIndex","indexOf","sibling","updateParentDomPointers","child","base","enqueueRender","c","process","debounceRendering","queue","sort","a","b","some","component","commitQueue","oldVNode","newDom","oldDom","parentDom","diff","ownerSVGElement","commitRoot","diffChildren","renderResult","newParentVNode","oldParentVNode","globalContext","isSvg","excessDomChildren","isHydrating","j","childVNode","firstChildDom","refs","oldChildren","oldChildrenLength","Array","isArray","placeChild","value","unmount","applyRef","nextDom","sibDom","outer","appendChild","nextSibling","insertBefore","diffProps","dom","newProps","oldProps","hydrate","setProperty","setStyle","style","test","name","oldValue","useCapture","nameLower","replace","toLowerCase","slice","_listeners","addEventListener","eventProxy","removeEventListener","removeAttributeNS","setAttributeNS","removeAttribute","setAttribute","e","event","reorderChildren","newVNode","tmp","isNew","oldState","snapshot","clearProcessingException","provider","componentContext","newType","contextType","prototype","render","doRender","sub","state","getDerivedStateFromProps","componentWillMount","componentDidMount","componentWillReceiveProps","shouldComponentUpdate","componentWillUpdate","componentDidUpdate","getChildContext","getSnapshotBeforeUpdate","diffElementNodes","diffed","root","cb","call","oldHtml","newHtml","nodeType","localName","document","createTextNode","createElementNS","is","data","childNodes","dangerouslySetInnerHTML","attributes","innerHTML","checked","current","parentVNode","skipRemove","r","componentWillUnmount","this","replaceNode","error","hasCaught","getDerivedStateFromError","setState","componentDidCatch","update","callback","s","forceUpdate","Promise","then","bind","resolve","setTimeout","defaultValue","contextId","Consumer","contextValue","Provider","subs","ctx","_props","old","splice","toChildArray","out","module","exports","preact","self"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"preact.min.js","sources":["../src/options.js","../src/create-element.js","../src/component.js","../src/render.js","../src/create-context.js","../src/constants.js","../src/util.js","../src/diff/children.js","../src/diff/props.js","../src/diff/index.js","../src/diff/catch-error.js","../src/clone-element.js","../src/cjs.js"],"sourcesContent":["import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n","import options from './options';\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * constructor for this virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\t// https://github.com/preactjs/preact/issues/1916\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\tif (children != null) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != null) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === undefined) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, null);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t// _nextDom must be initialized to undefined b/c it will eventually\n\t\t// be set to dom.nextSibling which can return `null` and it is important\n\t\t// to be able to distinguish between an uninitialized _nextDom and\n\t\t// a _nextDom that has been set to `null`\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\tconstructor: undefined,\n\t\t_original: original\n\t};\n\n\tif (original == null) vnode._original = vnode;\n\tif (options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is import('./internal').VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor === undefined;\n","import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function Component(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nComponent.prototype.setState = function(update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._vnode) {\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nComponent.prototype.forceUpdate = function(callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {import('./index').ComponentChildren | void}\n */\nComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._parent._children.indexOf(vnode) + 1)\n\t\t\t: null;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != null && sibling._dom != null) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : null;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {import('./internal').Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet vnode = component._vnode,\n\t\toldDom = vnode._dom,\n\t\tparentDom = component._parentDom;\n\n\tif (parentDom) {\n\t\tlet commitQueue = [];\n\t\tconst oldVNode = assign({}, vnode);\n\t\toldVNode._original = oldVNode;\n\n\t\tlet newDom = diff(\n\t\t\tparentDom,\n\t\t\tvnode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tparentDom.ownerSVGElement !== undefined,\n\t\t\tnull,\n\t\t\tcommitQueue,\n\t\t\toldDom == null ? getDomSibling(vnode) : oldDom\n\t\t);\n\t\tcommitRoot(commitQueue, vnode);\n\n\t\tif (newDom != oldDom) {\n\t\t\tupdateParentDomPointers(vnode);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./internal').VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != null && vnode._component != null) {\n\t\tvnode._dom = vnode._component.base = null;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != null && child._dom != null) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Component>}\n */\nlet rerenderQueue = [];\n\n/**\n * Asynchronously schedule a callback\n * @type {(cb: () => void) => void}\n */\n/* istanbul ignore next */\n// Note the following line isn't tree-shaken by rollup cuz of rollup/rollup#2566\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\n/**\n * Enqueue a rerender of a component\n * @param {import('./internal').Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet queue;\n\twhile ((process._rerenderCount = rerenderQueue.length)) {\n\t\tqueue = rerenderQueue.sort((a, b) => a._vnode._depth - b._vnode._depth);\n\t\trerenderQueue = [];\n\t\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t\t// process() calls from getting scheduled while `queue` is still being consumed.\n\t\tqueue.some(c => {\n\t\t\tif (c._dirty) renderComponent(c);\n\t\t});\n\t}\n}\nprocess._rerenderCount = 0;\n","import { EMPTY_OBJ, EMPTY_ARR } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\n\nconst IS_HYDRATE = EMPTY_OBJ;\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./index').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * render into\n * @param {Element | Text} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we\n\t// are in hydration mode or not by passing `IS_HYDRATE` instead of a\n\t// DOM element.\n\tlet isHydrating = replaceNode === IS_HYDRATE;\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? null\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\tvnode = createElement(Fragment, null, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\t((isHydrating ? parentDom : replaceNode || parentDom)._children = vnode),\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.ownerSVGElement !== undefined,\n\t\treplaceNode && !isHydrating\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t? null\n\t\t\t: parentDom.childNodes.length\n\t\t\t? EMPTY_ARR.slice.call(parentDom.childNodes)\n\t\t\t: null,\n\t\tcommitQueue,\n\t\treplaceNode || EMPTY_OBJ,\n\t\tisHydrating\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./index').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, IS_HYDRATE);\n}\n","import { enqueueRender } from './component';\n\nexport let i = 0;\n\nexport function createContext(defaultValue, contextId) {\n\tcontextId = '__cC' + i++;\n\n\tconst context = {\n\t\t_id: contextId,\n\t\t_defaultValue: defaultValue,\n\t\tConsumer(props, contextValue) {\n\t\t\t// return props.children(\n\t\t\t// \tcontext[contextId] ? context[contextId].props.value : defaultValue\n\t\t\t// );\n\t\t\treturn props.children(contextValue);\n\t\t},\n\t\tProvider(props, subs, ctx) {\n\t\t\tif (!this.getChildContext) {\n\t\t\t\tsubs = [];\n\t\t\t\tctx = {};\n\t\t\t\tctx[contextId] = this;\n\n\t\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\t\tthis.shouldComponentUpdate = function(_props) {\n\t\t\t\t\tif (this.props.value !== _props.value) {\n\t\t\t\t\t\t// I think the forced value propagation here was only needed when `options.debounceRendering` was being bypassed:\n\t\t\t\t\t\t// https://github.com/preactjs/preact/commit/4d339fb803bea09e9f198abf38ca1bf8ea4b7771#diff-54682ce380935a717e41b8bfc54737f6R358\n\t\t\t\t\t\t// In those cases though, even with the value corrected, we're double-rendering all nodes.\n\t\t\t\t\t\t// It might be better to just tell folks not to use force-sync mode.\n\t\t\t\t\t\t// Currently, using `useContext()` in a class component will overwrite its `this.context` value.\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context[contextId] = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\t\t\t\t\t\tsubs.some(enqueueRender);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.sub = c => {\n\t\t\t\t\tsubs.push(c);\n\t\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\t\tsubs.splice(subs.indexOf(c), 1);\n\t\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn props.children;\n\t\t}\n\t};\n\n\t// Devtools needs access to the context object when it\n\t// encounters a Provider. This is necessary to support\n\t// setting `displayName` on the context object instead\n\t// of on the component itself. See:\n\t// https://reactjs.org/docs/context.html#contextdisplayname\n\n\treturn (context.Provider._contextRef = context.Consumer.contextType = context);\n}\n","export const EMPTY_OBJ = {};\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n","/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {Node} node The node to remove\n */\nexport function removeNode(node) {\n\tlet parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n","import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { removeNode } from '../util';\nimport { getDomSibling } from '../component';\n\n/**\n * Diff the children of a virtual node\n * @param {import('../internal').PreactElement} parentDom The DOM element whose\n * children are being diffed\n * @param {import('../index').ComponentChildren[]} renderResult\n * @param {import('../internal').VNode} newParentVNode The new virtual\n * node whose children should be diff'ed against oldParentVNode\n * @param {import('../internal').VNode} oldParentVNode The old virtual\n * node whose children should be diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by getChildContext\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {Node | Text} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet i, j, oldVNode, childVNode, newDom, firstChildDom, refs;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet oldChildrenLength = oldChildren.length;\n\n\t// Only in very specific places should this logic be invoked (top level `render` and `diffElementNodes`).\n\t// I'm using `EMPTY_OBJ` to signal when `diffChildren` is invoked in these situations. I can't use `null`\n\t// for this purpose, because `null` is a valid value for `oldDom` which can mean to skip to this logic\n\t// (e.g. if mounting a new tree in which the old DOM should be ignored (usually for Fragments).\n\tif (oldDom == EMPTY_OBJ) {\n\t\tif (excessDomChildren != null) {\n\t\t\toldDom = excessDomChildren[0];\n\t\t} else if (oldChildrenLength) {\n\t\t\toldDom = getDomSibling(oldParentVNode, 0);\n\t\t} else {\n\t\t\toldDom = null;\n\t\t}\n\t}\n\n\tnewParentVNode._children = [];\n\tfor (i = 0; i < renderResult.length; i++) {\n\t\tchildVNode = renderResult[i];\n\n\t\tif (childVNode == null || typeof childVNode == 'boolean') {\n\t\t\tchildVNode = newParentVNode._children[i] = null;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (typeof childVNode == 'string' || typeof childVNode == 'number') {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tnull,\n\t\t\t\tchildVNode,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t} else if (Array.isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (childVNode._dom != null || childVNode._component != null) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tnull,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\t// Terser removes the `continue` here and wraps the loop body\n\t\t// in a `if (childVNode) { ... } condition\n\t\tif (childVNode == null) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\t// Check if we find a corresponding element in oldChildren.\n\t\t// If found, delete the array item by setting to `undefined`.\n\t\t// We use `undefined`, as `null` is reserved for empty placeholders\n\t\t// (holes).\n\t\toldVNode = oldChildren[i];\n\n\t\tif (\n\t\t\toldVNode === null ||\n\t\t\t(oldVNode &&\n\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\tchildVNode.type === oldVNode.type)\n\t\t) {\n\t\t\toldChildren[i] = undefined;\n\t\t} else {\n\t\t\t// Either oldVNode === undefined or oldChildrenLength > 0,\n\t\t\t// so after this loop oldVNode == null or oldVNode is a valid value.\n\t\t\tfor (j = 0; j < oldChildrenLength; j++) {\n\t\t\t\toldVNode = oldChildren[j];\n\t\t\t\t// If childVNode is unkeyed, we only match similarly unkeyed nodes, otherwise we match by key.\n\t\t\t\t// We always match by type (in either case).\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\t\tchildVNode.type === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\toldChildren[j] = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\toldVNode = null;\n\t\t\t}\n\t\t}\n\n\t\toldVNode = oldVNode || EMPTY_OBJ;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tnewDom = diff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tisSvg,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating\n\t\t);\n\n\t\tif ((j = childVNode.ref) && oldVNode.ref != j) {\n\t\t\tif (!refs) refs = [];\n\t\t\tif (oldVNode.ref) refs.push(oldVNode.ref, null, childVNode);\n\t\t\trefs.push(j, childVNode._component || newDom, childVNode);\n\t\t}\n\n\t\tif (newDom != null) {\n\t\t\tif (firstChildDom == null) {\n\t\t\t\tfirstChildDom = newDom;\n\t\t\t}\n\n\t\t\toldDom = placeChild(\n\t\t\t\tparentDom,\n\t\t\t\tchildVNode,\n\t\t\t\toldVNode,\n\t\t\t\toldChildren,\n\t\t\t\texcessDomChildren,\n\t\t\t\tnewDom,\n\t\t\t\toldDom\n\t\t\t);\n\n\t\t\t// Browsers will infer an option's `value` from `textContent` when\n\t\t\t// no value is present. This essentially bypasses our code to set it\n\t\t\t// later in `diff()`. It works fine in all browsers except for IE11\n\t\t\t// where it breaks setting `select.value`. There it will be always set\n\t\t\t// to an empty string. Re-applying an options value will fix that, so\n\t\t\t// there are probably some internal data structures that aren't\n\t\t\t// updated properly.\n\t\t\t//\n\t\t\t// To fix it we make sure to reset the inferred value, so that our own\n\t\t\t// value check in `diff()` won't be skipped.\n\t\t\tif (!isHydrating && newParentVNode.type == 'option') {\n\t\t\t\tparentDom.value = '';\n\t\t\t} else if (typeof newParentVNode.type == 'function') {\n\t\t\t\t// Because the newParentVNode is Fragment-like, we need to set it's\n\t\t\t\t// _nextDom property to the nextSibling of its last child DOM node.\n\t\t\t\t//\n\t\t\t\t// `oldDom` contains the correct value here because if the last child\n\t\t\t\t// is a Fragment-like, then oldDom has already been set to that child's _nextDom.\n\t\t\t\t// If the last child is a DOM VNode, then oldDom will be set to that DOM\n\t\t\t\t// node's nextSibling.\n\t\t\t\tnewParentVNode._nextDom = oldDom;\n\t\t\t}\n\t\t} else if (\n\t\t\toldDom &&\n\t\t\toldVNode._dom == oldDom &&\n\t\t\toldDom.parentNode != parentDom\n\t\t) {\n\t\t\t// The above condition is to handle null placeholders. See test in placeholder.test.js:\n\t\t\t// `efficiently replace null placeholders in parent rerenders`\n\t\t\toldDom = getDomSibling(oldVNode);\n\t\t}\n\t}\n\n\tnewParentVNode._dom = firstChildDom;\n\n\t// Remove children that are not part of any vnode.\n\tif (excessDomChildren != null && typeof newParentVNode.type != 'function') {\n\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\tif (excessDomChildren[i] != null) removeNode(excessDomChildren[i]);\n\t\t}\n\t}\n\n\t// Remove remaining oldChildren if there are any.\n\tfor (i = oldChildrenLength; i--; ) {\n\t\tif (oldChildren[i] != null) unmount(oldChildren[i], oldChildren[i]);\n\t}\n\n\t// Set refs only after unmount\n\tif (refs) {\n\t\tfor (i = 0; i < refs.length; i++) {\n\t\t\tapplyRef(refs[i], refs[++i], refs[++i]);\n\t\t}\n\t}\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {import('../index').ComponentChildren} children The unflattened\n * children of a virtual node\n * @returns {import('../internal').VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (Array.isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\nexport function placeChild(\n\tparentDom,\n\tchildVNode,\n\toldVNode,\n\toldChildren,\n\texcessDomChildren,\n\tnewDom,\n\toldDom\n) {\n\tlet nextDom;\n\tif (childVNode._nextDom !== undefined) {\n\t\t// Only Fragments or components that return Fragment like VNodes will\n\t\t// have a non-undefined _nextDom. Continue the diff from the sibling\n\t\t// of last DOM child of this child VNode\n\t\tnextDom = childVNode._nextDom;\n\n\t\t// Eagerly cleanup _nextDom. We don't need to persist the value because\n\t\t// it is only used by `diffChildren` to determine where to resume the diff after\n\t\t// diffing Components and Fragments. Once we store it the nextDOM local var, we\n\t\t// can clean up the property\n\t\tchildVNode._nextDom = undefined;\n\t} else if (\n\t\texcessDomChildren == oldVNode ||\n\t\tnewDom != oldDom ||\n\t\tnewDom.parentNode == null\n\t) {\n\t\t// NOTE: excessDomChildren==oldVNode above:\n\t\t// This is a compression of excessDomChildren==null && oldVNode==null!\n\t\t// The values only have the same type when `null`.\n\n\t\touter: if (oldDom == null || oldDom.parentNode !== parentDom) {\n\t\t\tparentDom.appendChild(newDom);\n\t\t\tnextDom = null;\n\t\t} else {\n\t\t\t// `j<oldChildrenLength; j+=2` is an alternative to `j++<oldChildrenLength/2`\n\t\t\tfor (\n\t\t\t\tlet sibDom = oldDom, j = 0;\n\t\t\t\t(sibDom = sibDom.nextSibling) && j < oldChildren.length;\n\t\t\t\tj += 2\n\t\t\t) {\n\t\t\t\tif (sibDom == newDom) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparentDom.insertBefore(newDom, oldDom);\n\t\t\tnextDom = oldDom;\n\t\t}\n\t}\n\n\t// If we have pre-calculated the nextDOM node, use it. Else calculate it now\n\t// Strictly check for `undefined` here cuz `null` is a valid value of `nextDom`.\n\t// See more detail in create-element.js:createVNode\n\tif (nextDom !== undefined) {\n\t\toldDom = nextDom;\n\t} else {\n\t\toldDom = newDom.nextSibling;\n\t}\n\n\treturn oldDom;\n}\n","import { IS_NON_DIMENSIONAL } from '../constants';\nimport options from '../options';\n\n/**\n * Diff the old and new properties of a VNode and apply changes to the DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to apply\n * changes to\n * @param {object} newProps The new props\n * @param {object} oldProps The old props\n * @param {boolean} isSvg Whether or not this node is an SVG node\n * @param {boolean} hydrate Whether or not we are in hydration mode\n */\nexport function diffProps(dom, newProps, oldProps, isSvg, hydrate) {\n\tlet i;\n\n\tfor (i in oldProps) {\n\t\tif (i !== 'children' && i !== 'key' && !(i in newProps)) {\n\t\t\tsetProperty(dom, i, null, oldProps[i], isSvg);\n\t\t}\n\t}\n\n\tfor (i in newProps) {\n\t\tif (\n\t\t\t(!hydrate || typeof newProps[i] == 'function') &&\n\t\t\ti !== 'children' &&\n\t\t\ti !== 'key' &&\n\t\t\ti !== 'value' &&\n\t\t\ti !== 'checked' &&\n\t\t\toldProps[i] !== newProps[i]\n\t\t) {\n\t\t\tsetProperty(dom, i, newProps[i], oldProps[i], isSvg);\n\t\t}\n\t}\n}\n\nfunction setStyle(style, key, value) {\n\tif (key[0] === '-') {\n\t\tstyle.setProperty(key, value);\n\t} else if (value == null) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, isSvg) {\n\tlet useCapture, nameLower, proxy;\n\n\tif (isSvg && name == 'className') name = 'class';\n\n\t// if (isSvg) {\n\t// \tif (name === 'className') name = 'class';\n\t// } else if (name === 'class') name += 'Name';\n\n\tif (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture = name !== (name = name.replace(/Capture$/, ''));\n\t\tnameLower = name.toLowerCase();\n\t\tif (nameLower in dom) name = nameLower;\n\t\tname = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tproxy = useCapture ? eventProxyCapture : eventProxy;\n\t\tif (value) {\n\t\t\tif (!oldValue) dom.addEventListener(name, proxy, useCapture);\n\t\t} else {\n\t\t\tdom.removeEventListener(name, proxy, useCapture);\n\t\t}\n\t} else if (\n\t\tname !== 'list' &&\n\t\tname !== 'tagName' &&\n\t\t// HTMLButtonElement.form and HTMLInputElement.form are read-only but can be set using\n\t\t// setAttribute\n\t\tname !== 'form' &&\n\t\tname !== 'type' &&\n\t\tname !== 'size' &&\n\t\tname !== 'download' &&\n\t\tname !== 'href' &&\n\t\t!isSvg &&\n\t\tname in dom\n\t) {\n\t\tdom[name] = value == null ? '' : value;\n\t} else if (typeof value != 'function' && name !== 'dangerouslySetInnerHTML') {\n\t\tif (name !== (name = name.replace(/xlink:?/, ''))) {\n\t\t\tif (value == null || value === false) {\n\t\t\t\tdom.removeAttributeNS(\n\t\t\t\t\t'http://www.w3.org/1999/xlink',\n\t\t\t\t\tname.toLowerCase()\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tdom.setAttributeNS(\n\t\t\t\t\t'http://www.w3.org/1999/xlink',\n\t\t\t\t\tname.toLowerCase(),\n\t\t\t\t\tvalue\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (\n\t\t\tvalue == null ||\n\t\t\t(value === false &&\n\t\t\t\t// ARIA-attributes have a different notion of boolean values.\n\t\t\t\t// The value `false` is different from the attribute not\n\t\t\t\t// existing on the DOM, so we can't remove it. For non-boolean\n\t\t\t\t// ARIA-attributes we could treat false as a removal, but the\n\t\t\t\t// amount of exceptions would cost us too many bytes. On top of\n\t\t\t\t// that other VDOM frameworks also always stringify `false`.\n\t\t\t\t!/^ar/.test(name))\n\t\t) {\n\t\t\tdom.removeAttribute(name);\n\t\t} else {\n\t\t\tdom.setAttribute(name, value);\n\t\t}\n\t}\n}\n\n/**\n * Proxy an event to hooked event handlers\n * @param {Event} e The event object from the browser\n * @private\n */\nfunction eventProxy(e) {\n\tthis._listeners[e.type + false](options.event ? options.event(e) : e);\n}\n\nfunction eventProxyCapture(e) {\n\tthis._listeners[e.type + true](options.event ? options.event(e) : e);\n}\n","import { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { Component } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren, placeChild } from './children';\nimport { diffProps, setProperty } from './props';\nimport { assign, removeNode } from '../util';\nimport options from '../options';\n\nfunction reorderChildren(newVNode, oldDom, parentDom) {\n\tfor (let tmp = 0; tmp < newVNode._children.length; tmp++) {\n\t\tconst vnode = newVNode._children[tmp];\n\t\tif (vnode) {\n\t\t\tvnode._parent = newVNode;\n\n\t\t\tif (vnode._dom) {\n\t\t\t\tif (typeof vnode.type == 'function' && vnode._children.length > 1) {\n\t\t\t\t\treorderChildren(vnode, oldDom, parentDom);\n\t\t\t\t}\n\n\t\t\t\toldDom = placeChild(\n\t\t\t\t\tparentDom,\n\t\t\t\t\tvnode,\n\t\t\t\t\tvnode,\n\t\t\t\t\tnewVNode._children,\n\t\t\t\t\tnull,\n\t\t\t\t\tvnode._dom,\n\t\t\t\t\toldDom\n\t\t\t\t);\n\n\t\t\t\tif (typeof newVNode.type == 'function') {\n\t\t\t\t\tnewVNode._nextDom = oldDom;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').PreactElement} parentDom The parent of the DOM element\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by getChildContext\n * @param {boolean} isSvg Whether or not this element is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {Element | Text} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} [isHydrating] Whether or not we are in hydration\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== undefined) return null;\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\ttry {\n\t\touter: if (typeof newType == 'function') {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif ('prototype' in newType && newType.prototype.render) {\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\tnewVNode._component = c = new Component(newProps, componentContext);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (c._nextState == null) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\t\t\tif (newType.getDerivedStateFromProps != null) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tc.componentWillMount != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidMount != null) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(!c._force &&\n\t\t\t\t\t\tc.shouldComponentUpdate != null &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\tnewVNode._original === oldVNode._original\n\t\t\t\t) {\n\t\t\t\t\tc.props = newProps;\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original !== oldVNode._original) c._dirty = false;\n\t\t\t\t\tc._vnode = newVNode;\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\treorderChildren(newVNode, oldDom, parentDom);\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != null) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidUpdate != null) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc.state = c._nextState;\n\n\t\t\tif ((tmp = options._render)) tmp(newVNode);\n\n\t\t\tc._dirty = false;\n\t\t\tc._vnode = newVNode;\n\t\t\tc._parentDom = parentDom;\n\n\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != null) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (!isNew && c.getSnapshotBeforeUpdate != null) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != null && tmp.type == Fragment && tmp.key == null;\n\t\t\tlet renderResult = isTopLevelFragment ? tmp.props.children : tmp;\n\n\t\t\tdiffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tArray.isArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = null;\n\t\t\t}\n\n\t\t\tc._force = false;\n\t\t} else if (\n\t\t\texcessDomChildren == null &&\n\t\t\tnewVNode._original === oldVNode._original\n\t\t) {\n\t\t\tnewVNode._children = oldVNode._children;\n\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t} else {\n\t\t\tnewVNode._dom = diffElementNodes(\n\t\t\t\toldVNode._dom,\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\tif ((tmp = options.diffed)) tmp(newVNode);\n\t} catch (e) {\n\t\tnewVNode._original = null;\n\t\toptions._catchError(e, newVNode, oldVNode);\n\t}\n\n\treturn newVNode._dom;\n}\n\n/**\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').VNode} root\n */\nexport function commitRoot(commitQueue, root) {\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {import('../internal').PreactElement} dom The DOM element representing\n * the virtual nodes being diffed\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {*} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @returns {import('../internal').PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating\n) {\n\tlet i;\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\n\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\tisSvg = newVNode.type === 'svg' || isSvg;\n\n\tif (excessDomChildren != null) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tconst child = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tchild != null &&\n\t\t\t\t((newVNode.type === null\n\t\t\t\t\t? child.nodeType === 3\n\t\t\t\t\t: child.localName === newVNode.type) ||\n\t\t\t\t\tdom == child)\n\t\t\t) {\n\t\t\t\tdom = child;\n\t\t\t\texcessDomChildren[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == null) {\n\t\tif (newVNode.type === null) {\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tdom = isSvg\n\t\t\t? document.createElementNS('http://www.w3.org/2000/svg', newVNode.type)\n\t\t\t: document.createElement(\n\t\t\t\t\tnewVNode.type,\n\t\t\t\t\tnewProps.is && { is: newProps.is }\n\t\t\t  );\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = null;\n\t\t// we are creating a new node, so we can assume this is a new subtree (in case we are hydrating), this deopts the hydrate\n\t\tisHydrating = false;\n\t}\n\n\tif (newVNode.type === null) {\n\t\tif (oldProps !== newProps && dom.data !== newProps) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\tif (excessDomChildren != null) {\n\t\t\texcessDomChildren = EMPTY_ARR.slice.call(dom.childNodes);\n\t\t}\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\tlet oldHtml = oldProps.dangerouslySetInnerHTML;\n\t\tlet newHtml = newProps.dangerouslySetInnerHTML;\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tif (!isHydrating) {\n\t\t\t// But, if we are in a situation where we are using existing DOM (e.g. replaceNode)\n\t\t\t// we should read the existing DOM attributes to diff them\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\toldProps = {};\n\t\t\t\tfor (let i = 0; i < dom.attributes.length; i++) {\n\t\t\t\t\toldProps[dom.attributes[i].name] = dom.attributes[i].value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (newHtml || oldHtml) {\n\t\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\t\tif (\n\t\t\t\t\t!newHtml ||\n\t\t\t\t\t((!oldHtml || newHtml.__html != oldHtml.__html) &&\n\t\t\t\t\t\tnewHtml.__html !== dom.innerHTML)\n\t\t\t\t) {\n\t\t\t\t\tdom.innerHTML = (newHtml && newHtml.__html) || '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdiffProps(dom, newProps, oldProps, isSvg, isHydrating);\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\ti = newVNode.props.children;\n\t\t\tdiffChildren(\n\t\t\t\tdom,\n\t\t\t\tArray.isArray(i) ? i : [i],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnewVNode.type === 'foreignObject' ? false : isSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tEMPTY_OBJ,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\t// (as above, don't diff props during hydration)\n\t\tif (!isHydrating) {\n\t\t\tif (\n\t\t\t\t'value' in newProps &&\n\t\t\t\t(i = newProps.value) !== undefined &&\n\t\t\t\ti !== dom.value\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'value', i, oldProps.value, false);\n\t\t\t}\n\t\t\tif (\n\t\t\t\t'checked' in newProps &&\n\t\t\t\t(i = newProps.checked) !== undefined &&\n\t\t\t\ti !== dom.checked\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'checked', i, oldProps.checked, false);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {object|function} ref\n * @param {any} value\n * @param {import('../internal').VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') ref(value);\n\t\telse ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {import('../internal').VNode} vnode The virtual node to unmount\n * @param {import('../internal').VNode} parentVNode The parent of the VNode that\n * initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current === vnode._dom) applyRef(r, null, parentVNode);\n\t}\n\n\tlet dom;\n\tif (!skipRemove && typeof vnode.type != 'function') {\n\t\tskipRemove = (dom = vnode._dom) != null;\n\t}\n\n\t// Must be set to `undefined` to properly clean up `_nextDom`\n\t// for which `null` is a valid value. See comment in `create-element.js`\n\tvnode._dom = vnode._nextDom = undefined;\n\n\tif ((r = vnode._component) != null) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = null;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) unmount(r[i], parentVNode, skipRemove);\n\t\t}\n\t}\n\n\tif (dom != null) removeNode(dom);\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n","import { enqueueRender } from '../component';\n\n/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').VNode} vnode The vnode that threw\n * the error that was caught (except for unmounting when this parameter\n * is the highest parent that was being unmounted)\n */\nexport function _catchError(error, vnode) {\n\t/** @type {import('../internal').Component} */\n\tlet component, hasCaught;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tif (\n\t\t\t\t\tcomponent.constructor &&\n\t\t\t\t\tcomponent.constructor.getDerivedStateFromError != null\n\t\t\t\t) {\n\t\t\t\t\thasCaught = true;\n\t\t\t\t\tcomponent.setState(\n\t\t\t\t\t\tcomponent.constructor.getDerivedStateFromError(error)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != null) {\n\t\t\t\t\thasCaught = true;\n\t\t\t\t\tcomponent.componentDidCatch(error);\n\t\t\t\t}\n\n\t\t\t\tif (hasCaught)\n\t\t\t\t\treturn enqueueRender((component._pendingError = component));\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n","import { assign } from './util';\nimport { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./index').ComponentChildren>} rest Any additional arguments will be used as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\tif (children != null) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tnull\n\t);\n}\n","import * as preact from './index.js';\nif (typeof module < 'u') module.exports = preact;\nelse self.preact = preact;\n"],"names":["options","isValidElement","rerenderQueue","defer","prevDebounce","IS_HYDRATE","i","EMPTY_OBJ","EMPTY_ARR","IS_NON_DIMENSIONAL","assign","obj","props","removeNode","node","parentNode","removeChild","createElement","type","children","key","ref","normalizedProps","arguments","length","push","defaultProps","undefined","createVNode","original","vnode","constructor","Fragment","Component","context","getDomSibling","childIndex","indexOf","sibling","updateParentDomPointers","child","base","enqueueRender","c","process","debounceRendering","queue","sort","a","b","some","component","commitQueue","oldVNode","newDom","oldDom","parentDom","diff","ownerSVGElement","commitRoot","diffChildren","renderResult","newParentVNode","oldParentVNode","globalContext","isSvg","excessDomChildren","isHydrating","j","childVNode","firstChildDom","refs","oldChildren","oldChildrenLength","Array","isArray","placeChild","value","unmount","applyRef","nextDom","sibDom","outer","appendChild","nextSibling","insertBefore","diffProps","dom","newProps","oldProps","hydrate","setProperty","setStyle","style","test","name","oldValue","useCapture","nameLower","proxy","cssText","replace","toLowerCase","slice","_listeners","eventProxyCapture","eventProxy","addEventListener","removeEventListener","removeAttributeNS","setAttributeNS","removeAttribute","setAttribute","e","event","reorderChildren","newVNode","tmp","isNew","oldState","snapshot","clearProcessingException","provider","componentContext","newType","contextType","prototype","render","doRender","sub","state","getDerivedStateFromProps","componentWillMount","componentDidMount","componentWillReceiveProps","shouldComponentUpdate","componentWillUpdate","componentDidUpdate","getChildContext","getSnapshotBeforeUpdate","diffElementNodes","diffed","root","cb","call","oldHtml","newHtml","nodeType","localName","document","createTextNode","createElementNS","is","data","childNodes","dangerouslySetInnerHTML","attributes","innerHTML","checked","current","parentVNode","skipRemove","r","componentWillUnmount","this","replaceNode","error","hasCaught","getDerivedStateFromError","setState","componentDidCatch","update","callback","s","forceUpdate","Promise","then","bind","resolve","setTimeout","defaultValue","contextId","Consumer","contextValue","Provider","subs","ctx","_props","old","splice","toChildArray","out","module","exports","preact","self"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/preact/dist/preact.mjs b/node_modules/preact/dist/preact.mjs
index 2d81e0c..ebd18c0 100644
--- a/node_modules/preact/dist/preact.mjs
+++ b/node_modules/preact/dist/preact.mjs
@@ -1,2 +1,2 @@
-var n,l,u,i,t,o,r,f={},e=[],c=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function s(n,l){for(var u in l)n[u]=l[u];return n}function a(n){var l=n.parentNode;l&&l.removeChild(n)}function v(n,l,u){var i,t,o,r=arguments,f={};for(o in l)"key"==o?i=l[o]:"ref"==o?t=l[o]:f[o]=l[o];if(arguments.length>3)for(u=[u],o=3;o<arguments.length;o++)u.push(r[o]);if(null!=u&&(f.children=u),"function"==typeof n&&null!=n.defaultProps)for(o in n.defaultProps)void 0===f[o]&&(f[o]=n.defaultProps[o]);return h(n,f,i,t,null)}function h(l,u,i,t,o){var r={type:l,props:u,key:i,ref:t,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,constructor:void 0,__v:o};return null==o&&(r.__v=r),null!=n.vnode&&n.vnode(r),r}function y(){return{current:null}}function p(n){return n.children}function d(n,l){this.props=n,this.context=l}function _(n,l){if(null==l)return n.__?_(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return"function"==typeof n.type?_(n):null}function w(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return w(n)}}function k(l){(!l.__d&&(l.__d=!0)&&u.push(l)&&!m.__r++||t!==n.debounceRendering)&&((t=n.debounceRendering)||i)(m)}function m(){for(var n;m.__r=u.length;)n=u.sort(function(n,l){return n.__v.__b-l.__v.__b}),u=[],n.some(function(n){var l,u,i,t,o,r,f;n.__d&&(r=(o=(l=n).__v).__e,(f=l.__P)&&(u=[],(i=s({},o)).__v=i,t=T(f,o,i,l.__n,void 0!==f.ownerSVGElement,null,u,null==r?_(o):r),$(u,o),t!=r&&w(o)))})}function g(n,l,u,i,t,o,r,c,s,v){var y,d,w,k,m,g,b,A=i&&i.__k||e,P=A.length;for(s==f&&(s=null!=r?r[0]:P?_(i,0):null),u.__k=[],y=0;y<l.length;y++)if(null!=(k=u.__k[y]=null==(k=l[y])||"boolean"==typeof k?null:"string"==typeof k||"number"==typeof k?h(null,k,null,null,k):Array.isArray(k)?h(p,{children:k},null,null,null):null!=k.__e||null!=k.__c?h(k.type,k.props,k.key,null,k.__v):k)){if(k.__=u,k.__b=u.__b+1,null===(w=A[y])||w&&k.key==w.key&&k.type===w.type)A[y]=void 0;else for(d=0;d<P;d++){if((w=A[d])&&k.key==w.key&&k.type===w.type){A[d]=void 0;break}w=null}m=T(n,k,w=w||f,t,o,r,c,s,v),(d=k.ref)&&w.ref!=d&&(b||(b=[]),w.ref&&b.push(w.ref,null,k),b.push(d,k.__c||m,k)),null!=m?(null==g&&(g=m),s=x(n,k,w,A,r,m,s),v||"option"!=u.type?"function"==typeof u.type&&(u.__d=s):n.value=""):s&&w.__e==s&&s.parentNode!=n&&(s=_(w))}if(u.__e=g,null!=r&&"function"!=typeof u.type)for(y=r.length;y--;)null!=r[y]&&a(r[y]);for(y=P;y--;)null!=A[y]&&I(A[y],A[y]);if(b)for(y=0;y<b.length;y++)H(b[y],b[++y],b[++y])}function b(n,l){return l=l||[],null==n||"boolean"==typeof n||(Array.isArray(n)?n.some(function(n){b(n,l)}):l.push(n)),l}function x(n,l,u,i,t,o,r){var f,e,c;if(void 0!==l.__d)f=l.__d,l.__d=void 0;else if(t==u||o!=r||null==o.parentNode)n:if(null==r||r.parentNode!==n)n.appendChild(o),f=null;else{for(e=r,c=0;(e=e.nextSibling)&&c<i.length;c+=2)if(e==o)break n;n.insertBefore(o,r),f=r}return void 0!==f?f:o.nextSibling}function A(n,l,u,i,t){var o;for(o in u)"children"===o||"key"===o||o in l||C(n,o,null,u[o],i);for(o in l)t&&"function"!=typeof l[o]||"children"===o||"key"===o||"value"===o||"checked"===o||u[o]===l[o]||C(n,o,l[o],u[o],i)}function P(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]=null==u?"":"number"!=typeof u||c.test(l)?u:u+"px"}function C(n,l,u,i,t){var o,r;if(t&&"className"==l&&(l="class"),"style"===l)if("string"==typeof u)n.style=u;else{if("string"==typeof i&&(n.style=i=""),i)for(l in i)u&&l in u||P(n.style,l,"");if(u)for(l in u)i&&u[l]===i[l]||P(n.style,l,u[l])}else"o"===l[0]&&"n"===l[1]?(o=l!==(l=l.replace(/Capture$/,"")),(r=l.toLowerCase())in n&&(l=r),l=l.slice(2),n.l||(n.l={}),n.l[l]=u,u?i||n.addEventListener(l,z,o):n.removeEventListener(l,z,o)):"list"!==l&&"tagName"!==l&&"form"!==l&&"type"!==l&&"size"!==l&&"download"!==l&&"href"!==l&&!t&&l in n?n[l]=null==u?"":u:"function"!=typeof u&&"dangerouslySetInnerHTML"!==l&&(l!==(l=l.replace(/xlink:?/,""))?null==u||!1===u?n.removeAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase()):n.setAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase(),u):null==u||!1===u&&!/^ar/.test(l)?n.removeAttribute(l):n.setAttribute(l,u))}function z(l){this.l[l.type](n.event?n.event(l):l)}function N(n,l,u){var i,t;for(i=0;i<n.__k.length;i++)(t=n.__k[i])&&(t.__=n,t.__e&&("function"==typeof t.type&&t.__k.length>1&&N(t,l,u),l=x(u,t,t,n.__k,null,t.__e,l),"function"==typeof n.type&&(n.__d=l)))}function T(l,u,i,t,o,r,f,e,c){var a,v,h,y,_,w,k,m,b,x,A,P=u.type;if(void 0!==u.constructor)return null;(a=n.__b)&&a(u);try{n:if("function"==typeof P){if(m=u.props,b=(a=P.contextType)&&t[a.__c],x=a?b?b.props.value:a.__:t,i.__c?k=(v=u.__c=i.__c).__=v.__E:("prototype"in P&&P.prototype.render?u.__c=v=new P(m,x):(u.__c=v=new d(m,x),v.constructor=P,v.render=L),b&&b.sub(v),v.props=m,v.state||(v.state={}),v.context=x,v.__n=t,h=v.__d=!0,v.__h=[]),null==v.__s&&(v.__s=v.state),null!=P.getDerivedStateFromProps&&(v.__s==v.state&&(v.__s=s({},v.__s)),s(v.__s,P.getDerivedStateFromProps(m,v.__s))),y=v.props,_=v.state,h)null==P.getDerivedStateFromProps&&null!=v.componentWillMount&&v.componentWillMount(),null!=v.componentDidMount&&v.__h.push(v.componentDidMount);else{if(null==P.getDerivedStateFromProps&&m!==y&&null!=v.componentWillReceiveProps&&v.componentWillReceiveProps(m,x),!v.__e&&null!=v.shouldComponentUpdate&&!1===v.shouldComponentUpdate(m,v.__s,x)||u.__v===i.__v){v.props=m,v.state=v.__s,u.__v!==i.__v&&(v.__d=!1),v.__v=u,u.__e=i.__e,u.__k=i.__k,v.__h.length&&f.push(v),N(u,e,l);break n}null!=v.componentWillUpdate&&v.componentWillUpdate(m,v.__s,x),null!=v.componentDidUpdate&&v.__h.push(function(){v.componentDidUpdate(y,_,w)})}v.context=x,v.props=m,v.state=v.__s,(a=n.__r)&&a(u),v.__d=!1,v.__v=u,v.__P=l,a=v.render(v.props,v.state,v.context),v.state=v.__s,null!=v.getChildContext&&(t=s(s({},t),v.getChildContext())),h||null==v.getSnapshotBeforeUpdate||(w=v.getSnapshotBeforeUpdate(y,_)),A=null!=a&&a.type==p&&null==a.key?a.props.children:a,g(l,Array.isArray(A)?A:[A],u,i,t,o,r,f,e,c),v.base=u.__e,v.__h.length&&f.push(v),k&&(v.__E=v.__=null),v.__e=!1}else null==r&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=j(i.__e,u,i,t,o,r,f,c);(a=n.diffed)&&a(u)}catch(l){u.__v=null,n.__e(l,u,i)}return u.__e}function $(l,u){n.__c&&n.__c(u,l),l.some(function(u){try{l=u.__h,u.__h=[],l.some(function(n){n.call(u)})}catch(l){n.__e(l,u.__v)}})}function j(n,l,u,i,t,o,r,c){var s,a,v,h,y,p=u.props,d=l.props;if(t="svg"===l.type||t,null!=o)for(s=0;s<o.length;s++)if(null!=(a=o[s])&&((null===l.type?3===a.nodeType:a.localName===l.type)||n==a)){n=a,o[s]=null;break}if(null==n){if(null===l.type)return document.createTextNode(d);n=t?document.createElementNS("http://www.w3.org/2000/svg",l.type):document.createElement(l.type,d.is&&{is:d.is}),o=null,c=!1}if(null===l.type)p!==d&&n.data!==d&&(n.data=d);else{if(null!=o&&(o=e.slice.call(n.childNodes)),v=(p=u.props||f).dangerouslySetInnerHTML,h=d.dangerouslySetInnerHTML,!c){if(null!=o)for(p={},y=0;y<n.attributes.length;y++)p[n.attributes[y].name]=n.attributes[y].value;(h||v)&&(h&&v&&h.__html==v.__html||(n.innerHTML=h&&h.__html||""))}A(n,d,p,t,c),h?l.__k=[]:(s=l.props.children,g(n,Array.isArray(s)?s:[s],l,u,i,"foreignObject"!==l.type&&t,o,r,f,c)),c||("value"in d&&void 0!==(s=d.value)&&s!==n.value&&C(n,"value",s,p.value,!1),"checked"in d&&void 0!==(s=d.checked)&&s!==n.checked&&C(n,"checked",s,p.checked,!1))}return n}function H(l,u,i){try{"function"==typeof l?l(u):l.current=u}catch(l){n.__e(l,i)}}function I(l,u,i){var t,o,r;if(n.unmount&&n.unmount(l),(t=l.ref)&&(t.current&&t.current!==l.__e||H(t,null,u)),i||"function"==typeof l.type||(i=null!=(o=l.__e)),l.__e=l.__d=void 0,null!=(t=l.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount()}catch(l){n.__e(l,u)}t.base=t.__P=null}if(t=l.__k)for(r=0;r<t.length;r++)t[r]&&I(t[r],u,i);null!=o&&a(o)}function L(n,l,u){return this.constructor(n,u)}function M(l,u,i){var t,r,c;n.__&&n.__(l,u),r=(t=i===o)?null:i&&i.__k||u.__k,l=v(p,null,[l]),c=[],T(u,(t?u:i||u).__k=l,r||f,f,void 0!==u.ownerSVGElement,i&&!t?[i]:r?null:u.childNodes.length?e.slice.call(u.childNodes):null,c,i||f,t),$(c,l)}function O(n,l){M(n,l,o)}function S(n,l,u){var i,t,o,r=arguments,f=s({},n.props);for(o in l)"key"==o?i=l[o]:"ref"==o?t=l[o]:f[o]=l[o];if(arguments.length>3)for(u=[u],o=3;o<arguments.length;o++)u.push(r[o]);return null!=u&&(f.children=u),h(n.type,f,i||n.key,t||n.ref,null)}function q(n,l){var u={__c:l="__cC"+r++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n,u,i){return this.getChildContext||(u=[],(i={})[l]=this,this.getChildContext=function(){return i},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(k)},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n={__e:function(n,l){for(var u,i;l=l.__;)if((u=l.__c)&&!u.__)try{if(u.constructor&&null!=u.constructor.getDerivedStateFromError&&(i=!0,u.setState(u.constructor.getDerivedStateFromError(n))),null!=u.componentDidCatch&&(i=!0,u.componentDidCatch(n)),i)return k(u.__E=u)}catch(l){n=l}throw n}},l=function(n){return null!=n&&void 0===n.constructor},d.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=s({},this.state),"function"==typeof n&&(n=n(s({},u),this.props)),n&&s(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),k(this))},d.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),k(this))},d.prototype.render=p,u=[],i="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,m.__r=0,o=f,r=0;export{M as render,O as hydrate,v as createElement,v as h,p as Fragment,y as createRef,l as isValidElement,d as Component,S as cloneElement,q as createContext,b as toChildArray,I as __u,n as options};
+var n,l,u,i,t,o,r,f={},e=[],c=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function s(n,l){for(var u in l)n[u]=l[u];return n}function a(n){var l=n.parentNode;l&&l.removeChild(n)}function v(n,l,u){var i,t,o,r=arguments,f={};for(o in l)"key"==o?i=l[o]:"ref"==o?t=l[o]:f[o]=l[o];if(arguments.length>3)for(u=[u],o=3;o<arguments.length;o++)u.push(r[o]);if(null!=u&&(f.children=u),"function"==typeof n&&null!=n.defaultProps)for(o in n.defaultProps)void 0===f[o]&&(f[o]=n.defaultProps[o]);return h(n,f,i,t,null)}function h(l,u,i,t,o){var r={type:l,props:u,key:i,ref:t,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,constructor:void 0,__v:o};return null==o&&(r.__v=r),null!=n.vnode&&n.vnode(r),r}function y(){return{current:null}}function p(n){return n.children}function d(n,l){this.props=n,this.context=l}function _(n,l){if(null==l)return n.__?_(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return"function"==typeof n.type?_(n):null}function w(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return w(n)}}function k(l){(!l.__d&&(l.__d=!0)&&u.push(l)&&!m.__r++||t!==n.debounceRendering)&&((t=n.debounceRendering)||i)(m)}function m(){for(var n;m.__r=u.length;)n=u.sort(function(n,l){return n.__v.__b-l.__v.__b}),u=[],n.some(function(n){var l,u,i,t,o,r,f;n.__d&&(r=(o=(l=n).__v).__e,(f=l.__P)&&(u=[],(i=s({},o)).__v=i,t=$(f,o,i,l.__n,void 0!==f.ownerSVGElement,null,u,null==r?_(o):r),j(u,o),t!=r&&w(o)))})}function g(n,l,u,i,t,o,r,c,s,v){var y,d,w,k,m,g,b,A=i&&i.__k||e,P=A.length;for(s==f&&(s=null!=r?r[0]:P?_(i,0):null),u.__k=[],y=0;y<l.length;y++)if(null!=(k=u.__k[y]=null==(k=l[y])||"boolean"==typeof k?null:"string"==typeof k||"number"==typeof k?h(null,k,null,null,k):Array.isArray(k)?h(p,{children:k},null,null,null):null!=k.__e||null!=k.__c?h(k.type,k.props,k.key,null,k.__v):k)){if(k.__=u,k.__b=u.__b+1,null===(w=A[y])||w&&k.key==w.key&&k.type===w.type)A[y]=void 0;else for(d=0;d<P;d++){if((w=A[d])&&k.key==w.key&&k.type===w.type){A[d]=void 0;break}w=null}m=$(n,k,w=w||f,t,o,r,c,s,v),(d=k.ref)&&w.ref!=d&&(b||(b=[]),w.ref&&b.push(w.ref,null,k),b.push(d,k.__c||m,k)),null!=m?(null==g&&(g=m),s=x(n,k,w,A,r,m,s),v||"option"!=u.type?"function"==typeof u.type&&(u.__d=s):n.value=""):s&&w.__e==s&&s.parentNode!=n&&(s=_(w))}if(u.__e=g,null!=r&&"function"!=typeof u.type)for(y=r.length;y--;)null!=r[y]&&a(r[y]);for(y=P;y--;)null!=A[y]&&L(A[y],A[y]);if(b)for(y=0;y<b.length;y++)I(b[y],b[++y],b[++y])}function b(n,l){return l=l||[],null==n||"boolean"==typeof n||(Array.isArray(n)?n.some(function(n){b(n,l)}):l.push(n)),l}function x(n,l,u,i,t,o,r){var f,e,c;if(void 0!==l.__d)f=l.__d,l.__d=void 0;else if(t==u||o!=r||null==o.parentNode)n:if(null==r||r.parentNode!==n)n.appendChild(o),f=null;else{for(e=r,c=0;(e=e.nextSibling)&&c<i.length;c+=2)if(e==o)break n;n.insertBefore(o,r),f=r}return void 0!==f?f:o.nextSibling}function A(n,l,u,i,t){var o;for(o in u)"children"===o||"key"===o||o in l||C(n,o,null,u[o],i);for(o in l)t&&"function"!=typeof l[o]||"children"===o||"key"===o||"value"===o||"checked"===o||u[o]===l[o]||C(n,o,l[o],u[o],i)}function P(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]=null==u?"":"number"!=typeof u||c.test(l)?u:u+"px"}function C(n,l,u,i,t){var o,r,f;if(t&&"className"==l&&(l="class"),"style"===l)if("string"==typeof u)n.style.cssText=u;else{if("string"==typeof i&&(n.style.cssText=i=""),i)for(l in i)u&&l in u||P(n.style,l,"");if(u)for(l in u)i&&u[l]===i[l]||P(n.style,l,u[l])}else"o"===l[0]&&"n"===l[1]?(o=l!==(l=l.replace(/Capture$/,"")),(r=l.toLowerCase())in n&&(l=r),l=l.slice(2),n.l||(n.l={}),n.l[l+o]=u,f=o?N:z,u?i||n.addEventListener(l,f,o):n.removeEventListener(l,f,o)):"list"!==l&&"tagName"!==l&&"form"!==l&&"type"!==l&&"size"!==l&&"download"!==l&&"href"!==l&&!t&&l in n?n[l]=null==u?"":u:"function"!=typeof u&&"dangerouslySetInnerHTML"!==l&&(l!==(l=l.replace(/xlink:?/,""))?null==u||!1===u?n.removeAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase()):n.setAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase(),u):null==u||!1===u&&!/^ar/.test(l)?n.removeAttribute(l):n.setAttribute(l,u))}function z(l){this.l[l.type+!1](n.event?n.event(l):l)}function N(l){this.l[l.type+!0](n.event?n.event(l):l)}function T(n,l,u){var i,t;for(i=0;i<n.__k.length;i++)(t=n.__k[i])&&(t.__=n,t.__e&&("function"==typeof t.type&&t.__k.length>1&&T(t,l,u),l=x(u,t,t,n.__k,null,t.__e,l),"function"==typeof n.type&&(n.__d=l)))}function $(l,u,i,t,o,r,f,e,c){var a,v,h,y,_,w,k,m,b,x,A,P=u.type;if(void 0!==u.constructor)return null;(a=n.__b)&&a(u);try{n:if("function"==typeof P){if(m=u.props,b=(a=P.contextType)&&t[a.__c],x=a?b?b.props.value:a.__:t,i.__c?k=(v=u.__c=i.__c).__=v.__E:("prototype"in P&&P.prototype.render?u.__c=v=new P(m,x):(u.__c=v=new d(m,x),v.constructor=P,v.render=M),b&&b.sub(v),v.props=m,v.state||(v.state={}),v.context=x,v.__n=t,h=v.__d=!0,v.__h=[]),null==v.__s&&(v.__s=v.state),null!=P.getDerivedStateFromProps&&(v.__s==v.state&&(v.__s=s({},v.__s)),s(v.__s,P.getDerivedStateFromProps(m,v.__s))),y=v.props,_=v.state,h)null==P.getDerivedStateFromProps&&null!=v.componentWillMount&&v.componentWillMount(),null!=v.componentDidMount&&v.__h.push(v.componentDidMount);else{if(null==P.getDerivedStateFromProps&&m!==y&&null!=v.componentWillReceiveProps&&v.componentWillReceiveProps(m,x),!v.__e&&null!=v.shouldComponentUpdate&&!1===v.shouldComponentUpdate(m,v.__s,x)||u.__v===i.__v){v.props=m,v.state=v.__s,u.__v!==i.__v&&(v.__d=!1),v.__v=u,u.__e=i.__e,u.__k=i.__k,v.__h.length&&f.push(v),T(u,e,l);break n}null!=v.componentWillUpdate&&v.componentWillUpdate(m,v.__s,x),null!=v.componentDidUpdate&&v.__h.push(function(){v.componentDidUpdate(y,_,w)})}v.context=x,v.props=m,v.state=v.__s,(a=n.__r)&&a(u),v.__d=!1,v.__v=u,v.__P=l,a=v.render(v.props,v.state,v.context),v.state=v.__s,null!=v.getChildContext&&(t=s(s({},t),v.getChildContext())),h||null==v.getSnapshotBeforeUpdate||(w=v.getSnapshotBeforeUpdate(y,_)),A=null!=a&&a.type==p&&null==a.key?a.props.children:a,g(l,Array.isArray(A)?A:[A],u,i,t,o,r,f,e,c),v.base=u.__e,v.__h.length&&f.push(v),k&&(v.__E=v.__=null),v.__e=!1}else null==r&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=H(i.__e,u,i,t,o,r,f,c);(a=n.diffed)&&a(u)}catch(l){u.__v=null,n.__e(l,u,i)}return u.__e}function j(l,u){n.__c&&n.__c(u,l),l.some(function(u){try{l=u.__h,u.__h=[],l.some(function(n){n.call(u)})}catch(l){n.__e(l,u.__v)}})}function H(n,l,u,i,t,o,r,c){var s,a,v,h,y,p=u.props,d=l.props;if(t="svg"===l.type||t,null!=o)for(s=0;s<o.length;s++)if(null!=(a=o[s])&&((null===l.type?3===a.nodeType:a.localName===l.type)||n==a)){n=a,o[s]=null;break}if(null==n){if(null===l.type)return document.createTextNode(d);n=t?document.createElementNS("http://www.w3.org/2000/svg",l.type):document.createElement(l.type,d.is&&{is:d.is}),o=null,c=!1}if(null===l.type)p!==d&&n.data!==d&&(n.data=d);else{if(null!=o&&(o=e.slice.call(n.childNodes)),v=(p=u.props||f).dangerouslySetInnerHTML,h=d.dangerouslySetInnerHTML,!c){if(null!=o)for(p={},y=0;y<n.attributes.length;y++)p[n.attributes[y].name]=n.attributes[y].value;(h||v)&&(h&&(v&&h.__html==v.__html||h.__html===n.innerHTML)||(n.innerHTML=h&&h.__html||""))}A(n,d,p,t,c),h?l.__k=[]:(s=l.props.children,g(n,Array.isArray(s)?s:[s],l,u,i,"foreignObject"!==l.type&&t,o,r,f,c)),c||("value"in d&&void 0!==(s=d.value)&&s!==n.value&&C(n,"value",s,p.value,!1),"checked"in d&&void 0!==(s=d.checked)&&s!==n.checked&&C(n,"checked",s,p.checked,!1))}return n}function I(l,u,i){try{"function"==typeof l?l(u):l.current=u}catch(l){n.__e(l,i)}}function L(l,u,i){var t,o,r;if(n.unmount&&n.unmount(l),(t=l.ref)&&(t.current&&t.current!==l.__e||I(t,null,u)),i||"function"==typeof l.type||(i=null!=(o=l.__e)),l.__e=l.__d=void 0,null!=(t=l.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount()}catch(l){n.__e(l,u)}t.base=t.__P=null}if(t=l.__k)for(r=0;r<t.length;r++)t[r]&&L(t[r],u,i);null!=o&&a(o)}function M(n,l,u){return this.constructor(n,u)}function O(l,u,i){var t,r,c;n.__&&n.__(l,u),r=(t=i===o)?null:i&&i.__k||u.__k,l=v(p,null,[l]),c=[],$(u,(t?u:i||u).__k=l,r||f,f,void 0!==u.ownerSVGElement,i&&!t?[i]:r?null:u.childNodes.length?e.slice.call(u.childNodes):null,c,i||f,t),j(c,l)}function S(n,l){O(n,l,o)}function q(n,l,u){var i,t,o,r=arguments,f=s({},n.props);for(o in l)"key"==o?i=l[o]:"ref"==o?t=l[o]:f[o]=l[o];if(arguments.length>3)for(u=[u],o=3;o<arguments.length;o++)u.push(r[o]);return null!=u&&(f.children=u),h(n.type,f,i||n.key,t||n.ref,null)}function B(n,l){var u={__c:l="__cC"+r++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n,u,i){return this.getChildContext||(u=[],(i={})[l]=this,this.getChildContext=function(){return i},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(k)},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n={__e:function(n,l){for(var u,i;l=l.__;)if((u=l.__c)&&!u.__)try{if(u.constructor&&null!=u.constructor.getDerivedStateFromError&&(i=!0,u.setState(u.constructor.getDerivedStateFromError(n))),null!=u.componentDidCatch&&(i=!0,u.componentDidCatch(n)),i)return k(u.__E=u)}catch(l){n=l}throw n}},l=function(n){return null!=n&&void 0===n.constructor},d.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=s({},this.state),"function"==typeof n&&(n=n(s({},u),this.props)),n&&s(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),k(this))},d.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),k(this))},d.prototype.render=p,u=[],i="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,m.__r=0,o=f,r=0;export{O as render,S as hydrate,v as createElement,v as h,p as Fragment,y as createRef,l as isValidElement,d as Component,q as cloneElement,B as createContext,b as toChildArray,L as __u,n as options};
 //# sourceMappingURL=preact.module.js.map
diff --git a/node_modules/preact/dist/preact.module.js b/node_modules/preact/dist/preact.module.js
index 2d81e0c..ebd18c0 100644
--- a/node_modules/preact/dist/preact.module.js
+++ b/node_modules/preact/dist/preact.module.js
@@ -1,2 +1,2 @@
-var n,l,u,i,t,o,r,f={},e=[],c=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function s(n,l){for(var u in l)n[u]=l[u];return n}function a(n){var l=n.parentNode;l&&l.removeChild(n)}function v(n,l,u){var i,t,o,r=arguments,f={};for(o in l)"key"==o?i=l[o]:"ref"==o?t=l[o]:f[o]=l[o];if(arguments.length>3)for(u=[u],o=3;o<arguments.length;o++)u.push(r[o]);if(null!=u&&(f.children=u),"function"==typeof n&&null!=n.defaultProps)for(o in n.defaultProps)void 0===f[o]&&(f[o]=n.defaultProps[o]);return h(n,f,i,t,null)}function h(l,u,i,t,o){var r={type:l,props:u,key:i,ref:t,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,constructor:void 0,__v:o};return null==o&&(r.__v=r),null!=n.vnode&&n.vnode(r),r}function y(){return{current:null}}function p(n){return n.children}function d(n,l){this.props=n,this.context=l}function _(n,l){if(null==l)return n.__?_(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return"function"==typeof n.type?_(n):null}function w(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return w(n)}}function k(l){(!l.__d&&(l.__d=!0)&&u.push(l)&&!m.__r++||t!==n.debounceRendering)&&((t=n.debounceRendering)||i)(m)}function m(){for(var n;m.__r=u.length;)n=u.sort(function(n,l){return n.__v.__b-l.__v.__b}),u=[],n.some(function(n){var l,u,i,t,o,r,f;n.__d&&(r=(o=(l=n).__v).__e,(f=l.__P)&&(u=[],(i=s({},o)).__v=i,t=T(f,o,i,l.__n,void 0!==f.ownerSVGElement,null,u,null==r?_(o):r),$(u,o),t!=r&&w(o)))})}function g(n,l,u,i,t,o,r,c,s,v){var y,d,w,k,m,g,b,A=i&&i.__k||e,P=A.length;for(s==f&&(s=null!=r?r[0]:P?_(i,0):null),u.__k=[],y=0;y<l.length;y++)if(null!=(k=u.__k[y]=null==(k=l[y])||"boolean"==typeof k?null:"string"==typeof k||"number"==typeof k?h(null,k,null,null,k):Array.isArray(k)?h(p,{children:k},null,null,null):null!=k.__e||null!=k.__c?h(k.type,k.props,k.key,null,k.__v):k)){if(k.__=u,k.__b=u.__b+1,null===(w=A[y])||w&&k.key==w.key&&k.type===w.type)A[y]=void 0;else for(d=0;d<P;d++){if((w=A[d])&&k.key==w.key&&k.type===w.type){A[d]=void 0;break}w=null}m=T(n,k,w=w||f,t,o,r,c,s,v),(d=k.ref)&&w.ref!=d&&(b||(b=[]),w.ref&&b.push(w.ref,null,k),b.push(d,k.__c||m,k)),null!=m?(null==g&&(g=m),s=x(n,k,w,A,r,m,s),v||"option"!=u.type?"function"==typeof u.type&&(u.__d=s):n.value=""):s&&w.__e==s&&s.parentNode!=n&&(s=_(w))}if(u.__e=g,null!=r&&"function"!=typeof u.type)for(y=r.length;y--;)null!=r[y]&&a(r[y]);for(y=P;y--;)null!=A[y]&&I(A[y],A[y]);if(b)for(y=0;y<b.length;y++)H(b[y],b[++y],b[++y])}function b(n,l){return l=l||[],null==n||"boolean"==typeof n||(Array.isArray(n)?n.some(function(n){b(n,l)}):l.push(n)),l}function x(n,l,u,i,t,o,r){var f,e,c;if(void 0!==l.__d)f=l.__d,l.__d=void 0;else if(t==u||o!=r||null==o.parentNode)n:if(null==r||r.parentNode!==n)n.appendChild(o),f=null;else{for(e=r,c=0;(e=e.nextSibling)&&c<i.length;c+=2)if(e==o)break n;n.insertBefore(o,r),f=r}return void 0!==f?f:o.nextSibling}function A(n,l,u,i,t){var o;for(o in u)"children"===o||"key"===o||o in l||C(n,o,null,u[o],i);for(o in l)t&&"function"!=typeof l[o]||"children"===o||"key"===o||"value"===o||"checked"===o||u[o]===l[o]||C(n,o,l[o],u[o],i)}function P(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]=null==u?"":"number"!=typeof u||c.test(l)?u:u+"px"}function C(n,l,u,i,t){var o,r;if(t&&"className"==l&&(l="class"),"style"===l)if("string"==typeof u)n.style=u;else{if("string"==typeof i&&(n.style=i=""),i)for(l in i)u&&l in u||P(n.style,l,"");if(u)for(l in u)i&&u[l]===i[l]||P(n.style,l,u[l])}else"o"===l[0]&&"n"===l[1]?(o=l!==(l=l.replace(/Capture$/,"")),(r=l.toLowerCase())in n&&(l=r),l=l.slice(2),n.l||(n.l={}),n.l[l]=u,u?i||n.addEventListener(l,z,o):n.removeEventListener(l,z,o)):"list"!==l&&"tagName"!==l&&"form"!==l&&"type"!==l&&"size"!==l&&"download"!==l&&"href"!==l&&!t&&l in n?n[l]=null==u?"":u:"function"!=typeof u&&"dangerouslySetInnerHTML"!==l&&(l!==(l=l.replace(/xlink:?/,""))?null==u||!1===u?n.removeAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase()):n.setAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase(),u):null==u||!1===u&&!/^ar/.test(l)?n.removeAttribute(l):n.setAttribute(l,u))}function z(l){this.l[l.type](n.event?n.event(l):l)}function N(n,l,u){var i,t;for(i=0;i<n.__k.length;i++)(t=n.__k[i])&&(t.__=n,t.__e&&("function"==typeof t.type&&t.__k.length>1&&N(t,l,u),l=x(u,t,t,n.__k,null,t.__e,l),"function"==typeof n.type&&(n.__d=l)))}function T(l,u,i,t,o,r,f,e,c){var a,v,h,y,_,w,k,m,b,x,A,P=u.type;if(void 0!==u.constructor)return null;(a=n.__b)&&a(u);try{n:if("function"==typeof P){if(m=u.props,b=(a=P.contextType)&&t[a.__c],x=a?b?b.props.value:a.__:t,i.__c?k=(v=u.__c=i.__c).__=v.__E:("prototype"in P&&P.prototype.render?u.__c=v=new P(m,x):(u.__c=v=new d(m,x),v.constructor=P,v.render=L),b&&b.sub(v),v.props=m,v.state||(v.state={}),v.context=x,v.__n=t,h=v.__d=!0,v.__h=[]),null==v.__s&&(v.__s=v.state),null!=P.getDerivedStateFromProps&&(v.__s==v.state&&(v.__s=s({},v.__s)),s(v.__s,P.getDerivedStateFromProps(m,v.__s))),y=v.props,_=v.state,h)null==P.getDerivedStateFromProps&&null!=v.componentWillMount&&v.componentWillMount(),null!=v.componentDidMount&&v.__h.push(v.componentDidMount);else{if(null==P.getDerivedStateFromProps&&m!==y&&null!=v.componentWillReceiveProps&&v.componentWillReceiveProps(m,x),!v.__e&&null!=v.shouldComponentUpdate&&!1===v.shouldComponentUpdate(m,v.__s,x)||u.__v===i.__v){v.props=m,v.state=v.__s,u.__v!==i.__v&&(v.__d=!1),v.__v=u,u.__e=i.__e,u.__k=i.__k,v.__h.length&&f.push(v),N(u,e,l);break n}null!=v.componentWillUpdate&&v.componentWillUpdate(m,v.__s,x),null!=v.componentDidUpdate&&v.__h.push(function(){v.componentDidUpdate(y,_,w)})}v.context=x,v.props=m,v.state=v.__s,(a=n.__r)&&a(u),v.__d=!1,v.__v=u,v.__P=l,a=v.render(v.props,v.state,v.context),v.state=v.__s,null!=v.getChildContext&&(t=s(s({},t),v.getChildContext())),h||null==v.getSnapshotBeforeUpdate||(w=v.getSnapshotBeforeUpdate(y,_)),A=null!=a&&a.type==p&&null==a.key?a.props.children:a,g(l,Array.isArray(A)?A:[A],u,i,t,o,r,f,e,c),v.base=u.__e,v.__h.length&&f.push(v),k&&(v.__E=v.__=null),v.__e=!1}else null==r&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=j(i.__e,u,i,t,o,r,f,c);(a=n.diffed)&&a(u)}catch(l){u.__v=null,n.__e(l,u,i)}return u.__e}function $(l,u){n.__c&&n.__c(u,l),l.some(function(u){try{l=u.__h,u.__h=[],l.some(function(n){n.call(u)})}catch(l){n.__e(l,u.__v)}})}function j(n,l,u,i,t,o,r,c){var s,a,v,h,y,p=u.props,d=l.props;if(t="svg"===l.type||t,null!=o)for(s=0;s<o.length;s++)if(null!=(a=o[s])&&((null===l.type?3===a.nodeType:a.localName===l.type)||n==a)){n=a,o[s]=null;break}if(null==n){if(null===l.type)return document.createTextNode(d);n=t?document.createElementNS("http://www.w3.org/2000/svg",l.type):document.createElement(l.type,d.is&&{is:d.is}),o=null,c=!1}if(null===l.type)p!==d&&n.data!==d&&(n.data=d);else{if(null!=o&&(o=e.slice.call(n.childNodes)),v=(p=u.props||f).dangerouslySetInnerHTML,h=d.dangerouslySetInnerHTML,!c){if(null!=o)for(p={},y=0;y<n.attributes.length;y++)p[n.attributes[y].name]=n.attributes[y].value;(h||v)&&(h&&v&&h.__html==v.__html||(n.innerHTML=h&&h.__html||""))}A(n,d,p,t,c),h?l.__k=[]:(s=l.props.children,g(n,Array.isArray(s)?s:[s],l,u,i,"foreignObject"!==l.type&&t,o,r,f,c)),c||("value"in d&&void 0!==(s=d.value)&&s!==n.value&&C(n,"value",s,p.value,!1),"checked"in d&&void 0!==(s=d.checked)&&s!==n.checked&&C(n,"checked",s,p.checked,!1))}return n}function H(l,u,i){try{"function"==typeof l?l(u):l.current=u}catch(l){n.__e(l,i)}}function I(l,u,i){var t,o,r;if(n.unmount&&n.unmount(l),(t=l.ref)&&(t.current&&t.current!==l.__e||H(t,null,u)),i||"function"==typeof l.type||(i=null!=(o=l.__e)),l.__e=l.__d=void 0,null!=(t=l.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount()}catch(l){n.__e(l,u)}t.base=t.__P=null}if(t=l.__k)for(r=0;r<t.length;r++)t[r]&&I(t[r],u,i);null!=o&&a(o)}function L(n,l,u){return this.constructor(n,u)}function M(l,u,i){var t,r,c;n.__&&n.__(l,u),r=(t=i===o)?null:i&&i.__k||u.__k,l=v(p,null,[l]),c=[],T(u,(t?u:i||u).__k=l,r||f,f,void 0!==u.ownerSVGElement,i&&!t?[i]:r?null:u.childNodes.length?e.slice.call(u.childNodes):null,c,i||f,t),$(c,l)}function O(n,l){M(n,l,o)}function S(n,l,u){var i,t,o,r=arguments,f=s({},n.props);for(o in l)"key"==o?i=l[o]:"ref"==o?t=l[o]:f[o]=l[o];if(arguments.length>3)for(u=[u],o=3;o<arguments.length;o++)u.push(r[o]);return null!=u&&(f.children=u),h(n.type,f,i||n.key,t||n.ref,null)}function q(n,l){var u={__c:l="__cC"+r++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n,u,i){return this.getChildContext||(u=[],(i={})[l]=this,this.getChildContext=function(){return i},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(k)},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n={__e:function(n,l){for(var u,i;l=l.__;)if((u=l.__c)&&!u.__)try{if(u.constructor&&null!=u.constructor.getDerivedStateFromError&&(i=!0,u.setState(u.constructor.getDerivedStateFromError(n))),null!=u.componentDidCatch&&(i=!0,u.componentDidCatch(n)),i)return k(u.__E=u)}catch(l){n=l}throw n}},l=function(n){return null!=n&&void 0===n.constructor},d.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=s({},this.state),"function"==typeof n&&(n=n(s({},u),this.props)),n&&s(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),k(this))},d.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),k(this))},d.prototype.render=p,u=[],i="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,m.__r=0,o=f,r=0;export{M as render,O as hydrate,v as createElement,v as h,p as Fragment,y as createRef,l as isValidElement,d as Component,S as cloneElement,q as createContext,b as toChildArray,I as __u,n as options};
+var n,l,u,i,t,o,r,f={},e=[],c=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function s(n,l){for(var u in l)n[u]=l[u];return n}function a(n){var l=n.parentNode;l&&l.removeChild(n)}function v(n,l,u){var i,t,o,r=arguments,f={};for(o in l)"key"==o?i=l[o]:"ref"==o?t=l[o]:f[o]=l[o];if(arguments.length>3)for(u=[u],o=3;o<arguments.length;o++)u.push(r[o]);if(null!=u&&(f.children=u),"function"==typeof n&&null!=n.defaultProps)for(o in n.defaultProps)void 0===f[o]&&(f[o]=n.defaultProps[o]);return h(n,f,i,t,null)}function h(l,u,i,t,o){var r={type:l,props:u,key:i,ref:t,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,constructor:void 0,__v:o};return null==o&&(r.__v=r),null!=n.vnode&&n.vnode(r),r}function y(){return{current:null}}function p(n){return n.children}function d(n,l){this.props=n,this.context=l}function _(n,l){if(null==l)return n.__?_(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return"function"==typeof n.type?_(n):null}function w(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return w(n)}}function k(l){(!l.__d&&(l.__d=!0)&&u.push(l)&&!m.__r++||t!==n.debounceRendering)&&((t=n.debounceRendering)||i)(m)}function m(){for(var n;m.__r=u.length;)n=u.sort(function(n,l){return n.__v.__b-l.__v.__b}),u=[],n.some(function(n){var l,u,i,t,o,r,f;n.__d&&(r=(o=(l=n).__v).__e,(f=l.__P)&&(u=[],(i=s({},o)).__v=i,t=$(f,o,i,l.__n,void 0!==f.ownerSVGElement,null,u,null==r?_(o):r),j(u,o),t!=r&&w(o)))})}function g(n,l,u,i,t,o,r,c,s,v){var y,d,w,k,m,g,b,A=i&&i.__k||e,P=A.length;for(s==f&&(s=null!=r?r[0]:P?_(i,0):null),u.__k=[],y=0;y<l.length;y++)if(null!=(k=u.__k[y]=null==(k=l[y])||"boolean"==typeof k?null:"string"==typeof k||"number"==typeof k?h(null,k,null,null,k):Array.isArray(k)?h(p,{children:k},null,null,null):null!=k.__e||null!=k.__c?h(k.type,k.props,k.key,null,k.__v):k)){if(k.__=u,k.__b=u.__b+1,null===(w=A[y])||w&&k.key==w.key&&k.type===w.type)A[y]=void 0;else for(d=0;d<P;d++){if((w=A[d])&&k.key==w.key&&k.type===w.type){A[d]=void 0;break}w=null}m=$(n,k,w=w||f,t,o,r,c,s,v),(d=k.ref)&&w.ref!=d&&(b||(b=[]),w.ref&&b.push(w.ref,null,k),b.push(d,k.__c||m,k)),null!=m?(null==g&&(g=m),s=x(n,k,w,A,r,m,s),v||"option"!=u.type?"function"==typeof u.type&&(u.__d=s):n.value=""):s&&w.__e==s&&s.parentNode!=n&&(s=_(w))}if(u.__e=g,null!=r&&"function"!=typeof u.type)for(y=r.length;y--;)null!=r[y]&&a(r[y]);for(y=P;y--;)null!=A[y]&&L(A[y],A[y]);if(b)for(y=0;y<b.length;y++)I(b[y],b[++y],b[++y])}function b(n,l){return l=l||[],null==n||"boolean"==typeof n||(Array.isArray(n)?n.some(function(n){b(n,l)}):l.push(n)),l}function x(n,l,u,i,t,o,r){var f,e,c;if(void 0!==l.__d)f=l.__d,l.__d=void 0;else if(t==u||o!=r||null==o.parentNode)n:if(null==r||r.parentNode!==n)n.appendChild(o),f=null;else{for(e=r,c=0;(e=e.nextSibling)&&c<i.length;c+=2)if(e==o)break n;n.insertBefore(o,r),f=r}return void 0!==f?f:o.nextSibling}function A(n,l,u,i,t){var o;for(o in u)"children"===o||"key"===o||o in l||C(n,o,null,u[o],i);for(o in l)t&&"function"!=typeof l[o]||"children"===o||"key"===o||"value"===o||"checked"===o||u[o]===l[o]||C(n,o,l[o],u[o],i)}function P(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]=null==u?"":"number"!=typeof u||c.test(l)?u:u+"px"}function C(n,l,u,i,t){var o,r,f;if(t&&"className"==l&&(l="class"),"style"===l)if("string"==typeof u)n.style.cssText=u;else{if("string"==typeof i&&(n.style.cssText=i=""),i)for(l in i)u&&l in u||P(n.style,l,"");if(u)for(l in u)i&&u[l]===i[l]||P(n.style,l,u[l])}else"o"===l[0]&&"n"===l[1]?(o=l!==(l=l.replace(/Capture$/,"")),(r=l.toLowerCase())in n&&(l=r),l=l.slice(2),n.l||(n.l={}),n.l[l+o]=u,f=o?N:z,u?i||n.addEventListener(l,f,o):n.removeEventListener(l,f,o)):"list"!==l&&"tagName"!==l&&"form"!==l&&"type"!==l&&"size"!==l&&"download"!==l&&"href"!==l&&!t&&l in n?n[l]=null==u?"":u:"function"!=typeof u&&"dangerouslySetInnerHTML"!==l&&(l!==(l=l.replace(/xlink:?/,""))?null==u||!1===u?n.removeAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase()):n.setAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase(),u):null==u||!1===u&&!/^ar/.test(l)?n.removeAttribute(l):n.setAttribute(l,u))}function z(l){this.l[l.type+!1](n.event?n.event(l):l)}function N(l){this.l[l.type+!0](n.event?n.event(l):l)}function T(n,l,u){var i,t;for(i=0;i<n.__k.length;i++)(t=n.__k[i])&&(t.__=n,t.__e&&("function"==typeof t.type&&t.__k.length>1&&T(t,l,u),l=x(u,t,t,n.__k,null,t.__e,l),"function"==typeof n.type&&(n.__d=l)))}function $(l,u,i,t,o,r,f,e,c){var a,v,h,y,_,w,k,m,b,x,A,P=u.type;if(void 0!==u.constructor)return null;(a=n.__b)&&a(u);try{n:if("function"==typeof P){if(m=u.props,b=(a=P.contextType)&&t[a.__c],x=a?b?b.props.value:a.__:t,i.__c?k=(v=u.__c=i.__c).__=v.__E:("prototype"in P&&P.prototype.render?u.__c=v=new P(m,x):(u.__c=v=new d(m,x),v.constructor=P,v.render=M),b&&b.sub(v),v.props=m,v.state||(v.state={}),v.context=x,v.__n=t,h=v.__d=!0,v.__h=[]),null==v.__s&&(v.__s=v.state),null!=P.getDerivedStateFromProps&&(v.__s==v.state&&(v.__s=s({},v.__s)),s(v.__s,P.getDerivedStateFromProps(m,v.__s))),y=v.props,_=v.state,h)null==P.getDerivedStateFromProps&&null!=v.componentWillMount&&v.componentWillMount(),null!=v.componentDidMount&&v.__h.push(v.componentDidMount);else{if(null==P.getDerivedStateFromProps&&m!==y&&null!=v.componentWillReceiveProps&&v.componentWillReceiveProps(m,x),!v.__e&&null!=v.shouldComponentUpdate&&!1===v.shouldComponentUpdate(m,v.__s,x)||u.__v===i.__v){v.props=m,v.state=v.__s,u.__v!==i.__v&&(v.__d=!1),v.__v=u,u.__e=i.__e,u.__k=i.__k,v.__h.length&&f.push(v),T(u,e,l);break n}null!=v.componentWillUpdate&&v.componentWillUpdate(m,v.__s,x),null!=v.componentDidUpdate&&v.__h.push(function(){v.componentDidUpdate(y,_,w)})}v.context=x,v.props=m,v.state=v.__s,(a=n.__r)&&a(u),v.__d=!1,v.__v=u,v.__P=l,a=v.render(v.props,v.state,v.context),v.state=v.__s,null!=v.getChildContext&&(t=s(s({},t),v.getChildContext())),h||null==v.getSnapshotBeforeUpdate||(w=v.getSnapshotBeforeUpdate(y,_)),A=null!=a&&a.type==p&&null==a.key?a.props.children:a,g(l,Array.isArray(A)?A:[A],u,i,t,o,r,f,e,c),v.base=u.__e,v.__h.length&&f.push(v),k&&(v.__E=v.__=null),v.__e=!1}else null==r&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=H(i.__e,u,i,t,o,r,f,c);(a=n.diffed)&&a(u)}catch(l){u.__v=null,n.__e(l,u,i)}return u.__e}function j(l,u){n.__c&&n.__c(u,l),l.some(function(u){try{l=u.__h,u.__h=[],l.some(function(n){n.call(u)})}catch(l){n.__e(l,u.__v)}})}function H(n,l,u,i,t,o,r,c){var s,a,v,h,y,p=u.props,d=l.props;if(t="svg"===l.type||t,null!=o)for(s=0;s<o.length;s++)if(null!=(a=o[s])&&((null===l.type?3===a.nodeType:a.localName===l.type)||n==a)){n=a,o[s]=null;break}if(null==n){if(null===l.type)return document.createTextNode(d);n=t?document.createElementNS("http://www.w3.org/2000/svg",l.type):document.createElement(l.type,d.is&&{is:d.is}),o=null,c=!1}if(null===l.type)p!==d&&n.data!==d&&(n.data=d);else{if(null!=o&&(o=e.slice.call(n.childNodes)),v=(p=u.props||f).dangerouslySetInnerHTML,h=d.dangerouslySetInnerHTML,!c){if(null!=o)for(p={},y=0;y<n.attributes.length;y++)p[n.attributes[y].name]=n.attributes[y].value;(h||v)&&(h&&(v&&h.__html==v.__html||h.__html===n.innerHTML)||(n.innerHTML=h&&h.__html||""))}A(n,d,p,t,c),h?l.__k=[]:(s=l.props.children,g(n,Array.isArray(s)?s:[s],l,u,i,"foreignObject"!==l.type&&t,o,r,f,c)),c||("value"in d&&void 0!==(s=d.value)&&s!==n.value&&C(n,"value",s,p.value,!1),"checked"in d&&void 0!==(s=d.checked)&&s!==n.checked&&C(n,"checked",s,p.checked,!1))}return n}function I(l,u,i){try{"function"==typeof l?l(u):l.current=u}catch(l){n.__e(l,i)}}function L(l,u,i){var t,o,r;if(n.unmount&&n.unmount(l),(t=l.ref)&&(t.current&&t.current!==l.__e||I(t,null,u)),i||"function"==typeof l.type||(i=null!=(o=l.__e)),l.__e=l.__d=void 0,null!=(t=l.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount()}catch(l){n.__e(l,u)}t.base=t.__P=null}if(t=l.__k)for(r=0;r<t.length;r++)t[r]&&L(t[r],u,i);null!=o&&a(o)}function M(n,l,u){return this.constructor(n,u)}function O(l,u,i){var t,r,c;n.__&&n.__(l,u),r=(t=i===o)?null:i&&i.__k||u.__k,l=v(p,null,[l]),c=[],$(u,(t?u:i||u).__k=l,r||f,f,void 0!==u.ownerSVGElement,i&&!t?[i]:r?null:u.childNodes.length?e.slice.call(u.childNodes):null,c,i||f,t),j(c,l)}function S(n,l){O(n,l,o)}function q(n,l,u){var i,t,o,r=arguments,f=s({},n.props);for(o in l)"key"==o?i=l[o]:"ref"==o?t=l[o]:f[o]=l[o];if(arguments.length>3)for(u=[u],o=3;o<arguments.length;o++)u.push(r[o]);return null!=u&&(f.children=u),h(n.type,f,i||n.key,t||n.ref,null)}function B(n,l){var u={__c:l="__cC"+r++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n,u,i){return this.getChildContext||(u=[],(i={})[l]=this,this.getChildContext=function(){return i},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(k)},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n={__e:function(n,l){for(var u,i;l=l.__;)if((u=l.__c)&&!u.__)try{if(u.constructor&&null!=u.constructor.getDerivedStateFromError&&(i=!0,u.setState(u.constructor.getDerivedStateFromError(n))),null!=u.componentDidCatch&&(i=!0,u.componentDidCatch(n)),i)return k(u.__E=u)}catch(l){n=l}throw n}},l=function(n){return null!=n&&void 0===n.constructor},d.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=s({},this.state),"function"==typeof n&&(n=n(s({},u),this.props)),n&&s(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),k(this))},d.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),k(this))},d.prototype.render=p,u=[],i="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,m.__r=0,o=f,r=0;export{O as render,S as hydrate,v as createElement,v as h,p as Fragment,y as createRef,l as isValidElement,d as Component,q as cloneElement,B as createContext,b as toChildArray,L as __u,n as options};
 //# sourceMappingURL=preact.module.js.map
diff --git a/node_modules/preact/dist/preact.module.js.map b/node_modules/preact/dist/preact.module.js.map
index 5822bd4..ea83164 100644
--- a/node_modules/preact/dist/preact.module.js.map
+++ b/node_modules/preact/dist/preact.module.js.map
@@ -1 +1 @@
-{"version":3,"file":"preact.module.js","sources":["../src/constants.js","../src/options.js","../src/create-element.js","../src/component.js","../src/render.js","../src/create-context.js","../src/util.js","../src/diff/children.js","../src/diff/props.js","../src/diff/index.js","../src/clone-element.js","../src/diff/catch-error.js"],"sourcesContent":["export const EMPTY_OBJ = {};\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n","import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n","import options from './options';\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * constructor for this virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\t// https://github.com/preactjs/preact/issues/1916\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\tif (children != null) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != null) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === undefined) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, null);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t// _nextDom must be initialized to undefined b/c it will eventually\n\t\t// be set to dom.nextSibling which can return `null` and it is important\n\t\t// to be able to distinguish between an uninitialized _nextDom and\n\t\t// a _nextDom that has been set to `null`\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\tconstructor: undefined,\n\t\t_original: original\n\t};\n\n\tif (original == null) vnode._original = vnode;\n\tif (options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is import('./internal').VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor === undefined;\n","import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function Component(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nComponent.prototype.setState = function(update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._vnode) {\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nComponent.prototype.forceUpdate = function(callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {import('./index').ComponentChildren | void}\n */\nComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._parent._children.indexOf(vnode) + 1)\n\t\t\t: null;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != null && sibling._dom != null) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : null;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {import('./internal').Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet vnode = component._vnode,\n\t\toldDom = vnode._dom,\n\t\tparentDom = component._parentDom;\n\n\tif (parentDom) {\n\t\tlet commitQueue = [];\n\t\tconst oldVNode = assign({}, vnode);\n\t\toldVNode._original = oldVNode;\n\n\t\tlet newDom = diff(\n\t\t\tparentDom,\n\t\t\tvnode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tparentDom.ownerSVGElement !== undefined,\n\t\t\tnull,\n\t\t\tcommitQueue,\n\t\t\toldDom == null ? getDomSibling(vnode) : oldDom\n\t\t);\n\t\tcommitRoot(commitQueue, vnode);\n\n\t\tif (newDom != oldDom) {\n\t\t\tupdateParentDomPointers(vnode);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./internal').VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != null && vnode._component != null) {\n\t\tvnode._dom = vnode._component.base = null;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != null && child._dom != null) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Component>}\n */\nlet rerenderQueue = [];\n\n/**\n * Asynchronously schedule a callback\n * @type {(cb: () => void) => void}\n */\n/* istanbul ignore next */\n// Note the following line isn't tree-shaken by rollup cuz of rollup/rollup#2566\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\n/**\n * Enqueue a rerender of a component\n * @param {import('./internal').Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet queue;\n\twhile ((process._rerenderCount = rerenderQueue.length)) {\n\t\tqueue = rerenderQueue.sort((a, b) => a._vnode._depth - b._vnode._depth);\n\t\trerenderQueue = [];\n\t\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t\t// process() calls from getting scheduled while `queue` is still being consumed.\n\t\tqueue.some(c => {\n\t\t\tif (c._dirty) renderComponent(c);\n\t\t});\n\t}\n}\nprocess._rerenderCount = 0;\n","import { EMPTY_OBJ, EMPTY_ARR } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\n\nconst IS_HYDRATE = EMPTY_OBJ;\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./index').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * render into\n * @param {Element | Text} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we\n\t// are in hydration mode or not by passing `IS_HYDRATE` instead of a\n\t// DOM element.\n\tlet isHydrating = replaceNode === IS_HYDRATE;\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? null\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\tvnode = createElement(Fragment, null, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\t((isHydrating ? parentDom : replaceNode || parentDom)._children = vnode),\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.ownerSVGElement !== undefined,\n\t\treplaceNode && !isHydrating\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t? null\n\t\t\t: parentDom.childNodes.length\n\t\t\t? EMPTY_ARR.slice.call(parentDom.childNodes)\n\t\t\t: null,\n\t\tcommitQueue,\n\t\treplaceNode || EMPTY_OBJ,\n\t\tisHydrating\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./index').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, IS_HYDRATE);\n}\n","import { enqueueRender } from './component';\n\nexport let i = 0;\n\nexport function createContext(defaultValue, contextId) {\n\tcontextId = '__cC' + i++;\n\n\tconst context = {\n\t\t_id: contextId,\n\t\t_defaultValue: defaultValue,\n\t\tConsumer(props, contextValue) {\n\t\t\t// return props.children(\n\t\t\t// \tcontext[contextId] ? context[contextId].props.value : defaultValue\n\t\t\t// );\n\t\t\treturn props.children(contextValue);\n\t\t},\n\t\tProvider(props, subs, ctx) {\n\t\t\tif (!this.getChildContext) {\n\t\t\t\tsubs = [];\n\t\t\t\tctx = {};\n\t\t\t\tctx[contextId] = this;\n\n\t\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\t\tthis.shouldComponentUpdate = function(_props) {\n\t\t\t\t\tif (this.props.value !== _props.value) {\n\t\t\t\t\t\t// I think the forced value propagation here was only needed when `options.debounceRendering` was being bypassed:\n\t\t\t\t\t\t// https://github.com/preactjs/preact/commit/4d339fb803bea09e9f198abf38ca1bf8ea4b7771#diff-54682ce380935a717e41b8bfc54737f6R358\n\t\t\t\t\t\t// In those cases though, even with the value corrected, we're double-rendering all nodes.\n\t\t\t\t\t\t// It might be better to just tell folks not to use force-sync mode.\n\t\t\t\t\t\t// Currently, using `useContext()` in a class component will overwrite its `this.context` value.\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context[contextId] = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\t\t\t\t\t\tsubs.some(enqueueRender);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.sub = c => {\n\t\t\t\t\tsubs.push(c);\n\t\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\t\tsubs.splice(subs.indexOf(c), 1);\n\t\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn props.children;\n\t\t}\n\t};\n\n\t// Devtools needs access to the context object when it\n\t// encounters a Provider. This is necessary to support\n\t// setting `displayName` on the context object instead\n\t// of on the component itself. See:\n\t// https://reactjs.org/docs/context.html#contextdisplayname\n\n\treturn (context.Provider._contextRef = context.Consumer.contextType = context);\n}\n","/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {Node} node The node to remove\n */\nexport function removeNode(node) {\n\tlet parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n","import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { removeNode } from '../util';\nimport { getDomSibling } from '../component';\n\n/**\n * Diff the children of a virtual node\n * @param {import('../internal').PreactElement} parentDom The DOM element whose\n * children are being diffed\n * @param {import('../index').ComponentChildren[]} renderResult\n * @param {import('../internal').VNode} newParentVNode The new virtual\n * node whose children should be diff'ed against oldParentVNode\n * @param {import('../internal').VNode} oldParentVNode The old virtual\n * node whose children should be diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by getChildContext\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {Node | Text} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet i, j, oldVNode, childVNode, newDom, firstChildDom, refs;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet oldChildrenLength = oldChildren.length;\n\n\t// Only in very specific places should this logic be invoked (top level `render` and `diffElementNodes`).\n\t// I'm using `EMPTY_OBJ` to signal when `diffChildren` is invoked in these situations. I can't use `null`\n\t// for this purpose, because `null` is a valid value for `oldDom` which can mean to skip to this logic\n\t// (e.g. if mounting a new tree in which the old DOM should be ignored (usually for Fragments).\n\tif (oldDom == EMPTY_OBJ) {\n\t\tif (excessDomChildren != null) {\n\t\t\toldDom = excessDomChildren[0];\n\t\t} else if (oldChildrenLength) {\n\t\t\toldDom = getDomSibling(oldParentVNode, 0);\n\t\t} else {\n\t\t\toldDom = null;\n\t\t}\n\t}\n\n\tnewParentVNode._children = [];\n\tfor (i = 0; i < renderResult.length; i++) {\n\t\tchildVNode = renderResult[i];\n\n\t\tif (childVNode == null || typeof childVNode == 'boolean') {\n\t\t\tchildVNode = newParentVNode._children[i] = null;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (typeof childVNode == 'string' || typeof childVNode == 'number') {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tnull,\n\t\t\t\tchildVNode,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t} else if (Array.isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (childVNode._dom != null || childVNode._component != null) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tnull,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\t// Terser removes the `continue` here and wraps the loop body\n\t\t// in a `if (childVNode) { ... } condition\n\t\tif (childVNode == null) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\t// Check if we find a corresponding element in oldChildren.\n\t\t// If found, delete the array item by setting to `undefined`.\n\t\t// We use `undefined`, as `null` is reserved for empty placeholders\n\t\t// (holes).\n\t\toldVNode = oldChildren[i];\n\n\t\tif (\n\t\t\toldVNode === null ||\n\t\t\t(oldVNode &&\n\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\tchildVNode.type === oldVNode.type)\n\t\t) {\n\t\t\toldChildren[i] = undefined;\n\t\t} else {\n\t\t\t// Either oldVNode === undefined or oldChildrenLength > 0,\n\t\t\t// so after this loop oldVNode == null or oldVNode is a valid value.\n\t\t\tfor (j = 0; j < oldChildrenLength; j++) {\n\t\t\t\toldVNode = oldChildren[j];\n\t\t\t\t// If childVNode is unkeyed, we only match similarly unkeyed nodes, otherwise we match by key.\n\t\t\t\t// We always match by type (in either case).\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\t\tchildVNode.type === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\toldChildren[j] = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\toldVNode = null;\n\t\t\t}\n\t\t}\n\n\t\toldVNode = oldVNode || EMPTY_OBJ;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tnewDom = diff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tisSvg,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating\n\t\t);\n\n\t\tif ((j = childVNode.ref) && oldVNode.ref != j) {\n\t\t\tif (!refs) refs = [];\n\t\t\tif (oldVNode.ref) refs.push(oldVNode.ref, null, childVNode);\n\t\t\trefs.push(j, childVNode._component || newDom, childVNode);\n\t\t}\n\n\t\tif (newDom != null) {\n\t\t\tif (firstChildDom == null) {\n\t\t\t\tfirstChildDom = newDom;\n\t\t\t}\n\n\t\t\toldDom = placeChild(\n\t\t\t\tparentDom,\n\t\t\t\tchildVNode,\n\t\t\t\toldVNode,\n\t\t\t\toldChildren,\n\t\t\t\texcessDomChildren,\n\t\t\t\tnewDom,\n\t\t\t\toldDom\n\t\t\t);\n\n\t\t\t// Browsers will infer an option's `value` from `textContent` when\n\t\t\t// no value is present. This essentially bypasses our code to set it\n\t\t\t// later in `diff()`. It works fine in all browsers except for IE11\n\t\t\t// where it breaks setting `select.value`. There it will be always set\n\t\t\t// to an empty string. Re-applying an options value will fix that, so\n\t\t\t// there are probably some internal data structures that aren't\n\t\t\t// updated properly.\n\t\t\t//\n\t\t\t// To fix it we make sure to reset the inferred value, so that our own\n\t\t\t// value check in `diff()` won't be skipped.\n\t\t\tif (!isHydrating && newParentVNode.type == 'option') {\n\t\t\t\tparentDom.value = '';\n\t\t\t} else if (typeof newParentVNode.type == 'function') {\n\t\t\t\t// Because the newParentVNode is Fragment-like, we need to set it's\n\t\t\t\t// _nextDom property to the nextSibling of its last child DOM node.\n\t\t\t\t//\n\t\t\t\t// `oldDom` contains the correct value here because if the last child\n\t\t\t\t// is a Fragment-like, then oldDom has already been set to that child's _nextDom.\n\t\t\t\t// If the last child is a DOM VNode, then oldDom will be set to that DOM\n\t\t\t\t// node's nextSibling.\n\t\t\t\tnewParentVNode._nextDom = oldDom;\n\t\t\t}\n\t\t} else if (\n\t\t\toldDom &&\n\t\t\toldVNode._dom == oldDom &&\n\t\t\toldDom.parentNode != parentDom\n\t\t) {\n\t\t\t// The above condition is to handle null placeholders. See test in placeholder.test.js:\n\t\t\t// `efficiently replace null placeholders in parent rerenders`\n\t\t\toldDom = getDomSibling(oldVNode);\n\t\t}\n\t}\n\n\tnewParentVNode._dom = firstChildDom;\n\n\t// Remove children that are not part of any vnode.\n\tif (excessDomChildren != null && typeof newParentVNode.type != 'function') {\n\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\tif (excessDomChildren[i] != null) removeNode(excessDomChildren[i]);\n\t\t}\n\t}\n\n\t// Remove remaining oldChildren if there are any.\n\tfor (i = oldChildrenLength; i--; ) {\n\t\tif (oldChildren[i] != null) unmount(oldChildren[i], oldChildren[i]);\n\t}\n\n\t// Set refs only after unmount\n\tif (refs) {\n\t\tfor (i = 0; i < refs.length; i++) {\n\t\t\tapplyRef(refs[i], refs[++i], refs[++i]);\n\t\t}\n\t}\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {import('../index').ComponentChildren} children The unflattened\n * children of a virtual node\n * @returns {import('../internal').VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (Array.isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\nexport function placeChild(\n\tparentDom,\n\tchildVNode,\n\toldVNode,\n\toldChildren,\n\texcessDomChildren,\n\tnewDom,\n\toldDom\n) {\n\tlet nextDom;\n\tif (childVNode._nextDom !== undefined) {\n\t\t// Only Fragments or components that return Fragment like VNodes will\n\t\t// have a non-undefined _nextDom. Continue the diff from the sibling\n\t\t// of last DOM child of this child VNode\n\t\tnextDom = childVNode._nextDom;\n\n\t\t// Eagerly cleanup _nextDom. We don't need to persist the value because\n\t\t// it is only used by `diffChildren` to determine where to resume the diff after\n\t\t// diffing Components and Fragments. Once we store it the nextDOM local var, we\n\t\t// can clean up the property\n\t\tchildVNode._nextDom = undefined;\n\t} else if (\n\t\texcessDomChildren == oldVNode ||\n\t\tnewDom != oldDom ||\n\t\tnewDom.parentNode == null\n\t) {\n\t\t// NOTE: excessDomChildren==oldVNode above:\n\t\t// This is a compression of excessDomChildren==null && oldVNode==null!\n\t\t// The values only have the same type when `null`.\n\n\t\touter: if (oldDom == null || oldDom.parentNode !== parentDom) {\n\t\t\tparentDom.appendChild(newDom);\n\t\t\tnextDom = null;\n\t\t} else {\n\t\t\t// `j<oldChildrenLength; j+=2` is an alternative to `j++<oldChildrenLength/2`\n\t\t\tfor (\n\t\t\t\tlet sibDom = oldDom, j = 0;\n\t\t\t\t(sibDom = sibDom.nextSibling) && j < oldChildren.length;\n\t\t\t\tj += 2\n\t\t\t) {\n\t\t\t\tif (sibDom == newDom) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparentDom.insertBefore(newDom, oldDom);\n\t\t\tnextDom = oldDom;\n\t\t}\n\t}\n\n\t// If we have pre-calculated the nextDOM node, use it. Else calculate it now\n\t// Strictly check for `undefined` here cuz `null` is a valid value of `nextDom`.\n\t// See more detail in create-element.js:createVNode\n\tif (nextDom !== undefined) {\n\t\toldDom = nextDom;\n\t} else {\n\t\toldDom = newDom.nextSibling;\n\t}\n\n\treturn oldDom;\n}\n","import { IS_NON_DIMENSIONAL } from '../constants';\nimport options from '../options';\n\n/**\n * Diff the old and new properties of a VNode and apply changes to the DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to apply\n * changes to\n * @param {object} newProps The new props\n * @param {object} oldProps The old props\n * @param {boolean} isSvg Whether or not this node is an SVG node\n * @param {boolean} hydrate Whether or not we are in hydration mode\n */\nexport function diffProps(dom, newProps, oldProps, isSvg, hydrate) {\n\tlet i;\n\n\tfor (i in oldProps) {\n\t\tif (i !== 'children' && i !== 'key' && !(i in newProps)) {\n\t\t\tsetProperty(dom, i, null, oldProps[i], isSvg);\n\t\t}\n\t}\n\n\tfor (i in newProps) {\n\t\tif (\n\t\t\t(!hydrate || typeof newProps[i] == 'function') &&\n\t\t\ti !== 'children' &&\n\t\t\ti !== 'key' &&\n\t\t\ti !== 'value' &&\n\t\t\ti !== 'checked' &&\n\t\t\toldProps[i] !== newProps[i]\n\t\t) {\n\t\t\tsetProperty(dom, i, newProps[i], oldProps[i], isSvg);\n\t\t}\n\t}\n}\n\nfunction setStyle(style, key, value) {\n\t// if (!(key in style)) {  // -3b\n\t// if (key < '.') {  // -1b\n\tif (key[0] === '-') {\n\t\tstyle.setProperty(key, value);\n\t} else if (value == null) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, isSvg) {\n\tlet useCapture, nameLower;\n\n\tif (isSvg && name == 'className') name = 'class';\n\n\t// if (isSvg) {\n\t// \tif (name === 'className') name = 'class';\n\t// } else if (name === 'class') name += 'Name';\n\n\tif (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture = name !== (name = name.replace(/Capture$/, ''));\n\t\tnameLower = name.toLowerCase();\n\t\tif (nameLower in dom) name = nameLower;\n\t\tname = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) dom.addEventListener(name, eventProxy, useCapture);\n\t\t} else {\n\t\t\tdom.removeEventListener(name, eventProxy, useCapture);\n\t\t}\n\t} else if (\n\t\tname !== 'list' &&\n\t\tname !== 'tagName' &&\n\t\t// HTMLButtonElement.form and HTMLInputElement.form are read-only but can be set using\n\t\t// setAttribute\n\t\tname !== 'form' &&\n\t\tname !== 'type' &&\n\t\tname !== 'size' &&\n\t\tname !== 'download' &&\n\t\tname !== 'href' &&\n\t\t!isSvg &&\n\t\tname in dom\n\t) {\n\t\tdom[name] = value == null ? '' : value;\n\t} else if (typeof value != 'function' && name !== 'dangerouslySetInnerHTML') {\n\t\tif (name !== (name = name.replace(/xlink:?/, ''))) {\n\t\t\tif (value == null || value === false) {\n\t\t\t\tdom.removeAttributeNS(\n\t\t\t\t\t'http://www.w3.org/1999/xlink',\n\t\t\t\t\tname.toLowerCase()\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tdom.setAttributeNS(\n\t\t\t\t\t'http://www.w3.org/1999/xlink',\n\t\t\t\t\tname.toLowerCase(),\n\t\t\t\t\tvalue\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (\n\t\t\tvalue == null ||\n\t\t\t(value === false &&\n\t\t\t\t// ARIA-attributes have a different notion of boolean values.\n\t\t\t\t// The value `false` is different from the attribute not\n\t\t\t\t// existing on the DOM, so we can't remove it. For non-boolean\n\t\t\t\t// ARIA-attributes we could treat false as a removal, but the\n\t\t\t\t// amount of exceptions would cost us too many bytes. On top of\n\t\t\t\t// that other VDOM frameworks also always stringify `false`.\n\t\t\t\t!/^ar/.test(name))\n\t\t) {\n\t\t\tdom.removeAttribute(name);\n\t\t} else {\n\t\t\tdom.setAttribute(name, value);\n\t\t}\n\t}\n}\n\n/**\n * Proxy an event to hooked event handlers\n * @param {Event} e The event object from the browser\n * @private\n */\nfunction eventProxy(e) {\n\tthis._listeners[e.type](options.event ? options.event(e) : e);\n}\n","import { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { Component } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren, placeChild } from './children';\nimport { diffProps, setProperty } from './props';\nimport { assign, removeNode } from '../util';\nimport options from '../options';\n\nfunction reorderChildren(newVNode, oldDom, parentDom) {\n\tfor (let tmp = 0; tmp < newVNode._children.length; tmp++) {\n\t\tconst vnode = newVNode._children[tmp];\n\t\tif (vnode) {\n\t\t\tvnode._parent = newVNode;\n\n\t\t\tif (vnode._dom) {\n\t\t\t\tif (typeof vnode.type == 'function' && vnode._children.length > 1) {\n\t\t\t\t\treorderChildren(vnode, oldDom, parentDom);\n\t\t\t\t}\n\n\t\t\t\toldDom = placeChild(\n\t\t\t\t\tparentDom,\n\t\t\t\t\tvnode,\n\t\t\t\t\tvnode,\n\t\t\t\t\tnewVNode._children,\n\t\t\t\t\tnull,\n\t\t\t\t\tvnode._dom,\n\t\t\t\t\toldDom\n\t\t\t\t);\n\n\t\t\t\tif (typeof newVNode.type == 'function') {\n\t\t\t\t\tnewVNode._nextDom = oldDom;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').PreactElement} parentDom The parent of the DOM element\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by getChildContext\n * @param {boolean} isSvg Whether or not this element is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {Element | Text} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} [isHydrating] Whether or not we are in hydration\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== undefined) return null;\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\ttry {\n\t\touter: if (typeof newType == 'function') {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif ('prototype' in newType && newType.prototype.render) {\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\tnewVNode._component = c = new Component(newProps, componentContext);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (c._nextState == null) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\t\t\tif (newType.getDerivedStateFromProps != null) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tc.componentWillMount != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidMount != null) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(!c._force &&\n\t\t\t\t\t\tc.shouldComponentUpdate != null &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\tnewVNode._original === oldVNode._original\n\t\t\t\t) {\n\t\t\t\t\tc.props = newProps;\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original !== oldVNode._original) c._dirty = false;\n\t\t\t\t\tc._vnode = newVNode;\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\treorderChildren(newVNode, oldDom, parentDom);\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != null) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidUpdate != null) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc.state = c._nextState;\n\n\t\t\tif ((tmp = options._render)) tmp(newVNode);\n\n\t\t\tc._dirty = false;\n\t\t\tc._vnode = newVNode;\n\t\t\tc._parentDom = parentDom;\n\n\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != null) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (!isNew && c.getSnapshotBeforeUpdate != null) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != null && tmp.type == Fragment && tmp.key == null;\n\t\t\tlet renderResult = isTopLevelFragment ? tmp.props.children : tmp;\n\n\t\t\tdiffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tArray.isArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = null;\n\t\t\t}\n\n\t\t\tc._force = false;\n\t\t} else if (\n\t\t\texcessDomChildren == null &&\n\t\t\tnewVNode._original === oldVNode._original\n\t\t) {\n\t\t\tnewVNode._children = oldVNode._children;\n\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t} else {\n\t\t\tnewVNode._dom = diffElementNodes(\n\t\t\t\toldVNode._dom,\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\tif ((tmp = options.diffed)) tmp(newVNode);\n\t} catch (e) {\n\t\tnewVNode._original = null;\n\t\toptions._catchError(e, newVNode, oldVNode);\n\t}\n\n\treturn newVNode._dom;\n}\n\n/**\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').VNode} root\n */\nexport function commitRoot(commitQueue, root) {\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {import('../internal').PreactElement} dom The DOM element representing\n * the virtual nodes being diffed\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {*} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @returns {import('../internal').PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating\n) {\n\tlet i;\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\n\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\tisSvg = newVNode.type === 'svg' || isSvg;\n\n\tif (excessDomChildren != null) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tconst child = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tchild != null &&\n\t\t\t\t((newVNode.type === null\n\t\t\t\t\t? child.nodeType === 3\n\t\t\t\t\t: child.localName === newVNode.type) ||\n\t\t\t\t\tdom == child)\n\t\t\t) {\n\t\t\t\tdom = child;\n\t\t\t\texcessDomChildren[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == null) {\n\t\tif (newVNode.type === null) {\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tdom = isSvg\n\t\t\t? document.createElementNS('http://www.w3.org/2000/svg', newVNode.type)\n\t\t\t: document.createElement(\n\t\t\t\t\tnewVNode.type,\n\t\t\t\t\tnewProps.is && { is: newProps.is }\n\t\t\t  );\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = null;\n\t\t// we are creating a new node, so we can assume this is a new subtree (in case we are hydrating), this deopts the hydrate\n\t\tisHydrating = false;\n\t}\n\n\tif (newVNode.type === null) {\n\t\tif (oldProps !== newProps && dom.data !== newProps) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\tif (excessDomChildren != null) {\n\t\t\texcessDomChildren = EMPTY_ARR.slice.call(dom.childNodes);\n\t\t}\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\tlet oldHtml = oldProps.dangerouslySetInnerHTML;\n\t\tlet newHtml = newProps.dangerouslySetInnerHTML;\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tif (!isHydrating) {\n\t\t\t// But, if we are in a situation where we are using existing DOM (e.g. replaceNode)\n\t\t\t// we should read the existing DOM attributes to diff them\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\toldProps = {};\n\t\t\t\tfor (let i = 0; i < dom.attributes.length; i++) {\n\t\t\t\t\toldProps[dom.attributes[i].name] = dom.attributes[i].value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (newHtml || oldHtml) {\n\t\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\t\tif (!newHtml || !oldHtml || newHtml.__html != oldHtml.__html) {\n\t\t\t\t\tdom.innerHTML = (newHtml && newHtml.__html) || '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdiffProps(dom, newProps, oldProps, isSvg, isHydrating);\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\ti = newVNode.props.children;\n\t\t\tdiffChildren(\n\t\t\t\tdom,\n\t\t\t\tArray.isArray(i) ? i : [i],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnewVNode.type === 'foreignObject' ? false : isSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tEMPTY_OBJ,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\t// (as above, don't diff props during hydration)\n\t\tif (!isHydrating) {\n\t\t\tif (\n\t\t\t\t'value' in newProps &&\n\t\t\t\t(i = newProps.value) !== undefined &&\n\t\t\t\ti !== dom.value\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'value', i, oldProps.value, false);\n\t\t\t}\n\t\t\tif (\n\t\t\t\t'checked' in newProps &&\n\t\t\t\t(i = newProps.checked) !== undefined &&\n\t\t\t\ti !== dom.checked\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'checked', i, oldProps.checked, false);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {object|function} ref\n * @param {any} value\n * @param {import('../internal').VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') ref(value);\n\t\telse ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {import('../internal').VNode} vnode The virtual node to unmount\n * @param {import('../internal').VNode} parentVNode The parent of the VNode that\n * initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current === vnode._dom) applyRef(r, null, parentVNode);\n\t}\n\n\tlet dom;\n\tif (!skipRemove && typeof vnode.type != 'function') {\n\t\tskipRemove = (dom = vnode._dom) != null;\n\t}\n\n\t// Must be set to `undefined` to properly clean up `_nextDom`\n\t// for which `null` is a valid value. See comment in `create-element.js`\n\tvnode._dom = vnode._nextDom = undefined;\n\n\tif ((r = vnode._component) != null) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = null;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) unmount(r[i], parentVNode, skipRemove);\n\t\t}\n\t}\n\n\tif (dom != null) removeNode(dom);\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n","import { assign } from './util';\nimport { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./index').ComponentChildren>} rest Any additional arguments will be used as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\tif (children != null) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tnull\n\t);\n}\n","import { enqueueRender } from '../component';\n\n/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').VNode} vnode The vnode that threw\n * the error that was caught (except for unmounting when this parameter\n * is the highest parent that was being unmounted)\n */\nexport function _catchError(error, vnode) {\n\t/** @type {import('../internal').Component} */\n\tlet component, hasCaught;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tif (\n\t\t\t\t\tcomponent.constructor &&\n\t\t\t\t\tcomponent.constructor.getDerivedStateFromError != null\n\t\t\t\t) {\n\t\t\t\t\thasCaught = true;\n\t\t\t\t\tcomponent.setState(\n\t\t\t\t\t\tcomponent.constructor.getDerivedStateFromError(error)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != null) {\n\t\t\t\t\thasCaught = true;\n\t\t\t\t\tcomponent.componentDidCatch(error);\n\t\t\t\t}\n\n\t\t\t\tif (hasCaught)\n\t\t\t\t\treturn enqueueRender((component._pendingError = component));\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n"],"names":["options","isValidElement","rerenderQueue","defer","prevDebounce","IS_HYDRATE","i","EMPTY_OBJ","EMPTY_ARR","IS_NON_DIMENSIONAL","assign","obj","props","removeNode","node","parentNode","removeChild","createElement","type","children","key","ref","normalizedProps","arguments","length","push","defaultProps","undefined","createVNode","original","vnode","constructor","createRef","current","Fragment","Component","context","getDomSibling","childIndex","indexOf","sibling","updateParentDomPointers","child","base","enqueueRender","c","process","debounceRendering","queue","sort","a","b","some","component","commitQueue","oldVNode","newDom","oldDom","parentDom","diff","ownerSVGElement","commitRoot","diffChildren","renderResult","newParentVNode","oldParentVNode","globalContext","isSvg","excessDomChildren","isHydrating","j","childVNode","firstChildDom","refs","oldChildren","oldChildrenLength","Array","isArray","placeChild","value","unmount","applyRef","toChildArray","out","nextDom","sibDom","outer","appendChild","nextSibling","insertBefore","diffProps","dom","newProps","oldProps","hydrate","setProperty","setStyle","style","test","name","oldValue","useCapture","nameLower","replace","toLowerCase","slice","_listeners","addEventListener","eventProxy","removeEventListener","removeAttributeNS","setAttributeNS","removeAttribute","setAttribute","e","event","reorderChildren","newVNode","tmp","isNew","oldState","snapshot","clearProcessingException","provider","componentContext","newType","contextType","prototype","render","doRender","sub","state","getDerivedStateFromProps","componentWillMount","componentDidMount","componentWillReceiveProps","shouldComponentUpdate","componentWillUpdate","componentDidUpdate","getChildContext","getSnapshotBeforeUpdate","diffElementNodes","diffed","root","cb","call","oldHtml","newHtml","nodeType","localName","document","createTextNode","createElementNS","is","data","childNodes","dangerouslySetInnerHTML","attributes","innerHTML","checked","parentVNode","skipRemove","r","componentWillUnmount","this","replaceNode","cloneElement","createContext","defaultValue","contextId","Consumer","contextValue","Provider","subs","ctx","_props","old","splice","error","hasCaught","getDerivedStateFromError","setState","componentDidCatch","update","callback","s","forceUpdate","Promise","then","bind","resolve","setTimeout"],"mappings":"AAAO,ICWDA,ECuFOC,ECqETC,EAQEC,EAcFC,ECxLEC,ECHKC,ELFEC,EAAY,GACZC,EAAY,GACZC,EAAqB,oEMK3B,SAASC,EAAOC,EAAKC,OACtB,IAAIN,KAAKM,EAAOD,EAAIL,GAAKM,EAAMN,YAU9B,SAASO,EAAWC,OACtBC,EAAaD,EAAKC,WAClBA,GAAYA,EAAWC,YAAYF,GJVxC,SAAgBG,EAAcC,EAAMN,EAAOO,GAA3C,IAEEC,EACAC,EACAf,cAHGgB,EAAkB,OAIjBhB,KAAKM,EACA,OAALN,EAAYc,EAAMR,EAAMN,GACd,OAALA,EAAYe,EAAMT,EAAMN,GAC5BgB,EAAgBhB,GAAKM,EAAMN,MAG7BiB,UAAUC,OAAS,MACtBL,EAAW,CAACA,GAEPb,EAAI,EAAGA,EAAIiB,UAAUC,OAAQlB,IACjCa,EAASM,KAAKF,EAAUjB,OAGV,MAAZa,IACHG,EAAgBH,SAAWA,GAKT,mBAARD,GAA2C,MAArBA,EAAKQ,iBAChCpB,KAAKY,EAAKQ,kBACaC,IAAvBL,EAAgBhB,KACnBgB,EAAgBhB,GAAKY,EAAKQ,aAAapB,WAKnCsB,EAAYV,EAAMI,EAAiBF,EAAKC,EAAK,MAe9C,SAASO,EAAYV,EAAMN,EAAOQ,EAAKC,EAAKQ,OAG5CC,EAAQ,CACbZ,KAAAA,EACAN,MAAAA,EACAQ,IAAAA,EACAC,IAAAA,MACW,QACF,SACD,MACF,cAKIM,MACE,KACZI,iBAAaJ,MACFE,UAGI,MAAZA,IAAkBC,MAAkBA,GACnB,MAAjB9B,EAAQ8B,OAAe9B,EAAQ8B,MAAMA,GAElCA,EAGR,SAAgBE,UACR,CAAEC,QAAS,MAGZ,SAASC,EAAStB,UACjBA,EAAMO,SC9EP,SAASgB,EAAUvB,EAAOwB,QAC3BxB,MAAQA,OACRwB,QAAUA,EAuET,SAASC,EAAcP,EAAOQ,MAClB,MAAdA,SAEIR,KACJO,EAAcP,KAAeA,SAAwBS,QAAQT,GAAS,GACtE,aAGAU,EACGF,EAAaR,MAAgBN,OAAQc,OAG5B,OAFfE,EAAUV,MAAgBQ,KAEa,MAAhBE,aAIfA,YASmB,mBAAdV,EAAMZ,KAAqBmB,EAAcP,GAAS,KAsCjE,SAASW,EAAwBX,GAAjC,IAGWxB,EACJoC,KAHyB,OAA1BZ,EAAQA,OAA8C,MAApBA,MAA0B,KAChEA,MAAaA,MAAiBa,KAAO,KAC5BrC,EAAI,EAAGA,EAAIwB,MAAgBN,OAAQlB,OAE9B,OADToC,EAAQZ,MAAgBxB,KACO,MAAdoC,MAAoB,CACxCZ,MAAaA,MAAiBa,KAAOD,mBAKhCD,EAAwBX,IAoC1B,SAASc,EAAcC,KAE1BA,QACAA,OAAW,IACZ3C,EAAcuB,KAAKoB,KAClBC,SACF1C,IAAiBJ,EAAQ+C,sBAEzB3C,EAAeJ,EAAQ+C,oBACN5C,GAAO2C,GAK1B,SAASA,YACJE,EACIF,MAAyB5C,EAAcsB,QAC9CwB,EAAQ9C,EAAc+C,KAAK,SAACC,EAAGC,UAAMD,UAAkBC,YACvDjD,EAAgB,GAGhB8C,EAAMI,KAAK,SAAAP,GAnGb,IAAyBQ,EAMnBC,EACEC,EAGFC,EATD1B,EACH2B,EACAC,EAiGKb,QAlGLY,GADG3B,GADoBuB,EAoGQR,aAjG/Ba,EAAYL,SAGRC,EAAc,IACZC,EAAW7C,EAAO,GAAIoB,QACPyB,EAEjBC,EAASG,EACZD,EACA5B,EACAyB,EACAF,WAC8B1B,IAA9B+B,EAAUE,gBACV,KACAN,EACU,MAAVG,EAAiBpB,EAAcP,GAAS2B,GAEzCI,EAAWP,EAAaxB,GAEpB0B,GAAUC,GACbhB,EAAwBX,OIlH3B,SAAgBgC,EACfJ,EACAK,EACAC,EACAC,EACAC,EACAC,EACAC,EACAd,EACAG,EACAY,GAVD,IAYK/D,EAAGgE,EAAGf,EAAUgB,EAAYf,EAAQgB,EAAeC,EAInDC,EAAeT,GAAkBA,OAA6BzD,EAE9DmE,EAAoBD,EAAYlD,WAMhCiC,GAAUlD,IAEZkD,EADwB,MAArBW,EACMA,EAAkB,GACjBO,EACDtC,EAAc4B,EAAgB,GAE9B,MAIXD,MAA2B,GACtB1D,EAAI,EAAGA,EAAIyD,EAAavC,OAAQlB,OAuClB,OAnCjBiE,EAAaP,MAAyB1D,GADrB,OAFlBiE,EAAaR,EAAazD,KAEqB,kBAAdiE,EACW,KAKd,iBAAdA,GAA+C,iBAAdA,EACL3C,EAC1C,KACA2C,EACA,KACA,KACAA,GAESK,MAAMC,QAAQN,GACmB3C,EAC1CM,EACA,CAAEf,SAAUoD,GACZ,KACA,KACA,MAE4B,MAAnBA,OAAoD,MAAzBA,MACM3C,EAC1C2C,EAAWrD,KACXqD,EAAW3D,MACX2D,EAAWnD,IACX,KACAmD,OAG0CA,OAS5CA,KAAqBP,EACrBO,MAAoBP,MAAwB,EAS9B,QAHdT,EAAWmB,EAAYpE,KAIrBiD,GACAgB,EAAWnD,KAAOmC,EAASnC,KAC3BmD,EAAWrD,OAASqC,EAASrC,KAE9BwD,EAAYpE,QAAKqB,WAIZ2C,EAAI,EAAGA,EAAIK,EAAmBL,IAAK,KACvCf,EAAWmB,EAAYJ,KAKtBC,EAAWnD,KAAOmC,EAASnC,KAC3BmD,EAAWrD,OAASqC,EAASrC,KAC5B,CACDwD,EAAYJ,QAAK3C,QAGlB4B,EAAW,KAObC,EAASG,EACRD,EACAa,EALDhB,EAAWA,GAAYhD,EAOtB2D,EACAC,EACAC,EACAd,EACAG,EACAY,IAGIC,EAAIC,EAAWlD,MAAQkC,EAASlC,KAAOiD,IACtCG,IAAMA,EAAO,IACdlB,EAASlC,KAAKoD,EAAKhD,KAAK8B,EAASlC,IAAK,KAAMkD,GAChDE,EAAKhD,KAAK6C,EAAGC,OAAyBf,EAAQe,IAGjC,MAAVf,GACkB,MAAjBgB,IACHA,EAAgBhB,GAGjBC,EAASqB,EACRpB,EACAa,EACAhB,EACAmB,EACAN,EACAZ,EACAC,GAaIY,GAAsC,UAAvBL,EAAe9C,KAEM,mBAAvB8C,EAAe9C,OAQhC8C,MAA0BP,GAT1BC,EAAUqB,MAAQ,IAYnBtB,GACAF,OAAiBE,GACjBA,EAAO1C,YAAc2C,IAIrBD,EAASpB,EAAckB,OAIzBS,MAAsBQ,EAGG,MAArBJ,GAA2D,mBAAvBJ,EAAe9C,SACjDZ,EAAI8D,EAAkB5C,OAAQlB,KACN,MAAxB8D,EAAkB9D,IAAYO,EAAWuD,EAAkB9D,QAK5DA,EAAIqE,EAAmBrE,KACL,MAAlBoE,EAAYpE,IAAY0E,EAAQN,EAAYpE,GAAIoE,EAAYpE,OAI7DmE,MACEnE,EAAI,EAAGA,EAAImE,EAAKjD,OAAQlB,IAC5B2E,EAASR,EAAKnE,GAAImE,IAAOnE,GAAImE,IAAOnE,IAWhC,SAAS4E,EAAa/D,EAAUgE,UACtCA,EAAMA,GAAO,GACG,MAAZhE,GAAuC,kBAAZA,IACpByD,MAAMC,QAAQ1D,GACxBA,EAASiC,KAAK,SAAAV,GACbwC,EAAaxC,EAAOyC,KAGrBA,EAAI1D,KAAKN,IAEHgE,EAGD,SAASL,EACfpB,EACAa,EACAhB,EACAmB,EACAN,EACAZ,EACAC,GAPM,IASF2B,EA2BGC,EAAiBf,UA1BI3C,IAAxB4C,MAIHa,EAAUb,MAMVA,WAAsB5C,OAChB,GACNyC,GAAqBb,GACrBC,GAAUC,GACW,MAArBD,EAAOzC,WAMPuE,EAAO,GAAc,MAAV7B,GAAkBA,EAAO1C,aAAe2C,EAClDA,EAAU6B,YAAY/B,GACtB4B,EAAU,SACJ,KAGDC,EAAS5B,EAAQa,EAAI,GACxBe,EAASA,EAAOG,cAAgBlB,EAAII,EAAYlD,OACjD8C,GAAK,KAEDe,GAAU7B,QACP8B,EAGR5B,EAAU+B,aAAajC,EAAQC,GAC/B2B,EAAU3B,cAOI9B,IAAZyD,EACMA,EAEA5B,EAAOgC,YCpSX,SAASE,EAAUC,EAAKC,EAAUC,EAAU1B,EAAO2B,OACrDxF,MAECA,KAAKuF,EACC,aAANvF,GAA0B,QAANA,GAAiBA,KAAKsF,GAC7CG,EAAYJ,EAAKrF,EAAG,KAAMuF,EAASvF,GAAI6D,OAIpC7D,KAAKsF,EAENE,GAAiC,mBAAfF,EAAStF,IACvB,aAANA,GACM,QAANA,GACM,UAANA,GACM,YAANA,GACAuF,EAASvF,KAAOsF,EAAStF,IAEzByF,EAAYJ,EAAKrF,EAAGsF,EAAStF,GAAIuF,EAASvF,GAAI6D,GAKjD,SAAS6B,EAASC,EAAO7E,EAAK2D,GAGd,MAAX3D,EAAI,GACP6E,EAAMF,YAAY3E,EAAK2D,GAEvBkB,EAAM7E,GADa,MAAT2D,EACG,GACa,iBAATA,GAAqBtE,EAAmByF,KAAK9E,GACjD2D,EAEAA,EAAQ,KAYhB,SAASgB,EAAYJ,EAAKQ,EAAMpB,EAAOqB,EAAUjC,OACnDkC,EAAYC,KAEZnC,GAAiB,aAARgC,IAAqBA,EAAO,SAM5B,UAATA,KACiB,iBAATpB,EACVY,EAAIM,MAAQlB,MACN,IACiB,iBAAZqB,IACVT,EAAIM,MAAQG,EAAW,IAGpBA,MACED,KAAQC,EACNrB,GAASoB,KAAQpB,GACtBiB,EAASL,EAAIM,MAAOE,EAAM,OAKzBpB,MACEoB,KAAQpB,EACPqB,GAAYrB,EAAMoB,KAAUC,EAASD,IACzCH,EAASL,EAAIM,MAAOE,EAAMpB,EAAMoB,QAOhB,MAAZA,EAAK,IAA0B,MAAZA,EAAK,IAChCE,EAAaF,KAAUA,EAAOA,EAAKI,QAAQ,WAAY,MACvDD,EAAYH,EAAKK,iBACAb,IAAKQ,EAAOG,GAC7BH,EAAOA,EAAKM,MAAM,GAEbd,EAAIe,IAAYf,EAAIe,EAAa,IACtCf,EAAIe,EAAWP,GAAQpB,EAEnBA,EACEqB,GAAUT,EAAIgB,iBAAiBR,EAAMS,EAAYP,GAEtDV,EAAIkB,oBAAoBV,EAAMS,EAAYP,IAGlC,SAATF,GACS,YAATA,GAGS,SAATA,GACS,SAATA,GACS,SAATA,GACS,aAATA,GACS,SAATA,IACChC,GACDgC,KAAQR,EAERA,EAAIQ,GAAiB,MAATpB,EAAgB,GAAKA,EACP,mBAATA,GAAgC,4BAAToB,IACpCA,KAAUA,EAAOA,EAAKI,QAAQ,UAAW,KAC/B,MAATxB,IAA2B,IAAVA,EACpBY,EAAImB,kBACH,+BACAX,EAAKK,eAGNb,EAAIoB,eACH,+BACAZ,EAAKK,cACLzB,GAIO,MAATA,IACW,IAAVA,IAOC,MAAMmB,KAAKC,GAEbR,EAAIqB,gBAAgBb,GAEpBR,EAAIsB,aAAad,EAAMpB,IAU1B,SAAS6B,EAAWM,QACdR,EAAWQ,EAAEhG,MAAMlB,EAAQmH,MAAQnH,EAAQmH,MAAMD,GAAKA,YCtJnDE,EAAgBC,EAAU5D,EAAQC,OACjC4D,EACFxF,MADEwF,EAAM,EAAGA,EAAMD,MAAmB7F,OAAQ8F,KAC5CxF,EAAQuF,MAAmBC,MAEhCxF,KAAgBuF,EAEZvF,QACsB,mBAAdA,EAAMZ,MAAsBY,MAAgBN,OAAS,GAC/D4F,EAAgBtF,EAAO2B,EAAQC,GAGhCD,EAASqB,EACRpB,EACA5B,EACAA,EACAuF,MACA,KACAvF,MACA2B,GAG2B,mBAAjB4D,EAASnG,OACnBmG,MAAoB5D,KAuBzB,SAAgBE,EACfD,EACA2D,EACA9D,EACAW,EACAC,EACAC,EACAd,EACAG,EACAY,GATD,IAWKiD,EAWEzE,EAAG0E,EAAO1B,EAAU2B,EAAUC,EAAUC,EACxC9B,EAKA+B,EACAC,EAiIA7D,EAlJL8D,EAAUR,EAASnG,aAISS,IAAzB0F,EAAStF,YAA2B,OAAO,MAE1CuF,EAAMtH,QAAgBsH,EAAID,OAG9B/B,EAAO,GAAsB,mBAAXuC,EAAuB,IAEpCjC,EAAWyB,EAASzG,MAKpB+G,GADJL,EAAMO,EAAQC,cACQ5D,EAAcoD,OAChCM,EAAmBN,EACpBK,EACCA,EAAS/G,MAAMmE,MACfuC,KACDpD,EAGCX,MAEHmE,GADA7E,EAAIwE,MAAsB9D,UAC0BV,OAGhD,cAAegF,GAAWA,EAAQE,UAAUC,OAC/CX,MAAsBxE,EAAI,IAAIgF,EAAQjC,EAAUgC,IAEhDP,MAAsBxE,EAAI,IAAIV,EAAUyD,EAAUgC,GAClD/E,EAAEd,YAAc8F,EAChBhF,EAAEmF,OAASC,GAERN,GAAUA,EAASO,IAAIrF,GAE3BA,EAAEjC,MAAQgF,EACL/C,EAAEsF,QAAOtF,EAAEsF,MAAQ,IACxBtF,EAAET,QAAUwF,EACZ/E,MAAmBqB,EACnBqD,EAAQ1E,OAAW,EACnBA,MAAqB,IAIF,MAAhBA,QACHA,MAAeA,EAAEsF,OAEsB,MAApCN,EAAQO,2BACPvF,OAAgBA,EAAEsF,QACrBtF,MAAenC,EAAO,GAAImC,QAG3BnC,EACCmC,MACAgF,EAAQO,yBAAyBxC,EAAU/C,SAI7CgD,EAAWhD,EAAEjC,MACb4G,EAAW3E,EAAEsF,MAGTZ,EAEkC,MAApCM,EAAQO,0BACgB,MAAxBvF,EAAEwF,oBAEFxF,EAAEwF,qBAGwB,MAAvBxF,EAAEyF,mBACLzF,MAAmBpB,KAAKoB,EAAEyF,uBAErB,IAE+B,MAApCT,EAAQO,0BACRxC,IAAaC,GACkB,MAA/BhD,EAAE0F,2BAEF1F,EAAE0F,0BAA0B3C,EAAUgC,IAIpC/E,OAC0B,MAA3BA,EAAE2F,wBAKI,IAJN3F,EAAE2F,sBACD5C,EACA/C,MACA+E,IAEFP,QAAuB9D,MACtB,CACDV,EAAEjC,MAAQgF,EACV/C,EAAEsF,MAAQtF,MAENwE,QAAuB9D,QAAoBV,OAAW,GAC1DA,MAAWwE,EACXA,MAAgB9D,MAChB8D,MAAqB9D,MACjBV,MAAmBrB,QACtB8B,EAAY7B,KAAKoB,GAGlBuE,EAAgBC,EAAU5D,EAAQC,SAC5B4B,EAGsB,MAAzBzC,EAAE4F,qBACL5F,EAAE4F,oBAAoB7C,EAAU/C,MAAc+E,GAGnB,MAAxB/E,EAAE6F,oBACL7F,MAAmBpB,KAAK,WACvBoB,EAAE6F,mBAAmB7C,EAAU2B,EAAUC,KAK5C5E,EAAET,QAAUwF,EACZ/E,EAAEjC,MAAQgF,EACV/C,EAAEsF,MAAQtF,OAELyE,EAAMtH,QAAkBsH,EAAID,GAEjCxE,OAAW,EACXA,MAAWwE,EACXxE,MAAea,EAEf4D,EAAMzE,EAAEmF,OAAOnF,EAAEjC,MAAOiC,EAAEsF,MAAOtF,EAAET,SAGnCS,EAAEsF,MAAQtF,MAEe,MAArBA,EAAE8F,kBACLzE,EAAgBxD,EAAOA,EAAO,GAAIwD,GAAgBrB,EAAE8F,oBAGhDpB,GAAsC,MAA7B1E,EAAE+F,0BACfnB,EAAW5E,EAAE+F,wBAAwB/C,EAAU2B,IAK5CzD,EADI,MAAPuD,GAAeA,EAAIpG,MAAQgB,GAAuB,MAAXoF,EAAIlG,IACJkG,EAAI1G,MAAMO,SAAWmG,EAE7DxD,EACCJ,EACAkB,MAAMC,QAAQd,GAAgBA,EAAe,CAACA,GAC9CsD,EACA9D,EACAW,EACAC,EACAC,EACAd,EACAG,EACAY,GAGDxB,EAAEF,KAAO0E,MAELxE,MAAmBrB,QACtB8B,EAAY7B,KAAKoB,GAGd6E,IACH7E,MAAkBA,KAAyB,MAG5CA,OAAW,OAEU,MAArBuB,GACAiD,QAAuB9D,OAEvB8D,MAAqB9D,MACrB8D,MAAgB9D,OAEhB8D,MAAgBwB,EACftF,MACA8D,EACA9D,EACAW,EACAC,EACAC,EACAd,EACAe,IAIGiD,EAAMtH,EAAQ8I,SAASxB,EAAID,GAC/B,MAAOH,GACRG,MAAqB,KACrBrH,MAAoBkH,EAAGG,EAAU9D,UAG3B8D,MAQD,SAASxD,EAAWP,EAAayF,GACnC/I,OAAiBA,MAAgB+I,EAAMzF,GAE3CA,EAAYF,KAAK,SAAAP,OAEfS,EAAcT,MACdA,MAAqB,GACrBS,EAAYF,KAAK,SAAA4F,GAChBA,EAAGC,KAAKpG,KAER,MAAOqE,GACRlH,MAAoBkH,EAAGrE,UAmB1B,SAASgG,EACRlD,EACA0B,EACA9D,EACAW,EACAC,EACAC,EACAd,EACAe,GARD,IAUK/D,EASIoC,EA+CHwG,EACAC,EASO7I,EAjERuF,EAAWtC,EAAS3C,MACpBgF,EAAWyB,EAASzG,SAGxBuD,EAA0B,QAAlBkD,EAASnG,MAAkBiD,EAEV,MAArBC,MACE9D,EAAI,EAAGA,EAAI8D,EAAkB5C,OAAQlB,OAO/B,OANJoC,EAAQ0B,EAAkB9D,OAOX,OAAlB+G,EAASnG,KACW,IAAnBwB,EAAM0G,SACN1G,EAAM2G,YAAchC,EAASnG,OAC/ByE,GAAOjD,GACP,CACDiD,EAAMjD,EACN0B,EAAkB9D,GAAK,cAMf,MAAPqF,EAAa,IACM,OAAlB0B,EAASnG,YACLoI,SAASC,eAAe3D,GAGhCD,EAAMxB,EACHmF,SAASE,gBAAgB,6BAA8BnC,EAASnG,MAChEoI,SAASrI,cACToG,EAASnG,KACT0E,EAAS6D,IAAM,CAAEA,GAAI7D,EAAS6D,KAGjCrF,EAAoB,KAEpBC,GAAc,KAGO,OAAlBgD,EAASnG,KACR2E,IAAaD,GAAYD,EAAI+D,OAAS9D,IACzCD,EAAI+D,KAAO9D,OAEN,IACmB,MAArBxB,IACHA,EAAoB5D,EAAUiG,MAAMwC,KAAKtD,EAAIgE,aAK1CT,GAFJrD,EAAWtC,EAAS3C,OAASL,GAENqJ,wBACnBT,EAAUvD,EAASgE,yBAIlBvF,EAAa,IAGQ,MAArBD,MACHyB,EAAW,GACFvF,EAAI,EAAGA,EAAIqF,EAAIkE,WAAWrI,OAAQlB,IAC1CuF,EAASF,EAAIkE,WAAWvJ,GAAG6F,MAAQR,EAAIkE,WAAWvJ,GAAGyE,OAInDoE,GAAWD,KAETC,GAAYD,GAAWC,UAAkBD,WAC7CvD,EAAImE,UAAaX,GAAWA,UAAmB,KAKlDzD,EAAUC,EAAKC,EAAUC,EAAU1B,EAAOE,GAGtC8E,EACH9B,MAAqB,IAErB/G,EAAI+G,EAASzG,MAAMO,SACnB2C,EACC6B,EACAf,MAAMC,QAAQvE,GAAKA,EAAI,CAACA,GACxB+G,EACA9D,EACAW,EACkB,kBAAlBmD,EAASnG,MAAmCiD,EAC5CC,EACAd,EACA/C,EACA8D,IAKGA,IAEH,UAAWuB,QACcjE,KAAxBrB,EAAIsF,EAASb,QACdzE,IAAMqF,EAAIZ,OAEVgB,EAAYJ,EAAK,QAASrF,EAAGuF,EAASd,OAAO,GAG7C,YAAaa,QACcjE,KAA1BrB,EAAIsF,EAASmE,UACdzJ,IAAMqF,EAAIoE,SAEVhE,EAAYJ,EAAK,UAAWrF,EAAGuF,EAASkE,SAAS,WAK7CpE,EASR,SAAgBV,EAAS5D,EAAK0D,EAAOjD,OAEjB,mBAAPT,EAAmBA,EAAI0D,GAC7B1D,EAAIY,QAAU8C,EAClB,MAAOmC,GACRlH,MAAoBkH,EAAGpF,IAYzB,SAAgBkD,EAAQlD,EAAOkI,EAAaC,GAA5C,IACKC,EAOAvE,EAsBMrF,KA5BNN,EAAQgF,SAAShF,EAAQgF,QAAQlD,IAEhCoI,EAAIpI,EAAMT,OACT6I,EAAEjI,SAAWiI,EAAEjI,UAAYH,OAAYmD,EAASiF,EAAG,KAAMF,IAI1DC,GAAmC,mBAAdnI,EAAMZ,OAC/B+I,EAAmC,OAArBtE,EAAM7D,QAKrBA,MAAaA,WAAiBH,EAEA,OAAzBuI,EAAIpI,OAA2B,IAC/BoI,EAAEC,yBAEJD,EAAEC,uBACD,MAAOjD,GACRlH,MAAoBkH,EAAG8C,GAIzBE,EAAEvH,KAAOuH,MAAe,QAGpBA,EAAIpI,UACCxB,EAAI,EAAGA,EAAI4J,EAAE1I,OAAQlB,IACzB4J,EAAE5J,IAAI0E,EAAQkF,EAAE5J,GAAI0J,EAAaC,GAI5B,MAAPtE,GAAa9E,EAAW8E,GAI7B,SAASsC,EAASrH,EAAOuH,EAAO/F,UACxBgI,KAAKrI,YAAYnB,EAAOwB,GLhehC,SAAgB4F,EAAOlG,EAAO4B,EAAW2G,GAAzC,IAMKhG,EAOAd,EAMAD,EAlBAtD,MAAeA,KAAc8B,EAAO4B,GAYpCH,GAPAc,EAAcgG,IAAgBhK,GAQ/B,KACCgK,GAAeA,OAA0B3G,MAC7C5B,EAAQb,EAAciB,EAAU,KAAM,CAACJ,IAGnCwB,EAAc,GAClBK,EACCD,GAGEW,EAAcX,EAAY2G,GAAe3G,OAAuB5B,EAClEyB,GAAYhD,EACZA,OAC8BoB,IAA9B+B,EAAUE,gBACVyG,IAAgBhG,EACb,CAACgG,GACD9G,EACA,KACAG,EAAUiG,WAAWnI,OACrBhB,EAAUiG,MAAMwC,KAAKvF,EAAUiG,YAC/B,KACHrG,EACA+G,GAAe9J,EACf8D,GAIDR,EAAWP,EAAaxB,GASlB,SAASgE,EAAQhE,EAAO4B,GAC9BsE,EAAOlG,EAAO4B,EAAWrD,GMxD1B,SAAgBiK,EAAaxI,EAAOlB,EAAOO,GAA3C,IAEEC,EACAC,EACAf,cAHGgB,EAAkBZ,EAAO,GAAIoB,EAAMlB,WAIlCN,KAAKM,EACA,OAALN,EAAYc,EAAMR,EAAMN,GACd,OAALA,EAAYe,EAAMT,EAAMN,GAC5BgB,EAAgBhB,GAAKM,EAAMN,MAG7BiB,UAAUC,OAAS,MACtBL,EAAW,CAACA,GACPb,EAAI,EAAGA,EAAIiB,UAAUC,OAAQlB,IACjCa,EAASM,KAAKF,EAAUjB,WAGV,MAAZa,IACHG,EAAgBH,SAAWA,GAGrBS,EACNE,EAAMZ,KACNI,EACAF,GAAOU,EAAMV,IACbC,GAAOS,EAAMT,IACb,MLhCK,SAASkJ,EAAcC,EAAcC,OAGrCrI,EAAU,KAFhBqI,EAAY,OAASnK,OAILkK,EACfE,kBAAS9J,EAAO+J,UAIR/J,EAAMO,SAASwJ,IAEvBC,kBAAShK,EAAOiK,EAAMC,UAChBV,KAAKzB,kBACTkC,EAAO,IACPC,EAAM,IACFL,GAAaL,UAEZzB,gBAAkB,kBAAMmC,QAExBtC,sBAAwB,SAASuC,GACjCX,KAAKxJ,MAAMmE,QAAUgG,EAAOhG,OAe/B8F,EAAKzH,KAAKR,SAIPsF,IAAM,SAAArF,GACVgI,EAAKpJ,KAAKoB,OACNmI,EAAMnI,EAAEsH,qBACZtH,EAAEsH,qBAAuB,WACxBU,EAAKI,OAAOJ,EAAKtI,QAAQM,GAAI,GACzBmI,GAAKA,EAAI/B,KAAKpG,MAKdjC,EAAMO,kBAUPiB,EAAQwI,YAAuBxI,EAAQsI,SAAS5C,YAAc1F,EJrDjEpC,EAAU,KUFT,SAAqBkL,EAAOpJ,WAE9BuB,EAAW8H,EAEPrJ,EAAQA,UACVuB,EAAYvB,SAAsBuB,YAGpCA,EAAUtB,aACwC,MAAlDsB,EAAUtB,YAAYqJ,2BAEtBD,GAAY,EACZ9H,EAAUgI,SACThI,EAAUtB,YAAYqJ,yBAAyBF,KAId,MAA/B7H,EAAUiI,oBACbH,GAAY,EACZ9H,EAAUiI,kBAAkBJ,IAGzBC,EACH,OAAOvI,EAAeS,MAA0BA,GAChD,MAAO6D,GACRgE,EAAQhE,QAKLgE,IT2DMjL,EAAiB,SAAA6B,UACpB,MAATA,QAAuCH,IAAtBG,EAAMC,aC1ExBI,EAAU4F,UAAUsD,SAAW,SAASE,EAAQC,OAE3CC,EAEHA,EADsB,MAAnBrB,UAA2BA,WAAoBA,KAAKjC,MACnDiC,SAEAA,SAAkB1J,EAAO,GAAI0J,KAAKjC,OAGlB,mBAAVoD,IAGVA,EAASA,EAAO7K,EAAO,GAAI+K,GAAIrB,KAAKxJ,QAGjC2K,GACH7K,EAAO+K,EAAGF,GAIG,MAAVA,GAEAnB,WACCoB,GAAUpB,SAAsB3I,KAAK+J,GACzC5I,EAAcwH,QAShBjI,EAAU4F,UAAU2D,YAAc,SAASF,GACtCpB,qBAIW,EACVoB,GAAUpB,SAAsB3I,KAAK+J,GACzC5I,EAAcwH,QAchBjI,EAAU4F,UAAUC,OAAS9F,EAwFzBhC,EAAgB,GAQdC,EACa,mBAAXwL,QACJA,QAAQ5D,UAAU6D,KAAKC,KAAKF,QAAQG,WACpCC,WA2CJjJ,MAAyB,ECxNnBzC,EAAaE,ECHRD,EAAI"}
\ No newline at end of file
+{"version":3,"file":"preact.module.js","sources":["../src/constants.js","../src/options.js","../src/create-element.js","../src/component.js","../src/render.js","../src/create-context.js","../src/util.js","../src/diff/children.js","../src/diff/props.js","../src/diff/index.js","../src/clone-element.js","../src/diff/catch-error.js"],"sourcesContent":["export const EMPTY_OBJ = {};\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n","import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n","import options from './options';\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * constructor for this virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\t// https://github.com/preactjs/preact/issues/1916\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\tif (children != null) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != null) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === undefined) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, null);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t// _nextDom must be initialized to undefined b/c it will eventually\n\t\t// be set to dom.nextSibling which can return `null` and it is important\n\t\t// to be able to distinguish between an uninitialized _nextDom and\n\t\t// a _nextDom that has been set to `null`\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\tconstructor: undefined,\n\t\t_original: original\n\t};\n\n\tif (original == null) vnode._original = vnode;\n\tif (options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is import('./internal').VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor === undefined;\n","import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function Component(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nComponent.prototype.setState = function(update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._vnode) {\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nComponent.prototype.forceUpdate = function(callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {import('./index').ComponentChildren | void}\n */\nComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._parent._children.indexOf(vnode) + 1)\n\t\t\t: null;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != null && sibling._dom != null) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : null;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {import('./internal').Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet vnode = component._vnode,\n\t\toldDom = vnode._dom,\n\t\tparentDom = component._parentDom;\n\n\tif (parentDom) {\n\t\tlet commitQueue = [];\n\t\tconst oldVNode = assign({}, vnode);\n\t\toldVNode._original = oldVNode;\n\n\t\tlet newDom = diff(\n\t\t\tparentDom,\n\t\t\tvnode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tparentDom.ownerSVGElement !== undefined,\n\t\t\tnull,\n\t\t\tcommitQueue,\n\t\t\toldDom == null ? getDomSibling(vnode) : oldDom\n\t\t);\n\t\tcommitRoot(commitQueue, vnode);\n\n\t\tif (newDom != oldDom) {\n\t\t\tupdateParentDomPointers(vnode);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./internal').VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != null && vnode._component != null) {\n\t\tvnode._dom = vnode._component.base = null;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != null && child._dom != null) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Component>}\n */\nlet rerenderQueue = [];\n\n/**\n * Asynchronously schedule a callback\n * @type {(cb: () => void) => void}\n */\n/* istanbul ignore next */\n// Note the following line isn't tree-shaken by rollup cuz of rollup/rollup#2566\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\n/**\n * Enqueue a rerender of a component\n * @param {import('./internal').Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet queue;\n\twhile ((process._rerenderCount = rerenderQueue.length)) {\n\t\tqueue = rerenderQueue.sort((a, b) => a._vnode._depth - b._vnode._depth);\n\t\trerenderQueue = [];\n\t\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t\t// process() calls from getting scheduled while `queue` is still being consumed.\n\t\tqueue.some(c => {\n\t\t\tif (c._dirty) renderComponent(c);\n\t\t});\n\t}\n}\nprocess._rerenderCount = 0;\n","import { EMPTY_OBJ, EMPTY_ARR } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\n\nconst IS_HYDRATE = EMPTY_OBJ;\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./index').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * render into\n * @param {Element | Text} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we\n\t// are in hydration mode or not by passing `IS_HYDRATE` instead of a\n\t// DOM element.\n\tlet isHydrating = replaceNode === IS_HYDRATE;\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? null\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\tvnode = createElement(Fragment, null, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\t((isHydrating ? parentDom : replaceNode || parentDom)._children = vnode),\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.ownerSVGElement !== undefined,\n\t\treplaceNode && !isHydrating\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t? null\n\t\t\t: parentDom.childNodes.length\n\t\t\t? EMPTY_ARR.slice.call(parentDom.childNodes)\n\t\t\t: null,\n\t\tcommitQueue,\n\t\treplaceNode || EMPTY_OBJ,\n\t\tisHydrating\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./index').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, IS_HYDRATE);\n}\n","import { enqueueRender } from './component';\n\nexport let i = 0;\n\nexport function createContext(defaultValue, contextId) {\n\tcontextId = '__cC' + i++;\n\n\tconst context = {\n\t\t_id: contextId,\n\t\t_defaultValue: defaultValue,\n\t\tConsumer(props, contextValue) {\n\t\t\t// return props.children(\n\t\t\t// \tcontext[contextId] ? context[contextId].props.value : defaultValue\n\t\t\t// );\n\t\t\treturn props.children(contextValue);\n\t\t},\n\t\tProvider(props, subs, ctx) {\n\t\t\tif (!this.getChildContext) {\n\t\t\t\tsubs = [];\n\t\t\t\tctx = {};\n\t\t\t\tctx[contextId] = this;\n\n\t\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\t\tthis.shouldComponentUpdate = function(_props) {\n\t\t\t\t\tif (this.props.value !== _props.value) {\n\t\t\t\t\t\t// I think the forced value propagation here was only needed when `options.debounceRendering` was being bypassed:\n\t\t\t\t\t\t// https://github.com/preactjs/preact/commit/4d339fb803bea09e9f198abf38ca1bf8ea4b7771#diff-54682ce380935a717e41b8bfc54737f6R358\n\t\t\t\t\t\t// In those cases though, even with the value corrected, we're double-rendering all nodes.\n\t\t\t\t\t\t// It might be better to just tell folks not to use force-sync mode.\n\t\t\t\t\t\t// Currently, using `useContext()` in a class component will overwrite its `this.context` value.\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context[contextId] = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\t\t\t\t\t\tsubs.some(enqueueRender);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.sub = c => {\n\t\t\t\t\tsubs.push(c);\n\t\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\t\tsubs.splice(subs.indexOf(c), 1);\n\t\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn props.children;\n\t\t}\n\t};\n\n\t// Devtools needs access to the context object when it\n\t// encounters a Provider. This is necessary to support\n\t// setting `displayName` on the context object instead\n\t// of on the component itself. See:\n\t// https://reactjs.org/docs/context.html#contextdisplayname\n\n\treturn (context.Provider._contextRef = context.Consumer.contextType = context);\n}\n","/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {Node} node The node to remove\n */\nexport function removeNode(node) {\n\tlet parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n","import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { removeNode } from '../util';\nimport { getDomSibling } from '../component';\n\n/**\n * Diff the children of a virtual node\n * @param {import('../internal').PreactElement} parentDom The DOM element whose\n * children are being diffed\n * @param {import('../index').ComponentChildren[]} renderResult\n * @param {import('../internal').VNode} newParentVNode The new virtual\n * node whose children should be diff'ed against oldParentVNode\n * @param {import('../internal').VNode} oldParentVNode The old virtual\n * node whose children should be diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by getChildContext\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {Node | Text} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet i, j, oldVNode, childVNode, newDom, firstChildDom, refs;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet oldChildrenLength = oldChildren.length;\n\n\t// Only in very specific places should this logic be invoked (top level `render` and `diffElementNodes`).\n\t// I'm using `EMPTY_OBJ` to signal when `diffChildren` is invoked in these situations. I can't use `null`\n\t// for this purpose, because `null` is a valid value for `oldDom` which can mean to skip to this logic\n\t// (e.g. if mounting a new tree in which the old DOM should be ignored (usually for Fragments).\n\tif (oldDom == EMPTY_OBJ) {\n\t\tif (excessDomChildren != null) {\n\t\t\toldDom = excessDomChildren[0];\n\t\t} else if (oldChildrenLength) {\n\t\t\toldDom = getDomSibling(oldParentVNode, 0);\n\t\t} else {\n\t\t\toldDom = null;\n\t\t}\n\t}\n\n\tnewParentVNode._children = [];\n\tfor (i = 0; i < renderResult.length; i++) {\n\t\tchildVNode = renderResult[i];\n\n\t\tif (childVNode == null || typeof childVNode == 'boolean') {\n\t\t\tchildVNode = newParentVNode._children[i] = null;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (typeof childVNode == 'string' || typeof childVNode == 'number') {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tnull,\n\t\t\t\tchildVNode,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t} else if (Array.isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (childVNode._dom != null || childVNode._component != null) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tnull,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\t// Terser removes the `continue` here and wraps the loop body\n\t\t// in a `if (childVNode) { ... } condition\n\t\tif (childVNode == null) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\t// Check if we find a corresponding element in oldChildren.\n\t\t// If found, delete the array item by setting to `undefined`.\n\t\t// We use `undefined`, as `null` is reserved for empty placeholders\n\t\t// (holes).\n\t\toldVNode = oldChildren[i];\n\n\t\tif (\n\t\t\toldVNode === null ||\n\t\t\t(oldVNode &&\n\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\tchildVNode.type === oldVNode.type)\n\t\t) {\n\t\t\toldChildren[i] = undefined;\n\t\t} else {\n\t\t\t// Either oldVNode === undefined or oldChildrenLength > 0,\n\t\t\t// so after this loop oldVNode == null or oldVNode is a valid value.\n\t\t\tfor (j = 0; j < oldChildrenLength; j++) {\n\t\t\t\toldVNode = oldChildren[j];\n\t\t\t\t// If childVNode is unkeyed, we only match similarly unkeyed nodes, otherwise we match by key.\n\t\t\t\t// We always match by type (in either case).\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\t\tchildVNode.type === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\toldChildren[j] = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\toldVNode = null;\n\t\t\t}\n\t\t}\n\n\t\toldVNode = oldVNode || EMPTY_OBJ;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tnewDom = diff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tisSvg,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating\n\t\t);\n\n\t\tif ((j = childVNode.ref) && oldVNode.ref != j) {\n\t\t\tif (!refs) refs = [];\n\t\t\tif (oldVNode.ref) refs.push(oldVNode.ref, null, childVNode);\n\t\t\trefs.push(j, childVNode._component || newDom, childVNode);\n\t\t}\n\n\t\tif (newDom != null) {\n\t\t\tif (firstChildDom == null) {\n\t\t\t\tfirstChildDom = newDom;\n\t\t\t}\n\n\t\t\toldDom = placeChild(\n\t\t\t\tparentDom,\n\t\t\t\tchildVNode,\n\t\t\t\toldVNode,\n\t\t\t\toldChildren,\n\t\t\t\texcessDomChildren,\n\t\t\t\tnewDom,\n\t\t\t\toldDom\n\t\t\t);\n\n\t\t\t// Browsers will infer an option's `value` from `textContent` when\n\t\t\t// no value is present. This essentially bypasses our code to set it\n\t\t\t// later in `diff()`. It works fine in all browsers except for IE11\n\t\t\t// where it breaks setting `select.value`. There it will be always set\n\t\t\t// to an empty string. Re-applying an options value will fix that, so\n\t\t\t// there are probably some internal data structures that aren't\n\t\t\t// updated properly.\n\t\t\t//\n\t\t\t// To fix it we make sure to reset the inferred value, so that our own\n\t\t\t// value check in `diff()` won't be skipped.\n\t\t\tif (!isHydrating && newParentVNode.type == 'option') {\n\t\t\t\tparentDom.value = '';\n\t\t\t} else if (typeof newParentVNode.type == 'function') {\n\t\t\t\t// Because the newParentVNode is Fragment-like, we need to set it's\n\t\t\t\t// _nextDom property to the nextSibling of its last child DOM node.\n\t\t\t\t//\n\t\t\t\t// `oldDom` contains the correct value here because if the last child\n\t\t\t\t// is a Fragment-like, then oldDom has already been set to that child's _nextDom.\n\t\t\t\t// If the last child is a DOM VNode, then oldDom will be set to that DOM\n\t\t\t\t// node's nextSibling.\n\t\t\t\tnewParentVNode._nextDom = oldDom;\n\t\t\t}\n\t\t} else if (\n\t\t\toldDom &&\n\t\t\toldVNode._dom == oldDom &&\n\t\t\toldDom.parentNode != parentDom\n\t\t) {\n\t\t\t// The above condition is to handle null placeholders. See test in placeholder.test.js:\n\t\t\t// `efficiently replace null placeholders in parent rerenders`\n\t\t\toldDom = getDomSibling(oldVNode);\n\t\t}\n\t}\n\n\tnewParentVNode._dom = firstChildDom;\n\n\t// Remove children that are not part of any vnode.\n\tif (excessDomChildren != null && typeof newParentVNode.type != 'function') {\n\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\tif (excessDomChildren[i] != null) removeNode(excessDomChildren[i]);\n\t\t}\n\t}\n\n\t// Remove remaining oldChildren if there are any.\n\tfor (i = oldChildrenLength; i--; ) {\n\t\tif (oldChildren[i] != null) unmount(oldChildren[i], oldChildren[i]);\n\t}\n\n\t// Set refs only after unmount\n\tif (refs) {\n\t\tfor (i = 0; i < refs.length; i++) {\n\t\t\tapplyRef(refs[i], refs[++i], refs[++i]);\n\t\t}\n\t}\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {import('../index').ComponentChildren} children The unflattened\n * children of a virtual node\n * @returns {import('../internal').VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (Array.isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\nexport function placeChild(\n\tparentDom,\n\tchildVNode,\n\toldVNode,\n\toldChildren,\n\texcessDomChildren,\n\tnewDom,\n\toldDom\n) {\n\tlet nextDom;\n\tif (childVNode._nextDom !== undefined) {\n\t\t// Only Fragments or components that return Fragment like VNodes will\n\t\t// have a non-undefined _nextDom. Continue the diff from the sibling\n\t\t// of last DOM child of this child VNode\n\t\tnextDom = childVNode._nextDom;\n\n\t\t// Eagerly cleanup _nextDom. We don't need to persist the value because\n\t\t// it is only used by `diffChildren` to determine where to resume the diff after\n\t\t// diffing Components and Fragments. Once we store it the nextDOM local var, we\n\t\t// can clean up the property\n\t\tchildVNode._nextDom = undefined;\n\t} else if (\n\t\texcessDomChildren == oldVNode ||\n\t\tnewDom != oldDom ||\n\t\tnewDom.parentNode == null\n\t) {\n\t\t// NOTE: excessDomChildren==oldVNode above:\n\t\t// This is a compression of excessDomChildren==null && oldVNode==null!\n\t\t// The values only have the same type when `null`.\n\n\t\touter: if (oldDom == null || oldDom.parentNode !== parentDom) {\n\t\t\tparentDom.appendChild(newDom);\n\t\t\tnextDom = null;\n\t\t} else {\n\t\t\t// `j<oldChildrenLength; j+=2` is an alternative to `j++<oldChildrenLength/2`\n\t\t\tfor (\n\t\t\t\tlet sibDom = oldDom, j = 0;\n\t\t\t\t(sibDom = sibDom.nextSibling) && j < oldChildren.length;\n\t\t\t\tj += 2\n\t\t\t) {\n\t\t\t\tif (sibDom == newDom) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparentDom.insertBefore(newDom, oldDom);\n\t\t\tnextDom = oldDom;\n\t\t}\n\t}\n\n\t// If we have pre-calculated the nextDOM node, use it. Else calculate it now\n\t// Strictly check for `undefined` here cuz `null` is a valid value of `nextDom`.\n\t// See more detail in create-element.js:createVNode\n\tif (nextDom !== undefined) {\n\t\toldDom = nextDom;\n\t} else {\n\t\toldDom = newDom.nextSibling;\n\t}\n\n\treturn oldDom;\n}\n","import { IS_NON_DIMENSIONAL } from '../constants';\nimport options from '../options';\n\n/**\n * Diff the old and new properties of a VNode and apply changes to the DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to apply\n * changes to\n * @param {object} newProps The new props\n * @param {object} oldProps The old props\n * @param {boolean} isSvg Whether or not this node is an SVG node\n * @param {boolean} hydrate Whether or not we are in hydration mode\n */\nexport function diffProps(dom, newProps, oldProps, isSvg, hydrate) {\n\tlet i;\n\n\tfor (i in oldProps) {\n\t\tif (i !== 'children' && i !== 'key' && !(i in newProps)) {\n\t\t\tsetProperty(dom, i, null, oldProps[i], isSvg);\n\t\t}\n\t}\n\n\tfor (i in newProps) {\n\t\tif (\n\t\t\t(!hydrate || typeof newProps[i] == 'function') &&\n\t\t\ti !== 'children' &&\n\t\t\ti !== 'key' &&\n\t\t\ti !== 'value' &&\n\t\t\ti !== 'checked' &&\n\t\t\toldProps[i] !== newProps[i]\n\t\t) {\n\t\t\tsetProperty(dom, i, newProps[i], oldProps[i], isSvg);\n\t\t}\n\t}\n}\n\nfunction setStyle(style, key, value) {\n\tif (key[0] === '-') {\n\t\tstyle.setProperty(key, value);\n\t} else if (value == null) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, isSvg) {\n\tlet useCapture, nameLower, proxy;\n\n\tif (isSvg && name == 'className') name = 'class';\n\n\t// if (isSvg) {\n\t// \tif (name === 'className') name = 'class';\n\t// } else if (name === 'class') name += 'Name';\n\n\tif (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture = name !== (name = name.replace(/Capture$/, ''));\n\t\tnameLower = name.toLowerCase();\n\t\tif (nameLower in dom) name = nameLower;\n\t\tname = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tproxy = useCapture ? eventProxyCapture : eventProxy;\n\t\tif (value) {\n\t\t\tif (!oldValue) dom.addEventListener(name, proxy, useCapture);\n\t\t} else {\n\t\t\tdom.removeEventListener(name, proxy, useCapture);\n\t\t}\n\t} else if (\n\t\tname !== 'list' &&\n\t\tname !== 'tagName' &&\n\t\t// HTMLButtonElement.form and HTMLInputElement.form are read-only but can be set using\n\t\t// setAttribute\n\t\tname !== 'form' &&\n\t\tname !== 'type' &&\n\t\tname !== 'size' &&\n\t\tname !== 'download' &&\n\t\tname !== 'href' &&\n\t\t!isSvg &&\n\t\tname in dom\n\t) {\n\t\tdom[name] = value == null ? '' : value;\n\t} else if (typeof value != 'function' && name !== 'dangerouslySetInnerHTML') {\n\t\tif (name !== (name = name.replace(/xlink:?/, ''))) {\n\t\t\tif (value == null || value === false) {\n\t\t\t\tdom.removeAttributeNS(\n\t\t\t\t\t'http://www.w3.org/1999/xlink',\n\t\t\t\t\tname.toLowerCase()\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tdom.setAttributeNS(\n\t\t\t\t\t'http://www.w3.org/1999/xlink',\n\t\t\t\t\tname.toLowerCase(),\n\t\t\t\t\tvalue\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (\n\t\t\tvalue == null ||\n\t\t\t(value === false &&\n\t\t\t\t// ARIA-attributes have a different notion of boolean values.\n\t\t\t\t// The value `false` is different from the attribute not\n\t\t\t\t// existing on the DOM, so we can't remove it. For non-boolean\n\t\t\t\t// ARIA-attributes we could treat false as a removal, but the\n\t\t\t\t// amount of exceptions would cost us too many bytes. On top of\n\t\t\t\t// that other VDOM frameworks also always stringify `false`.\n\t\t\t\t!/^ar/.test(name))\n\t\t) {\n\t\t\tdom.removeAttribute(name);\n\t\t} else {\n\t\t\tdom.setAttribute(name, value);\n\t\t}\n\t}\n}\n\n/**\n * Proxy an event to hooked event handlers\n * @param {Event} e The event object from the browser\n * @private\n */\nfunction eventProxy(e) {\n\tthis._listeners[e.type + false](options.event ? options.event(e) : e);\n}\n\nfunction eventProxyCapture(e) {\n\tthis._listeners[e.type + true](options.event ? options.event(e) : e);\n}\n","import { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { Component } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren, placeChild } from './children';\nimport { diffProps, setProperty } from './props';\nimport { assign, removeNode } from '../util';\nimport options from '../options';\n\nfunction reorderChildren(newVNode, oldDom, parentDom) {\n\tfor (let tmp = 0; tmp < newVNode._children.length; tmp++) {\n\t\tconst vnode = newVNode._children[tmp];\n\t\tif (vnode) {\n\t\t\tvnode._parent = newVNode;\n\n\t\t\tif (vnode._dom) {\n\t\t\t\tif (typeof vnode.type == 'function' && vnode._children.length > 1) {\n\t\t\t\t\treorderChildren(vnode, oldDom, parentDom);\n\t\t\t\t}\n\n\t\t\t\toldDom = placeChild(\n\t\t\t\t\tparentDom,\n\t\t\t\t\tvnode,\n\t\t\t\t\tvnode,\n\t\t\t\t\tnewVNode._children,\n\t\t\t\t\tnull,\n\t\t\t\t\tvnode._dom,\n\t\t\t\t\toldDom\n\t\t\t\t);\n\n\t\t\t\tif (typeof newVNode.type == 'function') {\n\t\t\t\t\tnewVNode._nextDom = oldDom;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').PreactElement} parentDom The parent of the DOM element\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by getChildContext\n * @param {boolean} isSvg Whether or not this element is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {Element | Text} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} [isHydrating] Whether or not we are in hydration\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== undefined) return null;\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\ttry {\n\t\touter: if (typeof newType == 'function') {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif ('prototype' in newType && newType.prototype.render) {\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\tnewVNode._component = c = new Component(newProps, componentContext);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (c._nextState == null) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\t\t\tif (newType.getDerivedStateFromProps != null) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tc.componentWillMount != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidMount != null) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(!c._force &&\n\t\t\t\t\t\tc.shouldComponentUpdate != null &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\tnewVNode._original === oldVNode._original\n\t\t\t\t) {\n\t\t\t\t\tc.props = newProps;\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original !== oldVNode._original) c._dirty = false;\n\t\t\t\t\tc._vnode = newVNode;\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\treorderChildren(newVNode, oldDom, parentDom);\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != null) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidUpdate != null) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc.state = c._nextState;\n\n\t\t\tif ((tmp = options._render)) tmp(newVNode);\n\n\t\t\tc._dirty = false;\n\t\t\tc._vnode = newVNode;\n\t\t\tc._parentDom = parentDom;\n\n\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != null) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (!isNew && c.getSnapshotBeforeUpdate != null) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != null && tmp.type == Fragment && tmp.key == null;\n\t\t\tlet renderResult = isTopLevelFragment ? tmp.props.children : tmp;\n\n\t\t\tdiffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tArray.isArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = null;\n\t\t\t}\n\n\t\t\tc._force = false;\n\t\t} else if (\n\t\t\texcessDomChildren == null &&\n\t\t\tnewVNode._original === oldVNode._original\n\t\t) {\n\t\t\tnewVNode._children = oldVNode._children;\n\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t} else {\n\t\t\tnewVNode._dom = diffElementNodes(\n\t\t\t\toldVNode._dom,\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\tif ((tmp = options.diffed)) tmp(newVNode);\n\t} catch (e) {\n\t\tnewVNode._original = null;\n\t\toptions._catchError(e, newVNode, oldVNode);\n\t}\n\n\treturn newVNode._dom;\n}\n\n/**\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').VNode} root\n */\nexport function commitRoot(commitQueue, root) {\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {import('../internal').PreactElement} dom The DOM element representing\n * the virtual nodes being diffed\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {*} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @returns {import('../internal').PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating\n) {\n\tlet i;\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\n\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\tisSvg = newVNode.type === 'svg' || isSvg;\n\n\tif (excessDomChildren != null) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tconst child = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tchild != null &&\n\t\t\t\t((newVNode.type === null\n\t\t\t\t\t? child.nodeType === 3\n\t\t\t\t\t: child.localName === newVNode.type) ||\n\t\t\t\t\tdom == child)\n\t\t\t) {\n\t\t\t\tdom = child;\n\t\t\t\texcessDomChildren[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == null) {\n\t\tif (newVNode.type === null) {\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tdom = isSvg\n\t\t\t? document.createElementNS('http://www.w3.org/2000/svg', newVNode.type)\n\t\t\t: document.createElement(\n\t\t\t\t\tnewVNode.type,\n\t\t\t\t\tnewProps.is && { is: newProps.is }\n\t\t\t  );\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = null;\n\t\t// we are creating a new node, so we can assume this is a new subtree (in case we are hydrating), this deopts the hydrate\n\t\tisHydrating = false;\n\t}\n\n\tif (newVNode.type === null) {\n\t\tif (oldProps !== newProps && dom.data !== newProps) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\tif (excessDomChildren != null) {\n\t\t\texcessDomChildren = EMPTY_ARR.slice.call(dom.childNodes);\n\t\t}\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\tlet oldHtml = oldProps.dangerouslySetInnerHTML;\n\t\tlet newHtml = newProps.dangerouslySetInnerHTML;\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tif (!isHydrating) {\n\t\t\t// But, if we are in a situation where we are using existing DOM (e.g. replaceNode)\n\t\t\t// we should read the existing DOM attributes to diff them\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\toldProps = {};\n\t\t\t\tfor (let i = 0; i < dom.attributes.length; i++) {\n\t\t\t\t\toldProps[dom.attributes[i].name] = dom.attributes[i].value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (newHtml || oldHtml) {\n\t\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\t\tif (\n\t\t\t\t\t!newHtml ||\n\t\t\t\t\t((!oldHtml || newHtml.__html != oldHtml.__html) &&\n\t\t\t\t\t\tnewHtml.__html !== dom.innerHTML)\n\t\t\t\t) {\n\t\t\t\t\tdom.innerHTML = (newHtml && newHtml.__html) || '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdiffProps(dom, newProps, oldProps, isSvg, isHydrating);\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\ti = newVNode.props.children;\n\t\t\tdiffChildren(\n\t\t\t\tdom,\n\t\t\t\tArray.isArray(i) ? i : [i],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnewVNode.type === 'foreignObject' ? false : isSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tEMPTY_OBJ,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\t// (as above, don't diff props during hydration)\n\t\tif (!isHydrating) {\n\t\t\tif (\n\t\t\t\t'value' in newProps &&\n\t\t\t\t(i = newProps.value) !== undefined &&\n\t\t\t\ti !== dom.value\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'value', i, oldProps.value, false);\n\t\t\t}\n\t\t\tif (\n\t\t\t\t'checked' in newProps &&\n\t\t\t\t(i = newProps.checked) !== undefined &&\n\t\t\t\ti !== dom.checked\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'checked', i, oldProps.checked, false);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {object|function} ref\n * @param {any} value\n * @param {import('../internal').VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') ref(value);\n\t\telse ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {import('../internal').VNode} vnode The virtual node to unmount\n * @param {import('../internal').VNode} parentVNode The parent of the VNode that\n * initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current === vnode._dom) applyRef(r, null, parentVNode);\n\t}\n\n\tlet dom;\n\tif (!skipRemove && typeof vnode.type != 'function') {\n\t\tskipRemove = (dom = vnode._dom) != null;\n\t}\n\n\t// Must be set to `undefined` to properly clean up `_nextDom`\n\t// for which `null` is a valid value. See comment in `create-element.js`\n\tvnode._dom = vnode._nextDom = undefined;\n\n\tif ((r = vnode._component) != null) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = null;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) unmount(r[i], parentVNode, skipRemove);\n\t\t}\n\t}\n\n\tif (dom != null) removeNode(dom);\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n","import { assign } from './util';\nimport { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./index').ComponentChildren>} rest Any additional arguments will be used as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\tif (children != null) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tnull\n\t);\n}\n","import { enqueueRender } from '../component';\n\n/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').VNode} vnode The vnode that threw\n * the error that was caught (except for unmounting when this parameter\n * is the highest parent that was being unmounted)\n */\nexport function _catchError(error, vnode) {\n\t/** @type {import('../internal').Component} */\n\tlet component, hasCaught;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tif (\n\t\t\t\t\tcomponent.constructor &&\n\t\t\t\t\tcomponent.constructor.getDerivedStateFromError != null\n\t\t\t\t) {\n\t\t\t\t\thasCaught = true;\n\t\t\t\t\tcomponent.setState(\n\t\t\t\t\t\tcomponent.constructor.getDerivedStateFromError(error)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != null) {\n\t\t\t\t\thasCaught = true;\n\t\t\t\t\tcomponent.componentDidCatch(error);\n\t\t\t\t}\n\n\t\t\t\tif (hasCaught)\n\t\t\t\t\treturn enqueueRender((component._pendingError = component));\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n"],"names":["options","isValidElement","rerenderQueue","defer","prevDebounce","IS_HYDRATE","i","EMPTY_OBJ","EMPTY_ARR","IS_NON_DIMENSIONAL","assign","obj","props","removeNode","node","parentNode","removeChild","createElement","type","children","key","ref","normalizedProps","arguments","length","push","defaultProps","undefined","createVNode","original","vnode","constructor","createRef","current","Fragment","Component","context","getDomSibling","childIndex","indexOf","sibling","updateParentDomPointers","child","base","enqueueRender","c","process","debounceRendering","queue","sort","a","b","some","component","commitQueue","oldVNode","newDom","oldDom","parentDom","diff","ownerSVGElement","commitRoot","diffChildren","renderResult","newParentVNode","oldParentVNode","globalContext","isSvg","excessDomChildren","isHydrating","j","childVNode","firstChildDom","refs","oldChildren","oldChildrenLength","Array","isArray","placeChild","value","unmount","applyRef","toChildArray","out","nextDom","sibDom","outer","appendChild","nextSibling","insertBefore","diffProps","dom","newProps","oldProps","hydrate","setProperty","setStyle","style","test","name","oldValue","useCapture","nameLower","proxy","cssText","replace","toLowerCase","slice","_listeners","eventProxyCapture","eventProxy","addEventListener","removeEventListener","removeAttributeNS","setAttributeNS","removeAttribute","setAttribute","e","event","reorderChildren","newVNode","tmp","isNew","oldState","snapshot","clearProcessingException","provider","componentContext","newType","contextType","prototype","render","doRender","sub","state","getDerivedStateFromProps","componentWillMount","componentDidMount","componentWillReceiveProps","shouldComponentUpdate","componentWillUpdate","componentDidUpdate","getChildContext","getSnapshotBeforeUpdate","diffElementNodes","diffed","root","cb","call","oldHtml","newHtml","nodeType","localName","document","createTextNode","createElementNS","is","data","childNodes","dangerouslySetInnerHTML","attributes","innerHTML","checked","parentVNode","skipRemove","r","componentWillUnmount","this","replaceNode","cloneElement","createContext","defaultValue","contextId","Consumer","contextValue","Provider","subs","ctx","_props","old","splice","error","hasCaught","getDerivedStateFromError","setState","componentDidCatch","update","callback","s","forceUpdate","Promise","then","bind","resolve","setTimeout"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/preact/dist/preact.umd.js b/node_modules/preact/dist/preact.umd.js
index e00b469..6971f94 100644
--- a/node_modules/preact/dist/preact.umd.js
+++ b/node_modules/preact/dist/preact.umd.js
@@ -1,2 +1,2 @@
-!function(n,l){"object"==typeof exports&&"undefined"!=typeof module?l(exports):"function"==typeof define&&define.amd?define(["exports"],l):l(n.preact={})}(this,function(n){var l,u,i,t,o,f,r,e={},c=[],s=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function a(n,l){for(var u in l)n[u]=l[u];return n}function v(n){var l=n.parentNode;l&&l.removeChild(n)}function h(n,l,u){var i,t,o,f=arguments,r={};for(o in l)"key"==o?i=l[o]:"ref"==o?t=l[o]:r[o]=l[o];if(arguments.length>3)for(u=[u],o=3;o<arguments.length;o++)u.push(f[o]);if(null!=u&&(r.children=u),"function"==typeof n&&null!=n.defaultProps)for(o in n.defaultProps)void 0===r[o]&&(r[o]=n.defaultProps[o]);return y(n,r,i,t,null)}function y(n,u,i,t,o){var f={type:n,props:u,key:i,ref:t,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,constructor:void 0,__v:o};return null==o&&(f.__v=f),null!=l.vnode&&l.vnode(f),f}function p(n){return n.children}function d(n,l){this.props=n,this.context=l}function _(n,l){if(null==l)return n.__?_(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return"function"==typeof n.type?_(n):null}function w(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return w(n)}}function k(n){(!n.__d&&(n.__d=!0)&&i.push(n)&&!m.__r++||o!==l.debounceRendering)&&((o=l.debounceRendering)||t)(m)}function m(){for(var n;m.__r=i.length;)n=i.sort(function(n,l){return n.__v.__b-l.__v.__b}),i=[],n.some(function(n){var l,u,i,t,o,f,r;n.__d&&(f=(o=(l=n).__v).__e,(r=l.__P)&&(u=[],(i=a({},o)).__v=i,t=z(r,o,i,l.__n,void 0!==r.ownerSVGElement,null,u,null==f?_(o):f),N(u,o),t!=f&&w(o)))})}function g(n,l,u,i,t,o,f,r,s,a){var h,d,w,k,m,g,x,A=i&&i.__k||c,P=A.length;for(s==e&&(s=null!=f?f[0]:P?_(i,0):null),u.__k=[],h=0;h<l.length;h++)if(null!=(k=u.__k[h]=null==(k=l[h])||"boolean"==typeof k?null:"string"==typeof k||"number"==typeof k?y(null,k,null,null,k):Array.isArray(k)?y(p,{children:k},null,null,null):null!=k.__e||null!=k.__c?y(k.type,k.props,k.key,null,k.__v):k)){if(k.__=u,k.__b=u.__b+1,null===(w=A[h])||w&&k.key==w.key&&k.type===w.type)A[h]=void 0;else for(d=0;d<P;d++){if((w=A[d])&&k.key==w.key&&k.type===w.type){A[d]=void 0;break}w=null}m=z(n,k,w=w||e,t,o,f,r,s,a),(d=k.ref)&&w.ref!=d&&(x||(x=[]),w.ref&&x.push(w.ref,null,k),x.push(d,k.__c||m,k)),null!=m?(null==g&&(g=m),s=b(n,k,w,A,f,m,s),a||"option"!=u.type?"function"==typeof u.type&&(u.__d=s):n.value=""):s&&w.__e==s&&s.parentNode!=n&&(s=_(w))}if(u.__e=g,null!=f&&"function"!=typeof u.type)for(h=f.length;h--;)null!=f[h]&&v(f[h]);for(h=P;h--;)null!=A[h]&&H(A[h],A[h]);if(x)for(h=0;h<x.length;h++)$(x[h],x[++h],x[++h])}function b(n,l,u,i,t,o,f){var r,e,c;if(void 0!==l.__d)r=l.__d,l.__d=void 0;else if(t==u||o!=f||null==o.parentNode)n:if(null==f||f.parentNode!==n)n.appendChild(o),r=null;else{for(e=f,c=0;(e=e.nextSibling)&&c<i.length;c+=2)if(e==o)break n;n.insertBefore(o,f),r=f}return void 0!==r?r:o.nextSibling}function x(n,l,u,i,t){var o;for(o in u)"children"===o||"key"===o||o in l||P(n,o,null,u[o],i);for(o in l)t&&"function"!=typeof l[o]||"children"===o||"key"===o||"value"===o||"checked"===o||u[o]===l[o]||P(n,o,l[o],u[o],i)}function A(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]=null==u?"":"number"!=typeof u||s.test(l)?u:u+"px"}function P(n,l,u,i,t){var o,f;if(t&&"className"==l&&(l="class"),"style"===l)if("string"==typeof u)n.style=u;else{if("string"==typeof i&&(n.style=i=""),i)for(l in i)u&&l in u||A(n.style,l,"");if(u)for(l in u)i&&u[l]===i[l]||A(n.style,l,u[l])}else"o"===l[0]&&"n"===l[1]?(o=l!==(l=l.replace(/Capture$/,"")),(f=l.toLowerCase())in n&&(l=f),l=l.slice(2),n.l||(n.l={}),n.l[l]=u,u?i||n.addEventListener(l,C,o):n.removeEventListener(l,C,o)):"list"!==l&&"tagName"!==l&&"form"!==l&&"type"!==l&&"size"!==l&&"download"!==l&&"href"!==l&&!t&&l in n?n[l]=null==u?"":u:"function"!=typeof u&&"dangerouslySetInnerHTML"!==l&&(l!==(l=l.replace(/xlink:?/,""))?null==u||!1===u?n.removeAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase()):n.setAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase(),u):null==u||!1===u&&!/^ar/.test(l)?n.removeAttribute(l):n.setAttribute(l,u))}function C(n){this.l[n.type](l.event?l.event(n):n)}function j(n,l,u){var i,t;for(i=0;i<n.__k.length;i++)(t=n.__k[i])&&(t.__=n,t.__e&&("function"==typeof t.type&&t.__k.length>1&&j(t,l,u),l=b(u,t,t,n.__k,null,t.__e,l),"function"==typeof n.type&&(n.__d=l)))}function z(n,u,i,t,o,f,r,e,c){var s,v,h,y,_,w,k,m,b,x,A,P=u.type;if(void 0!==u.constructor)return null;(s=l.__b)&&s(u);try{n:if("function"==typeof P){if(m=u.props,b=(s=P.contextType)&&t[s.__c],x=s?b?b.props.value:s.__:t,i.__c?k=(v=u.__c=i.__c).__=v.__E:("prototype"in P&&P.prototype.render?u.__c=v=new P(m,x):(u.__c=v=new d(m,x),v.constructor=P,v.render=I),b&&b.sub(v),v.props=m,v.state||(v.state={}),v.context=x,v.__n=t,h=v.__d=!0,v.__h=[]),null==v.__s&&(v.__s=v.state),null!=P.getDerivedStateFromProps&&(v.__s==v.state&&(v.__s=a({},v.__s)),a(v.__s,P.getDerivedStateFromProps(m,v.__s))),y=v.props,_=v.state,h)null==P.getDerivedStateFromProps&&null!=v.componentWillMount&&v.componentWillMount(),null!=v.componentDidMount&&v.__h.push(v.componentDidMount);else{if(null==P.getDerivedStateFromProps&&m!==y&&null!=v.componentWillReceiveProps&&v.componentWillReceiveProps(m,x),!v.__e&&null!=v.shouldComponentUpdate&&!1===v.shouldComponentUpdate(m,v.__s,x)||u.__v===i.__v){v.props=m,v.state=v.__s,u.__v!==i.__v&&(v.__d=!1),v.__v=u,u.__e=i.__e,u.__k=i.__k,v.__h.length&&r.push(v),j(u,e,n);break n}null!=v.componentWillUpdate&&v.componentWillUpdate(m,v.__s,x),null!=v.componentDidUpdate&&v.__h.push(function(){v.componentDidUpdate(y,_,w)})}v.context=x,v.props=m,v.state=v.__s,(s=l.__r)&&s(u),v.__d=!1,v.__v=u,v.__P=n,s=v.render(v.props,v.state,v.context),v.state=v.__s,null!=v.getChildContext&&(t=a(a({},t),v.getChildContext())),h||null==v.getSnapshotBeforeUpdate||(w=v.getSnapshotBeforeUpdate(y,_)),A=null!=s&&s.type==p&&null==s.key?s.props.children:s,g(n,Array.isArray(A)?A:[A],u,i,t,o,f,r,e,c),v.base=u.__e,v.__h.length&&r.push(v),k&&(v.__E=v.__=null),v.__e=!1}else null==f&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=T(i.__e,u,i,t,o,f,r,c);(s=l.diffed)&&s(u)}catch(n){u.__v=null,l.__e(n,u,i)}return u.__e}function N(n,u){l.__c&&l.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u)})}catch(n){l.__e(n,u.__v)}})}function T(n,l,u,i,t,o,f,r){var s,a,v,h,y,p=u.props,d=l.props;if(t="svg"===l.type||t,null!=o)for(s=0;s<o.length;s++)if(null!=(a=o[s])&&((null===l.type?3===a.nodeType:a.localName===l.type)||n==a)){n=a,o[s]=null;break}if(null==n){if(null===l.type)return document.createTextNode(d);n=t?document.createElementNS("http://www.w3.org/2000/svg",l.type):document.createElement(l.type,d.is&&{is:d.is}),o=null,r=!1}if(null===l.type)p!==d&&n.data!==d&&(n.data=d);else{if(null!=o&&(o=c.slice.call(n.childNodes)),v=(p=u.props||e).dangerouslySetInnerHTML,h=d.dangerouslySetInnerHTML,!r){if(null!=o)for(p={},y=0;y<n.attributes.length;y++)p[n.attributes[y].name]=n.attributes[y].value;(h||v)&&(h&&v&&h.__html==v.__html||(n.innerHTML=h&&h.__html||""))}x(n,d,p,t,r),h?l.__k=[]:(s=l.props.children,g(n,Array.isArray(s)?s:[s],l,u,i,"foreignObject"!==l.type&&t,o,f,e,r)),r||("value"in d&&void 0!==(s=d.value)&&s!==n.value&&P(n,"value",s,p.value,!1),"checked"in d&&void 0!==(s=d.checked)&&s!==n.checked&&P(n,"checked",s,p.checked,!1))}return n}function $(n,u,i){try{"function"==typeof n?n(u):n.current=u}catch(n){l.__e(n,i)}}function H(n,u,i){var t,o,f;if(l.unmount&&l.unmount(n),(t=n.ref)&&(t.current&&t.current!==n.__e||$(t,null,u)),i||"function"==typeof n.type||(i=null!=(o=n.__e)),n.__e=n.__d=void 0,null!=(t=n.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount()}catch(n){l.__e(n,u)}t.base=t.__P=null}if(t=n.__k)for(f=0;f<t.length;f++)t[f]&&H(t[f],u,i);null!=o&&v(o)}function I(n,l,u){return this.constructor(n,u)}function L(n,u,i){var t,o,r;l.__&&l.__(n,u),o=(t=i===f)?null:i&&i.__k||u.__k,n=h(p,null,[n]),r=[],z(u,(t?u:i||u).__k=n,o||e,e,void 0!==u.ownerSVGElement,i&&!t?[i]:o?null:u.childNodes.length?c.slice.call(u.childNodes):null,r,i||e,t),N(r,n)}l={__e:function(n,l){for(var u,i;l=l.__;)if((u=l.__c)&&!u.__)try{if(u.constructor&&null!=u.constructor.getDerivedStateFromError&&(i=!0,u.setState(u.constructor.getDerivedStateFromError(n))),null!=u.componentDidCatch&&(i=!0,u.componentDidCatch(n)),i)return k(u.__E=u)}catch(l){n=l}throw n}},u=function(n){return null!=n&&void 0===n.constructor},d.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=a({},this.state),"function"==typeof n&&(n=n(a({},u),this.props)),n&&a(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),k(this))},d.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),k(this))},d.prototype.render=p,i=[],t="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,m.__r=0,f=e,r=0,n.render=L,n.hydrate=function(n,l){L(n,l,f)},n.createElement=h,n.h=h,n.Fragment=p,n.createRef=function(){return{current:null}},n.isValidElement=u,n.Component=d,n.cloneElement=function(n,l,u){var i,t,o,f=arguments,r=a({},n.props);for(o in l)"key"==o?i=l[o]:"ref"==o?t=l[o]:r[o]=l[o];if(arguments.length>3)for(u=[u],o=3;o<arguments.length;o++)u.push(f[o]);return null!=u&&(r.children=u),y(n.type,r,i||n.key,t||n.ref,null)},n.createContext=function(n,l){var u={__c:l="__cC"+r++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n,u,i){return this.getChildContext||(u=[],(i={})[l]=this,this.getChildContext=function(){return i},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(k)},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u},n.toChildArray=function n(l,u){return u=u||[],null==l||"boolean"==typeof l||(Array.isArray(l)?l.some(function(l){n(l,u)}):u.push(l)),u},n.__u=H,n.options=l});
+!function(n,l){"object"==typeof exports&&"undefined"!=typeof module?l(exports):"function"==typeof define&&define.amd?define(["exports"],l):l(n.preact={})}(this,function(n){var l,u,i,t,o,f,r,e={},c=[],s=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function a(n,l){for(var u in l)n[u]=l[u];return n}function v(n){var l=n.parentNode;l&&l.removeChild(n)}function h(n,l,u){var i,t,o,f=arguments,r={};for(o in l)"key"==o?i=l[o]:"ref"==o?t=l[o]:r[o]=l[o];if(arguments.length>3)for(u=[u],o=3;o<arguments.length;o++)u.push(f[o]);if(null!=u&&(r.children=u),"function"==typeof n&&null!=n.defaultProps)for(o in n.defaultProps)void 0===r[o]&&(r[o]=n.defaultProps[o]);return y(n,r,i,t,null)}function y(n,u,i,t,o){var f={type:n,props:u,key:i,ref:t,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,constructor:void 0,__v:o};return null==o&&(f.__v=f),null!=l.vnode&&l.vnode(f),f}function p(n){return n.children}function d(n,l){this.props=n,this.context=l}function _(n,l){if(null==l)return n.__?_(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return"function"==typeof n.type?_(n):null}function w(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return w(n)}}function k(n){(!n.__d&&(n.__d=!0)&&i.push(n)&&!m.__r++||o!==l.debounceRendering)&&((o=l.debounceRendering)||t)(m)}function m(){for(var n;m.__r=i.length;)n=i.sort(function(n,l){return n.__v.__b-l.__v.__b}),i=[],n.some(function(n){var l,u,i,t,o,f,r;n.__d&&(f=(o=(l=n).__v).__e,(r=l.__P)&&(u=[],(i=a({},o)).__v=i,t=N(r,o,i,l.__n,void 0!==r.ownerSVGElement,null,u,null==f?_(o):f),T(u,o),t!=f&&w(o)))})}function g(n,l,u,i,t,o,f,r,s,a){var h,d,w,k,m,g,x,A=i&&i.__k||c,P=A.length;for(s==e&&(s=null!=f?f[0]:P?_(i,0):null),u.__k=[],h=0;h<l.length;h++)if(null!=(k=u.__k[h]=null==(k=l[h])||"boolean"==typeof k?null:"string"==typeof k||"number"==typeof k?y(null,k,null,null,k):Array.isArray(k)?y(p,{children:k},null,null,null):null!=k.__e||null!=k.__c?y(k.type,k.props,k.key,null,k.__v):k)){if(k.__=u,k.__b=u.__b+1,null===(w=A[h])||w&&k.key==w.key&&k.type===w.type)A[h]=void 0;else for(d=0;d<P;d++){if((w=A[d])&&k.key==w.key&&k.type===w.type){A[d]=void 0;break}w=null}m=N(n,k,w=w||e,t,o,f,r,s,a),(d=k.ref)&&w.ref!=d&&(x||(x=[]),w.ref&&x.push(w.ref,null,k),x.push(d,k.__c||m,k)),null!=m?(null==g&&(g=m),s=b(n,k,w,A,f,m,s),a||"option"!=u.type?"function"==typeof u.type&&(u.__d=s):n.value=""):s&&w.__e==s&&s.parentNode!=n&&(s=_(w))}if(u.__e=g,null!=f&&"function"!=typeof u.type)for(h=f.length;h--;)null!=f[h]&&v(f[h]);for(h=P;h--;)null!=A[h]&&I(A[h],A[h]);if(x)for(h=0;h<x.length;h++)H(x[h],x[++h],x[++h])}function b(n,l,u,i,t,o,f){var r,e,c;if(void 0!==l.__d)r=l.__d,l.__d=void 0;else if(t==u||o!=f||null==o.parentNode)n:if(null==f||f.parentNode!==n)n.appendChild(o),r=null;else{for(e=f,c=0;(e=e.nextSibling)&&c<i.length;c+=2)if(e==o)break n;n.insertBefore(o,f),r=f}return void 0!==r?r:o.nextSibling}function x(n,l,u,i,t){var o;for(o in u)"children"===o||"key"===o||o in l||P(n,o,null,u[o],i);for(o in l)t&&"function"!=typeof l[o]||"children"===o||"key"===o||"value"===o||"checked"===o||u[o]===l[o]||P(n,o,l[o],u[o],i)}function A(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]=null==u?"":"number"!=typeof u||s.test(l)?u:u+"px"}function P(n,l,u,i,t){var o,f,r;if(t&&"className"==l&&(l="class"),"style"===l)if("string"==typeof u)n.style.cssText=u;else{if("string"==typeof i&&(n.style.cssText=i=""),i)for(l in i)u&&l in u||A(n.style,l,"");if(u)for(l in u)i&&u[l]===i[l]||A(n.style,l,u[l])}else"o"===l[0]&&"n"===l[1]?(o=l!==(l=l.replace(/Capture$/,"")),(f=l.toLowerCase())in n&&(l=f),l=l.slice(2),n.l||(n.l={}),n.l[l+o]=u,r=o?j:C,u?i||n.addEventListener(l,r,o):n.removeEventListener(l,r,o)):"list"!==l&&"tagName"!==l&&"form"!==l&&"type"!==l&&"size"!==l&&"download"!==l&&"href"!==l&&!t&&l in n?n[l]=null==u?"":u:"function"!=typeof u&&"dangerouslySetInnerHTML"!==l&&(l!==(l=l.replace(/xlink:?/,""))?null==u||!1===u?n.removeAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase()):n.setAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase(),u):null==u||!1===u&&!/^ar/.test(l)?n.removeAttribute(l):n.setAttribute(l,u))}function C(n){this.l[n.type+!1](l.event?l.event(n):n)}function j(n){this.l[n.type+!0](l.event?l.event(n):n)}function z(n,l,u){var i,t;for(i=0;i<n.__k.length;i++)(t=n.__k[i])&&(t.__=n,t.__e&&("function"==typeof t.type&&t.__k.length>1&&z(t,l,u),l=b(u,t,t,n.__k,null,t.__e,l),"function"==typeof n.type&&(n.__d=l)))}function N(n,u,i,t,o,f,r,e,c){var s,v,h,y,_,w,k,m,b,x,A,P=u.type;if(void 0!==u.constructor)return null;(s=l.__b)&&s(u);try{n:if("function"==typeof P){if(m=u.props,b=(s=P.contextType)&&t[s.__c],x=s?b?b.props.value:s.__:t,i.__c?k=(v=u.__c=i.__c).__=v.__E:("prototype"in P&&P.prototype.render?u.__c=v=new P(m,x):(u.__c=v=new d(m,x),v.constructor=P,v.render=L),b&&b.sub(v),v.props=m,v.state||(v.state={}),v.context=x,v.__n=t,h=v.__d=!0,v.__h=[]),null==v.__s&&(v.__s=v.state),null!=P.getDerivedStateFromProps&&(v.__s==v.state&&(v.__s=a({},v.__s)),a(v.__s,P.getDerivedStateFromProps(m,v.__s))),y=v.props,_=v.state,h)null==P.getDerivedStateFromProps&&null!=v.componentWillMount&&v.componentWillMount(),null!=v.componentDidMount&&v.__h.push(v.componentDidMount);else{if(null==P.getDerivedStateFromProps&&m!==y&&null!=v.componentWillReceiveProps&&v.componentWillReceiveProps(m,x),!v.__e&&null!=v.shouldComponentUpdate&&!1===v.shouldComponentUpdate(m,v.__s,x)||u.__v===i.__v){v.props=m,v.state=v.__s,u.__v!==i.__v&&(v.__d=!1),v.__v=u,u.__e=i.__e,u.__k=i.__k,v.__h.length&&r.push(v),z(u,e,n);break n}null!=v.componentWillUpdate&&v.componentWillUpdate(m,v.__s,x),null!=v.componentDidUpdate&&v.__h.push(function(){v.componentDidUpdate(y,_,w)})}v.context=x,v.props=m,v.state=v.__s,(s=l.__r)&&s(u),v.__d=!1,v.__v=u,v.__P=n,s=v.render(v.props,v.state,v.context),v.state=v.__s,null!=v.getChildContext&&(t=a(a({},t),v.getChildContext())),h||null==v.getSnapshotBeforeUpdate||(w=v.getSnapshotBeforeUpdate(y,_)),A=null!=s&&s.type==p&&null==s.key?s.props.children:s,g(n,Array.isArray(A)?A:[A],u,i,t,o,f,r,e,c),v.base=u.__e,v.__h.length&&r.push(v),k&&(v.__E=v.__=null),v.__e=!1}else null==f&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=$(i.__e,u,i,t,o,f,r,c);(s=l.diffed)&&s(u)}catch(n){u.__v=null,l.__e(n,u,i)}return u.__e}function T(n,u){l.__c&&l.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u)})}catch(n){l.__e(n,u.__v)}})}function $(n,l,u,i,t,o,f,r){var s,a,v,h,y,p=u.props,d=l.props;if(t="svg"===l.type||t,null!=o)for(s=0;s<o.length;s++)if(null!=(a=o[s])&&((null===l.type?3===a.nodeType:a.localName===l.type)||n==a)){n=a,o[s]=null;break}if(null==n){if(null===l.type)return document.createTextNode(d);n=t?document.createElementNS("http://www.w3.org/2000/svg",l.type):document.createElement(l.type,d.is&&{is:d.is}),o=null,r=!1}if(null===l.type)p!==d&&n.data!==d&&(n.data=d);else{if(null!=o&&(o=c.slice.call(n.childNodes)),v=(p=u.props||e).dangerouslySetInnerHTML,h=d.dangerouslySetInnerHTML,!r){if(null!=o)for(p={},y=0;y<n.attributes.length;y++)p[n.attributes[y].name]=n.attributes[y].value;(h||v)&&(h&&(v&&h.__html==v.__html||h.__html===n.innerHTML)||(n.innerHTML=h&&h.__html||""))}x(n,d,p,t,r),h?l.__k=[]:(s=l.props.children,g(n,Array.isArray(s)?s:[s],l,u,i,"foreignObject"!==l.type&&t,o,f,e,r)),r||("value"in d&&void 0!==(s=d.value)&&s!==n.value&&P(n,"value",s,p.value,!1),"checked"in d&&void 0!==(s=d.checked)&&s!==n.checked&&P(n,"checked",s,p.checked,!1))}return n}function H(n,u,i){try{"function"==typeof n?n(u):n.current=u}catch(n){l.__e(n,i)}}function I(n,u,i){var t,o,f;if(l.unmount&&l.unmount(n),(t=n.ref)&&(t.current&&t.current!==n.__e||H(t,null,u)),i||"function"==typeof n.type||(i=null!=(o=n.__e)),n.__e=n.__d=void 0,null!=(t=n.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount()}catch(n){l.__e(n,u)}t.base=t.__P=null}if(t=n.__k)for(f=0;f<t.length;f++)t[f]&&I(t[f],u,i);null!=o&&v(o)}function L(n,l,u){return this.constructor(n,u)}function M(n,u,i){var t,o,r;l.__&&l.__(n,u),o=(t=i===f)?null:i&&i.__k||u.__k,n=h(p,null,[n]),r=[],N(u,(t?u:i||u).__k=n,o||e,e,void 0!==u.ownerSVGElement,i&&!t?[i]:o?null:u.childNodes.length?c.slice.call(u.childNodes):null,r,i||e,t),T(r,n)}l={__e:function(n,l){for(var u,i;l=l.__;)if((u=l.__c)&&!u.__)try{if(u.constructor&&null!=u.constructor.getDerivedStateFromError&&(i=!0,u.setState(u.constructor.getDerivedStateFromError(n))),null!=u.componentDidCatch&&(i=!0,u.componentDidCatch(n)),i)return k(u.__E=u)}catch(l){n=l}throw n}},u=function(n){return null!=n&&void 0===n.constructor},d.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=a({},this.state),"function"==typeof n&&(n=n(a({},u),this.props)),n&&a(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),k(this))},d.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),k(this))},d.prototype.render=p,i=[],t="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,m.__r=0,f=e,r=0,n.render=M,n.hydrate=function(n,l){M(n,l,f)},n.createElement=h,n.h=h,n.Fragment=p,n.createRef=function(){return{current:null}},n.isValidElement=u,n.Component=d,n.cloneElement=function(n,l,u){var i,t,o,f=arguments,r=a({},n.props);for(o in l)"key"==o?i=l[o]:"ref"==o?t=l[o]:r[o]=l[o];if(arguments.length>3)for(u=[u],o=3;o<arguments.length;o++)u.push(f[o]);return null!=u&&(r.children=u),y(n.type,r,i||n.key,t||n.ref,null)},n.createContext=function(n,l){var u={__c:l="__cC"+r++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n,u,i){return this.getChildContext||(u=[],(i={})[l]=this,this.getChildContext=function(){return i},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(k)},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u},n.toChildArray=function n(l,u){return u=u||[],null==l||"boolean"==typeof l||(Array.isArray(l)?l.some(function(l){n(l,u)}):u.push(l)),u},n.__u=I,n.options=l});
 //# sourceMappingURL=preact.umd.js.map
diff --git a/node_modules/preact/dist/preact.umd.js.map b/node_modules/preact/dist/preact.umd.js.map
index e7d778a..41cddcc 100644
--- a/node_modules/preact/dist/preact.umd.js.map
+++ b/node_modules/preact/dist/preact.umd.js.map
@@ -1 +1 @@
-{"version":3,"file":"preact.umd.js","sources":["../src/options.js","../src/create-element.js","../src/component.js","../src/render.js","../src/create-context.js","../src/constants.js","../src/util.js","../src/diff/children.js","../src/diff/props.js","../src/diff/index.js","../src/diff/catch-error.js","../src/clone-element.js"],"sourcesContent":["import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n","import options from './options';\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * constructor for this virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\t// https://github.com/preactjs/preact/issues/1916\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\tif (children != null) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != null) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === undefined) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, null);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t// _nextDom must be initialized to undefined b/c it will eventually\n\t\t// be set to dom.nextSibling which can return `null` and it is important\n\t\t// to be able to distinguish between an uninitialized _nextDom and\n\t\t// a _nextDom that has been set to `null`\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\tconstructor: undefined,\n\t\t_original: original\n\t};\n\n\tif (original == null) vnode._original = vnode;\n\tif (options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is import('./internal').VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor === undefined;\n","import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function Component(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nComponent.prototype.setState = function(update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._vnode) {\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nComponent.prototype.forceUpdate = function(callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {import('./index').ComponentChildren | void}\n */\nComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._parent._children.indexOf(vnode) + 1)\n\t\t\t: null;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != null && sibling._dom != null) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : null;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {import('./internal').Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet vnode = component._vnode,\n\t\toldDom = vnode._dom,\n\t\tparentDom = component._parentDom;\n\n\tif (parentDom) {\n\t\tlet commitQueue = [];\n\t\tconst oldVNode = assign({}, vnode);\n\t\toldVNode._original = oldVNode;\n\n\t\tlet newDom = diff(\n\t\t\tparentDom,\n\t\t\tvnode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tparentDom.ownerSVGElement !== undefined,\n\t\t\tnull,\n\t\t\tcommitQueue,\n\t\t\toldDom == null ? getDomSibling(vnode) : oldDom\n\t\t);\n\t\tcommitRoot(commitQueue, vnode);\n\n\t\tif (newDom != oldDom) {\n\t\t\tupdateParentDomPointers(vnode);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./internal').VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != null && vnode._component != null) {\n\t\tvnode._dom = vnode._component.base = null;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != null && child._dom != null) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Component>}\n */\nlet rerenderQueue = [];\n\n/**\n * Asynchronously schedule a callback\n * @type {(cb: () => void) => void}\n */\n/* istanbul ignore next */\n// Note the following line isn't tree-shaken by rollup cuz of rollup/rollup#2566\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\n/**\n * Enqueue a rerender of a component\n * @param {import('./internal').Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet queue;\n\twhile ((process._rerenderCount = rerenderQueue.length)) {\n\t\tqueue = rerenderQueue.sort((a, b) => a._vnode._depth - b._vnode._depth);\n\t\trerenderQueue = [];\n\t\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t\t// process() calls from getting scheduled while `queue` is still being consumed.\n\t\tqueue.some(c => {\n\t\t\tif (c._dirty) renderComponent(c);\n\t\t});\n\t}\n}\nprocess._rerenderCount = 0;\n","import { EMPTY_OBJ, EMPTY_ARR } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\n\nconst IS_HYDRATE = EMPTY_OBJ;\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./index').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * render into\n * @param {Element | Text} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we\n\t// are in hydration mode or not by passing `IS_HYDRATE` instead of a\n\t// DOM element.\n\tlet isHydrating = replaceNode === IS_HYDRATE;\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? null\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\tvnode = createElement(Fragment, null, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\t((isHydrating ? parentDom : replaceNode || parentDom)._children = vnode),\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.ownerSVGElement !== undefined,\n\t\treplaceNode && !isHydrating\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t? null\n\t\t\t: parentDom.childNodes.length\n\t\t\t? EMPTY_ARR.slice.call(parentDom.childNodes)\n\t\t\t: null,\n\t\tcommitQueue,\n\t\treplaceNode || EMPTY_OBJ,\n\t\tisHydrating\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./index').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, IS_HYDRATE);\n}\n","import { enqueueRender } from './component';\n\nexport let i = 0;\n\nexport function createContext(defaultValue, contextId) {\n\tcontextId = '__cC' + i++;\n\n\tconst context = {\n\t\t_id: contextId,\n\t\t_defaultValue: defaultValue,\n\t\tConsumer(props, contextValue) {\n\t\t\t// return props.children(\n\t\t\t// \tcontext[contextId] ? context[contextId].props.value : defaultValue\n\t\t\t// );\n\t\t\treturn props.children(contextValue);\n\t\t},\n\t\tProvider(props, subs, ctx) {\n\t\t\tif (!this.getChildContext) {\n\t\t\t\tsubs = [];\n\t\t\t\tctx = {};\n\t\t\t\tctx[contextId] = this;\n\n\t\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\t\tthis.shouldComponentUpdate = function(_props) {\n\t\t\t\t\tif (this.props.value !== _props.value) {\n\t\t\t\t\t\t// I think the forced value propagation here was only needed when `options.debounceRendering` was being bypassed:\n\t\t\t\t\t\t// https://github.com/preactjs/preact/commit/4d339fb803bea09e9f198abf38ca1bf8ea4b7771#diff-54682ce380935a717e41b8bfc54737f6R358\n\t\t\t\t\t\t// In those cases though, even with the value corrected, we're double-rendering all nodes.\n\t\t\t\t\t\t// It might be better to just tell folks not to use force-sync mode.\n\t\t\t\t\t\t// Currently, using `useContext()` in a class component will overwrite its `this.context` value.\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context[contextId] = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\t\t\t\t\t\tsubs.some(enqueueRender);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.sub = c => {\n\t\t\t\t\tsubs.push(c);\n\t\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\t\tsubs.splice(subs.indexOf(c), 1);\n\t\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn props.children;\n\t\t}\n\t};\n\n\t// Devtools needs access to the context object when it\n\t// encounters a Provider. This is necessary to support\n\t// setting `displayName` on the context object instead\n\t// of on the component itself. See:\n\t// https://reactjs.org/docs/context.html#contextdisplayname\n\n\treturn (context.Provider._contextRef = context.Consumer.contextType = context);\n}\n","export const EMPTY_OBJ = {};\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n","/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {Node} node The node to remove\n */\nexport function removeNode(node) {\n\tlet parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n","import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { removeNode } from '../util';\nimport { getDomSibling } from '../component';\n\n/**\n * Diff the children of a virtual node\n * @param {import('../internal').PreactElement} parentDom The DOM element whose\n * children are being diffed\n * @param {import('../index').ComponentChildren[]} renderResult\n * @param {import('../internal').VNode} newParentVNode The new virtual\n * node whose children should be diff'ed against oldParentVNode\n * @param {import('../internal').VNode} oldParentVNode The old virtual\n * node whose children should be diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by getChildContext\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {Node | Text} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet i, j, oldVNode, childVNode, newDom, firstChildDom, refs;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet oldChildrenLength = oldChildren.length;\n\n\t// Only in very specific places should this logic be invoked (top level `render` and `diffElementNodes`).\n\t// I'm using `EMPTY_OBJ` to signal when `diffChildren` is invoked in these situations. I can't use `null`\n\t// for this purpose, because `null` is a valid value for `oldDom` which can mean to skip to this logic\n\t// (e.g. if mounting a new tree in which the old DOM should be ignored (usually for Fragments).\n\tif (oldDom == EMPTY_OBJ) {\n\t\tif (excessDomChildren != null) {\n\t\t\toldDom = excessDomChildren[0];\n\t\t} else if (oldChildrenLength) {\n\t\t\toldDom = getDomSibling(oldParentVNode, 0);\n\t\t} else {\n\t\t\toldDom = null;\n\t\t}\n\t}\n\n\tnewParentVNode._children = [];\n\tfor (i = 0; i < renderResult.length; i++) {\n\t\tchildVNode = renderResult[i];\n\n\t\tif (childVNode == null || typeof childVNode == 'boolean') {\n\t\t\tchildVNode = newParentVNode._children[i] = null;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (typeof childVNode == 'string' || typeof childVNode == 'number') {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tnull,\n\t\t\t\tchildVNode,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t} else if (Array.isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (childVNode._dom != null || childVNode._component != null) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tnull,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\t// Terser removes the `continue` here and wraps the loop body\n\t\t// in a `if (childVNode) { ... } condition\n\t\tif (childVNode == null) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\t// Check if we find a corresponding element in oldChildren.\n\t\t// If found, delete the array item by setting to `undefined`.\n\t\t// We use `undefined`, as `null` is reserved for empty placeholders\n\t\t// (holes).\n\t\toldVNode = oldChildren[i];\n\n\t\tif (\n\t\t\toldVNode === null ||\n\t\t\t(oldVNode &&\n\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\tchildVNode.type === oldVNode.type)\n\t\t) {\n\t\t\toldChildren[i] = undefined;\n\t\t} else {\n\t\t\t// Either oldVNode === undefined or oldChildrenLength > 0,\n\t\t\t// so after this loop oldVNode == null or oldVNode is a valid value.\n\t\t\tfor (j = 0; j < oldChildrenLength; j++) {\n\t\t\t\toldVNode = oldChildren[j];\n\t\t\t\t// If childVNode is unkeyed, we only match similarly unkeyed nodes, otherwise we match by key.\n\t\t\t\t// We always match by type (in either case).\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\t\tchildVNode.type === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\toldChildren[j] = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\toldVNode = null;\n\t\t\t}\n\t\t}\n\n\t\toldVNode = oldVNode || EMPTY_OBJ;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tnewDom = diff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tisSvg,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating\n\t\t);\n\n\t\tif ((j = childVNode.ref) && oldVNode.ref != j) {\n\t\t\tif (!refs) refs = [];\n\t\t\tif (oldVNode.ref) refs.push(oldVNode.ref, null, childVNode);\n\t\t\trefs.push(j, childVNode._component || newDom, childVNode);\n\t\t}\n\n\t\tif (newDom != null) {\n\t\t\tif (firstChildDom == null) {\n\t\t\t\tfirstChildDom = newDom;\n\t\t\t}\n\n\t\t\toldDom = placeChild(\n\t\t\t\tparentDom,\n\t\t\t\tchildVNode,\n\t\t\t\toldVNode,\n\t\t\t\toldChildren,\n\t\t\t\texcessDomChildren,\n\t\t\t\tnewDom,\n\t\t\t\toldDom\n\t\t\t);\n\n\t\t\t// Browsers will infer an option's `value` from `textContent` when\n\t\t\t// no value is present. This essentially bypasses our code to set it\n\t\t\t// later in `diff()`. It works fine in all browsers except for IE11\n\t\t\t// where it breaks setting `select.value`. There it will be always set\n\t\t\t// to an empty string. Re-applying an options value will fix that, so\n\t\t\t// there are probably some internal data structures that aren't\n\t\t\t// updated properly.\n\t\t\t//\n\t\t\t// To fix it we make sure to reset the inferred value, so that our own\n\t\t\t// value check in `diff()` won't be skipped.\n\t\t\tif (!isHydrating && newParentVNode.type == 'option') {\n\t\t\t\tparentDom.value = '';\n\t\t\t} else if (typeof newParentVNode.type == 'function') {\n\t\t\t\t// Because the newParentVNode is Fragment-like, we need to set it's\n\t\t\t\t// _nextDom property to the nextSibling of its last child DOM node.\n\t\t\t\t//\n\t\t\t\t// `oldDom` contains the correct value here because if the last child\n\t\t\t\t// is a Fragment-like, then oldDom has already been set to that child's _nextDom.\n\t\t\t\t// If the last child is a DOM VNode, then oldDom will be set to that DOM\n\t\t\t\t// node's nextSibling.\n\t\t\t\tnewParentVNode._nextDom = oldDom;\n\t\t\t}\n\t\t} else if (\n\t\t\toldDom &&\n\t\t\toldVNode._dom == oldDom &&\n\t\t\toldDom.parentNode != parentDom\n\t\t) {\n\t\t\t// The above condition is to handle null placeholders. See test in placeholder.test.js:\n\t\t\t// `efficiently replace null placeholders in parent rerenders`\n\t\t\toldDom = getDomSibling(oldVNode);\n\t\t}\n\t}\n\n\tnewParentVNode._dom = firstChildDom;\n\n\t// Remove children that are not part of any vnode.\n\tif (excessDomChildren != null && typeof newParentVNode.type != 'function') {\n\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\tif (excessDomChildren[i] != null) removeNode(excessDomChildren[i]);\n\t\t}\n\t}\n\n\t// Remove remaining oldChildren if there are any.\n\tfor (i = oldChildrenLength; i--; ) {\n\t\tif (oldChildren[i] != null) unmount(oldChildren[i], oldChildren[i]);\n\t}\n\n\t// Set refs only after unmount\n\tif (refs) {\n\t\tfor (i = 0; i < refs.length; i++) {\n\t\t\tapplyRef(refs[i], refs[++i], refs[++i]);\n\t\t}\n\t}\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {import('../index').ComponentChildren} children The unflattened\n * children of a virtual node\n * @returns {import('../internal').VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (Array.isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\nexport function placeChild(\n\tparentDom,\n\tchildVNode,\n\toldVNode,\n\toldChildren,\n\texcessDomChildren,\n\tnewDom,\n\toldDom\n) {\n\tlet nextDom;\n\tif (childVNode._nextDom !== undefined) {\n\t\t// Only Fragments or components that return Fragment like VNodes will\n\t\t// have a non-undefined _nextDom. Continue the diff from the sibling\n\t\t// of last DOM child of this child VNode\n\t\tnextDom = childVNode._nextDom;\n\n\t\t// Eagerly cleanup _nextDom. We don't need to persist the value because\n\t\t// it is only used by `diffChildren` to determine where to resume the diff after\n\t\t// diffing Components and Fragments. Once we store it the nextDOM local var, we\n\t\t// can clean up the property\n\t\tchildVNode._nextDom = undefined;\n\t} else if (\n\t\texcessDomChildren == oldVNode ||\n\t\tnewDom != oldDom ||\n\t\tnewDom.parentNode == null\n\t) {\n\t\t// NOTE: excessDomChildren==oldVNode above:\n\t\t// This is a compression of excessDomChildren==null && oldVNode==null!\n\t\t// The values only have the same type when `null`.\n\n\t\touter: if (oldDom == null || oldDom.parentNode !== parentDom) {\n\t\t\tparentDom.appendChild(newDom);\n\t\t\tnextDom = null;\n\t\t} else {\n\t\t\t// `j<oldChildrenLength; j+=2` is an alternative to `j++<oldChildrenLength/2`\n\t\t\tfor (\n\t\t\t\tlet sibDom = oldDom, j = 0;\n\t\t\t\t(sibDom = sibDom.nextSibling) && j < oldChildren.length;\n\t\t\t\tj += 2\n\t\t\t) {\n\t\t\t\tif (sibDom == newDom) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparentDom.insertBefore(newDom, oldDom);\n\t\t\tnextDom = oldDom;\n\t\t}\n\t}\n\n\t// If we have pre-calculated the nextDOM node, use it. Else calculate it now\n\t// Strictly check for `undefined` here cuz `null` is a valid value of `nextDom`.\n\t// See more detail in create-element.js:createVNode\n\tif (nextDom !== undefined) {\n\t\toldDom = nextDom;\n\t} else {\n\t\toldDom = newDom.nextSibling;\n\t}\n\n\treturn oldDom;\n}\n","import { IS_NON_DIMENSIONAL } from '../constants';\nimport options from '../options';\n\n/**\n * Diff the old and new properties of a VNode and apply changes to the DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to apply\n * changes to\n * @param {object} newProps The new props\n * @param {object} oldProps The old props\n * @param {boolean} isSvg Whether or not this node is an SVG node\n * @param {boolean} hydrate Whether or not we are in hydration mode\n */\nexport function diffProps(dom, newProps, oldProps, isSvg, hydrate) {\n\tlet i;\n\n\tfor (i in oldProps) {\n\t\tif (i !== 'children' && i !== 'key' && !(i in newProps)) {\n\t\t\tsetProperty(dom, i, null, oldProps[i], isSvg);\n\t\t}\n\t}\n\n\tfor (i in newProps) {\n\t\tif (\n\t\t\t(!hydrate || typeof newProps[i] == 'function') &&\n\t\t\ti !== 'children' &&\n\t\t\ti !== 'key' &&\n\t\t\ti !== 'value' &&\n\t\t\ti !== 'checked' &&\n\t\t\toldProps[i] !== newProps[i]\n\t\t) {\n\t\t\tsetProperty(dom, i, newProps[i], oldProps[i], isSvg);\n\t\t}\n\t}\n}\n\nfunction setStyle(style, key, value) {\n\t// if (!(key in style)) {  // -3b\n\t// if (key < '.') {  // -1b\n\tif (key[0] === '-') {\n\t\tstyle.setProperty(key, value);\n\t} else if (value == null) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, isSvg) {\n\tlet useCapture, nameLower;\n\n\tif (isSvg && name == 'className') name = 'class';\n\n\t// if (isSvg) {\n\t// \tif (name === 'className') name = 'class';\n\t// } else if (name === 'class') name += 'Name';\n\n\tif (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture = name !== (name = name.replace(/Capture$/, ''));\n\t\tnameLower = name.toLowerCase();\n\t\tif (nameLower in dom) name = nameLower;\n\t\tname = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) dom.addEventListener(name, eventProxy, useCapture);\n\t\t} else {\n\t\t\tdom.removeEventListener(name, eventProxy, useCapture);\n\t\t}\n\t} else if (\n\t\tname !== 'list' &&\n\t\tname !== 'tagName' &&\n\t\t// HTMLButtonElement.form and HTMLInputElement.form are read-only but can be set using\n\t\t// setAttribute\n\t\tname !== 'form' &&\n\t\tname !== 'type' &&\n\t\tname !== 'size' &&\n\t\tname !== 'download' &&\n\t\tname !== 'href' &&\n\t\t!isSvg &&\n\t\tname in dom\n\t) {\n\t\tdom[name] = value == null ? '' : value;\n\t} else if (typeof value != 'function' && name !== 'dangerouslySetInnerHTML') {\n\t\tif (name !== (name = name.replace(/xlink:?/, ''))) {\n\t\t\tif (value == null || value === false) {\n\t\t\t\tdom.removeAttributeNS(\n\t\t\t\t\t'http://www.w3.org/1999/xlink',\n\t\t\t\t\tname.toLowerCase()\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tdom.setAttributeNS(\n\t\t\t\t\t'http://www.w3.org/1999/xlink',\n\t\t\t\t\tname.toLowerCase(),\n\t\t\t\t\tvalue\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (\n\t\t\tvalue == null ||\n\t\t\t(value === false &&\n\t\t\t\t// ARIA-attributes have a different notion of boolean values.\n\t\t\t\t// The value `false` is different from the attribute not\n\t\t\t\t// existing on the DOM, so we can't remove it. For non-boolean\n\t\t\t\t// ARIA-attributes we could treat false as a removal, but the\n\t\t\t\t// amount of exceptions would cost us too many bytes. On top of\n\t\t\t\t// that other VDOM frameworks also always stringify `false`.\n\t\t\t\t!/^ar/.test(name))\n\t\t) {\n\t\t\tdom.removeAttribute(name);\n\t\t} else {\n\t\t\tdom.setAttribute(name, value);\n\t\t}\n\t}\n}\n\n/**\n * Proxy an event to hooked event handlers\n * @param {Event} e The event object from the browser\n * @private\n */\nfunction eventProxy(e) {\n\tthis._listeners[e.type](options.event ? options.event(e) : e);\n}\n","import { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { Component } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren, placeChild } from './children';\nimport { diffProps, setProperty } from './props';\nimport { assign, removeNode } from '../util';\nimport options from '../options';\n\nfunction reorderChildren(newVNode, oldDom, parentDom) {\n\tfor (let tmp = 0; tmp < newVNode._children.length; tmp++) {\n\t\tconst vnode = newVNode._children[tmp];\n\t\tif (vnode) {\n\t\t\tvnode._parent = newVNode;\n\n\t\t\tif (vnode._dom) {\n\t\t\t\tif (typeof vnode.type == 'function' && vnode._children.length > 1) {\n\t\t\t\t\treorderChildren(vnode, oldDom, parentDom);\n\t\t\t\t}\n\n\t\t\t\toldDom = placeChild(\n\t\t\t\t\tparentDom,\n\t\t\t\t\tvnode,\n\t\t\t\t\tvnode,\n\t\t\t\t\tnewVNode._children,\n\t\t\t\t\tnull,\n\t\t\t\t\tvnode._dom,\n\t\t\t\t\toldDom\n\t\t\t\t);\n\n\t\t\t\tif (typeof newVNode.type == 'function') {\n\t\t\t\t\tnewVNode._nextDom = oldDom;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').PreactElement} parentDom The parent of the DOM element\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by getChildContext\n * @param {boolean} isSvg Whether or not this element is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {Element | Text} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} [isHydrating] Whether or not we are in hydration\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== undefined) return null;\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\ttry {\n\t\touter: if (typeof newType == 'function') {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif ('prototype' in newType && newType.prototype.render) {\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\tnewVNode._component = c = new Component(newProps, componentContext);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (c._nextState == null) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\t\t\tif (newType.getDerivedStateFromProps != null) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tc.componentWillMount != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidMount != null) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(!c._force &&\n\t\t\t\t\t\tc.shouldComponentUpdate != null &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\tnewVNode._original === oldVNode._original\n\t\t\t\t) {\n\t\t\t\t\tc.props = newProps;\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original !== oldVNode._original) c._dirty = false;\n\t\t\t\t\tc._vnode = newVNode;\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\treorderChildren(newVNode, oldDom, parentDom);\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != null) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidUpdate != null) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc.state = c._nextState;\n\n\t\t\tif ((tmp = options._render)) tmp(newVNode);\n\n\t\t\tc._dirty = false;\n\t\t\tc._vnode = newVNode;\n\t\t\tc._parentDom = parentDom;\n\n\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != null) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (!isNew && c.getSnapshotBeforeUpdate != null) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != null && tmp.type == Fragment && tmp.key == null;\n\t\t\tlet renderResult = isTopLevelFragment ? tmp.props.children : tmp;\n\n\t\t\tdiffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tArray.isArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = null;\n\t\t\t}\n\n\t\t\tc._force = false;\n\t\t} else if (\n\t\t\texcessDomChildren == null &&\n\t\t\tnewVNode._original === oldVNode._original\n\t\t) {\n\t\t\tnewVNode._children = oldVNode._children;\n\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t} else {\n\t\t\tnewVNode._dom = diffElementNodes(\n\t\t\t\toldVNode._dom,\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\tif ((tmp = options.diffed)) tmp(newVNode);\n\t} catch (e) {\n\t\tnewVNode._original = null;\n\t\toptions._catchError(e, newVNode, oldVNode);\n\t}\n\n\treturn newVNode._dom;\n}\n\n/**\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').VNode} root\n */\nexport function commitRoot(commitQueue, root) {\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {import('../internal').PreactElement} dom The DOM element representing\n * the virtual nodes being diffed\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {*} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @returns {import('../internal').PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating\n) {\n\tlet i;\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\n\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\tisSvg = newVNode.type === 'svg' || isSvg;\n\n\tif (excessDomChildren != null) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tconst child = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tchild != null &&\n\t\t\t\t((newVNode.type === null\n\t\t\t\t\t? child.nodeType === 3\n\t\t\t\t\t: child.localName === newVNode.type) ||\n\t\t\t\t\tdom == child)\n\t\t\t) {\n\t\t\t\tdom = child;\n\t\t\t\texcessDomChildren[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == null) {\n\t\tif (newVNode.type === null) {\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tdom = isSvg\n\t\t\t? document.createElementNS('http://www.w3.org/2000/svg', newVNode.type)\n\t\t\t: document.createElement(\n\t\t\t\t\tnewVNode.type,\n\t\t\t\t\tnewProps.is && { is: newProps.is }\n\t\t\t  );\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = null;\n\t\t// we are creating a new node, so we can assume this is a new subtree (in case we are hydrating), this deopts the hydrate\n\t\tisHydrating = false;\n\t}\n\n\tif (newVNode.type === null) {\n\t\tif (oldProps !== newProps && dom.data !== newProps) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\tif (excessDomChildren != null) {\n\t\t\texcessDomChildren = EMPTY_ARR.slice.call(dom.childNodes);\n\t\t}\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\tlet oldHtml = oldProps.dangerouslySetInnerHTML;\n\t\tlet newHtml = newProps.dangerouslySetInnerHTML;\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tif (!isHydrating) {\n\t\t\t// But, if we are in a situation where we are using existing DOM (e.g. replaceNode)\n\t\t\t// we should read the existing DOM attributes to diff them\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\toldProps = {};\n\t\t\t\tfor (let i = 0; i < dom.attributes.length; i++) {\n\t\t\t\t\toldProps[dom.attributes[i].name] = dom.attributes[i].value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (newHtml || oldHtml) {\n\t\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\t\tif (!newHtml || !oldHtml || newHtml.__html != oldHtml.__html) {\n\t\t\t\t\tdom.innerHTML = (newHtml && newHtml.__html) || '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdiffProps(dom, newProps, oldProps, isSvg, isHydrating);\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\ti = newVNode.props.children;\n\t\t\tdiffChildren(\n\t\t\t\tdom,\n\t\t\t\tArray.isArray(i) ? i : [i],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnewVNode.type === 'foreignObject' ? false : isSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tEMPTY_OBJ,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\t// (as above, don't diff props during hydration)\n\t\tif (!isHydrating) {\n\t\t\tif (\n\t\t\t\t'value' in newProps &&\n\t\t\t\t(i = newProps.value) !== undefined &&\n\t\t\t\ti !== dom.value\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'value', i, oldProps.value, false);\n\t\t\t}\n\t\t\tif (\n\t\t\t\t'checked' in newProps &&\n\t\t\t\t(i = newProps.checked) !== undefined &&\n\t\t\t\ti !== dom.checked\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'checked', i, oldProps.checked, false);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {object|function} ref\n * @param {any} value\n * @param {import('../internal').VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') ref(value);\n\t\telse ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {import('../internal').VNode} vnode The virtual node to unmount\n * @param {import('../internal').VNode} parentVNode The parent of the VNode that\n * initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current === vnode._dom) applyRef(r, null, parentVNode);\n\t}\n\n\tlet dom;\n\tif (!skipRemove && typeof vnode.type != 'function') {\n\t\tskipRemove = (dom = vnode._dom) != null;\n\t}\n\n\t// Must be set to `undefined` to properly clean up `_nextDom`\n\t// for which `null` is a valid value. See comment in `create-element.js`\n\tvnode._dom = vnode._nextDom = undefined;\n\n\tif ((r = vnode._component) != null) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = null;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) unmount(r[i], parentVNode, skipRemove);\n\t\t}\n\t}\n\n\tif (dom != null) removeNode(dom);\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n","import { enqueueRender } from '../component';\n\n/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').VNode} vnode The vnode that threw\n * the error that was caught (except for unmounting when this parameter\n * is the highest parent that was being unmounted)\n */\nexport function _catchError(error, vnode) {\n\t/** @type {import('../internal').Component} */\n\tlet component, hasCaught;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tif (\n\t\t\t\t\tcomponent.constructor &&\n\t\t\t\t\tcomponent.constructor.getDerivedStateFromError != null\n\t\t\t\t) {\n\t\t\t\t\thasCaught = true;\n\t\t\t\t\tcomponent.setState(\n\t\t\t\t\t\tcomponent.constructor.getDerivedStateFromError(error)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != null) {\n\t\t\t\t\thasCaught = true;\n\t\t\t\t\tcomponent.componentDidCatch(error);\n\t\t\t\t}\n\n\t\t\t\tif (hasCaught)\n\t\t\t\t\treturn enqueueRender((component._pendingError = component));\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n","import { assign } from './util';\nimport { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./index').ComponentChildren>} rest Any additional arguments will be used as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\tif (children != null) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tnull\n\t);\n}\n"],"names":["options","isValidElement","rerenderQueue","defer","prevDebounce","IS_HYDRATE","i","EMPTY_OBJ","EMPTY_ARR","IS_NON_DIMENSIONAL","assign","obj","props","removeNode","node","parentNode","removeChild","createElement","type","children","key","ref","normalizedProps","arguments","length","push","defaultProps","undefined","createVNode","original","vnode","constructor","Fragment","Component","context","getDomSibling","childIndex","indexOf","sibling","updateParentDomPointers","child","base","enqueueRender","c","process","debounceRendering","queue","sort","a","b","some","component","commitQueue","oldVNode","newDom","oldDom","parentDom","diff","ownerSVGElement","commitRoot","diffChildren","renderResult","newParentVNode","oldParentVNode","globalContext","isSvg","excessDomChildren","isHydrating","j","childVNode","firstChildDom","refs","oldChildren","oldChildrenLength","Array","isArray","placeChild","value","unmount","applyRef","nextDom","sibDom","outer","appendChild","nextSibling","insertBefore","diffProps","dom","newProps","oldProps","hydrate","setProperty","setStyle","style","test","name","oldValue","useCapture","nameLower","replace","toLowerCase","slice","_listeners","addEventListener","eventProxy","removeEventListener","removeAttributeNS","setAttributeNS","removeAttribute","setAttribute","e","event","reorderChildren","newVNode","tmp","isNew","oldState","snapshot","clearProcessingException","provider","componentContext","newType","contextType","prototype","render","doRender","sub","state","getDerivedStateFromProps","componentWillMount","componentDidMount","componentWillReceiveProps","shouldComponentUpdate","componentWillUpdate","componentDidUpdate","getChildContext","getSnapshotBeforeUpdate","diffElementNodes","diffed","root","cb","call","oldHtml","newHtml","nodeType","localName","document","createTextNode","createElementNS","is","data","childNodes","dangerouslySetInnerHTML","attributes","innerHTML","checked","current","parentVNode","skipRemove","r","componentWillUnmount","this","replaceNode","error","hasCaught","getDerivedStateFromError","setState","componentDidCatch","update","callback","s","forceUpdate","Promise","then","bind","resolve","setTimeout","defaultValue","contextId","Consumer","contextValue","Provider","subs","ctx","_props","old","splice","toChildArray","out"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"preact.umd.js","sources":["../src/options.js","../src/create-element.js","../src/component.js","../src/render.js","../src/create-context.js","../src/constants.js","../src/util.js","../src/diff/children.js","../src/diff/props.js","../src/diff/index.js","../src/diff/catch-error.js","../src/clone-element.js"],"sourcesContent":["import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n","import options from './options';\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * constructor for this virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\t// https://github.com/preactjs/preact/issues/1916\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\tif (children != null) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != null) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === undefined) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, null);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: null,\n\t\t_depth: 0,\n\t\t_dom: null,\n\t\t// _nextDom must be initialized to undefined b/c it will eventually\n\t\t// be set to dom.nextSibling which can return `null` and it is important\n\t\t// to be able to distinguish between an uninitialized _nextDom and\n\t\t// a _nextDom that has been set to `null`\n\t\t_nextDom: undefined,\n\t\t_component: null,\n\t\tconstructor: undefined,\n\t\t_original: original\n\t};\n\n\tif (original == null) vnode._original = vnode;\n\tif (options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is import('./internal').VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor === undefined;\n","import { assign } from './util';\nimport { diff, commitRoot } from './diff/index';\nimport options from './options';\nimport { Fragment } from './create-element';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function Component(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nComponent.prototype.setState = function(update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tassign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._vnode) {\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nComponent.prototype.forceUpdate = function(callback) {\n\tif (this._vnode) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._force = true;\n\t\tif (callback) this._renderCallbacks.push(callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {import('./index').ComponentChildren | void}\n */\nComponent.prototype.render = Fragment;\n\n/**\n * @param {import('./internal').VNode} vnode\n * @param {number | null} [childIndex]\n */\nexport function getDomSibling(vnode, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn vnode._parent\n\t\t\t? getDomSibling(vnode._parent, vnode._parent._children.indexOf(vnode) + 1)\n\t\t\t: null;\n\t}\n\n\tlet sibling;\n\tfor (; childIndex < vnode._children.length; childIndex++) {\n\t\tsibling = vnode._children[childIndex];\n\n\t\tif (sibling != null && sibling._dom != null) {\n\t\t\t// Since updateParentDomPointers keeps _dom pointer correct,\n\t\t\t// we can rely on _dom to tell us if this subtree contains a\n\t\t\t// rendered DOM node, and what the first rendered DOM node is\n\t\t\treturn sibling._dom;\n\t\t}\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children.\n\t// We must resume from this vnode's sibling (in it's parent _children array)\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search)\n\treturn typeof vnode.type == 'function' ? getDomSibling(vnode) : null;\n}\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {import('./internal').Component} component The component to rerender\n */\nfunction renderComponent(component) {\n\tlet vnode = component._vnode,\n\t\toldDom = vnode._dom,\n\t\tparentDom = component._parentDom;\n\n\tif (parentDom) {\n\t\tlet commitQueue = [];\n\t\tconst oldVNode = assign({}, vnode);\n\t\toldVNode._original = oldVNode;\n\n\t\tlet newDom = diff(\n\t\t\tparentDom,\n\t\t\tvnode,\n\t\t\toldVNode,\n\t\t\tcomponent._globalContext,\n\t\t\tparentDom.ownerSVGElement !== undefined,\n\t\t\tnull,\n\t\t\tcommitQueue,\n\t\t\toldDom == null ? getDomSibling(vnode) : oldDom\n\t\t);\n\t\tcommitRoot(commitQueue, vnode);\n\n\t\tif (newDom != oldDom) {\n\t\t\tupdateParentDomPointers(vnode);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./internal').VNode} vnode\n */\nfunction updateParentDomPointers(vnode) {\n\tif ((vnode = vnode._parent) != null && vnode._component != null) {\n\t\tvnode._dom = vnode._component.base = null;\n\t\tfor (let i = 0; i < vnode._children.length; i++) {\n\t\t\tlet child = vnode._children[i];\n\t\t\tif (child != null && child._dom != null) {\n\t\t\t\tvnode._dom = vnode._component.base = child._dom;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn updateParentDomPointers(vnode);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Component>}\n */\nlet rerenderQueue = [];\n\n/**\n * Asynchronously schedule a callback\n * @type {(cb: () => void) => void}\n */\n/* istanbul ignore next */\n// Note the following line isn't tree-shaken by rollup cuz of rollup/rollup#2566\nconst defer =\n\ttypeof Promise == 'function'\n\t\t? Promise.prototype.then.bind(Promise.resolve())\n\t\t: setTimeout;\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\n/**\n * Enqueue a rerender of a component\n * @param {import('./internal').Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!c._dirty &&\n\t\t\t(c._dirty = true) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\tlet queue;\n\twhile ((process._rerenderCount = rerenderQueue.length)) {\n\t\tqueue = rerenderQueue.sort((a, b) => a._vnode._depth - b._vnode._depth);\n\t\trerenderQueue = [];\n\t\t// Don't update `renderCount` yet. Keep its value non-zero to prevent unnecessary\n\t\t// process() calls from getting scheduled while `queue` is still being consumed.\n\t\tqueue.some(c => {\n\t\t\tif (c._dirty) renderComponent(c);\n\t\t});\n\t}\n}\nprocess._rerenderCount = 0;\n","import { EMPTY_OBJ, EMPTY_ARR } from './constants';\nimport { commitRoot, diff } from './diff/index';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\n\nconst IS_HYDRATE = EMPTY_OBJ;\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./index').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * render into\n * @param {Element | Text} [replaceNode] Optional: Attempt to re-use an\n * existing DOM tree rooted at `replaceNode`\n */\nexport function render(vnode, parentDom, replaceNode) {\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// We abuse the `replaceNode` parameter in `hydrate()` to signal if we\n\t// are in hydration mode or not by passing `IS_HYDRATE` instead of a\n\t// DOM element.\n\tlet isHydrating = replaceNode === IS_HYDRATE;\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet oldVNode = isHydrating\n\t\t? null\n\t\t: (replaceNode && replaceNode._children) || parentDom._children;\n\tvnode = createElement(Fragment, null, [vnode]);\n\n\t// List of effects that need to be called after diffing.\n\tlet commitQueue = [];\n\tdiff(\n\t\tparentDom,\n\t\t// Determine the new vnode tree and store it on the DOM element on\n\t\t// our custom `_children` property.\n\t\t((isHydrating ? parentDom : replaceNode || parentDom)._children = vnode),\n\t\toldVNode || EMPTY_OBJ,\n\t\tEMPTY_OBJ,\n\t\tparentDom.ownerSVGElement !== undefined,\n\t\treplaceNode && !isHydrating\n\t\t\t? [replaceNode]\n\t\t\t: oldVNode\n\t\t\t? null\n\t\t\t: parentDom.childNodes.length\n\t\t\t? EMPTY_ARR.slice.call(parentDom.childNodes)\n\t\t\t: null,\n\t\tcommitQueue,\n\t\treplaceNode || EMPTY_OBJ,\n\t\tisHydrating\n\t);\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, vnode);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./index').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * update\n */\nexport function hydrate(vnode, parentDom) {\n\trender(vnode, parentDom, IS_HYDRATE);\n}\n","import { enqueueRender } from './component';\n\nexport let i = 0;\n\nexport function createContext(defaultValue, contextId) {\n\tcontextId = '__cC' + i++;\n\n\tconst context = {\n\t\t_id: contextId,\n\t\t_defaultValue: defaultValue,\n\t\tConsumer(props, contextValue) {\n\t\t\t// return props.children(\n\t\t\t// \tcontext[contextId] ? context[contextId].props.value : defaultValue\n\t\t\t// );\n\t\t\treturn props.children(contextValue);\n\t\t},\n\t\tProvider(props, subs, ctx) {\n\t\t\tif (!this.getChildContext) {\n\t\t\t\tsubs = [];\n\t\t\t\tctx = {};\n\t\t\t\tctx[contextId] = this;\n\n\t\t\t\tthis.getChildContext = () => ctx;\n\n\t\t\t\tthis.shouldComponentUpdate = function(_props) {\n\t\t\t\t\tif (this.props.value !== _props.value) {\n\t\t\t\t\t\t// I think the forced value propagation here was only needed when `options.debounceRendering` was being bypassed:\n\t\t\t\t\t\t// https://github.com/preactjs/preact/commit/4d339fb803bea09e9f198abf38ca1bf8ea4b7771#diff-54682ce380935a717e41b8bfc54737f6R358\n\t\t\t\t\t\t// In those cases though, even with the value corrected, we're double-rendering all nodes.\n\t\t\t\t\t\t// It might be better to just tell folks not to use force-sync mode.\n\t\t\t\t\t\t// Currently, using `useContext()` in a class component will overwrite its `this.context` value.\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\n\t\t\t\t\t\t// subs.some(c => {\n\t\t\t\t\t\t// \tc.context[contextId] = _props.value;\n\t\t\t\t\t\t// \tenqueueRender(c);\n\t\t\t\t\t\t// });\n\t\t\t\t\t\tsubs.some(enqueueRender);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tthis.sub = c => {\n\t\t\t\t\tsubs.push(c);\n\t\t\t\t\tlet old = c.componentWillUnmount;\n\t\t\t\t\tc.componentWillUnmount = () => {\n\t\t\t\t\t\tsubs.splice(subs.indexOf(c), 1);\n\t\t\t\t\t\tif (old) old.call(c);\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn props.children;\n\t\t}\n\t};\n\n\t// Devtools needs access to the context object when it\n\t// encounters a Provider. This is necessary to support\n\t// setting `displayName` on the context object instead\n\t// of on the component itself. See:\n\t// https://reactjs.org/docs/context.html#contextdisplayname\n\n\treturn (context.Provider._contextRef = context.Consumer.contextType = context);\n}\n","export const EMPTY_OBJ = {};\nexport const EMPTY_ARR = [];\nexport const IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;\n","/**\n * Assign properties from `props` to `obj`\n * @template O, P The obj and props types\n * @param {O} obj The object to copy properties to\n * @param {P} props The object to copy properties from\n * @returns {O & P}\n */\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn /** @type {O & P} */ (obj);\n}\n\n/**\n * Remove a child node from its parent if attached. This is a workaround for\n * IE11 which doesn't support `Element.prototype.remove()`. Using this function\n * is smaller than including a dedicated polyfill.\n * @param {Node} node The node to remove\n */\nexport function removeNode(node) {\n\tlet parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n","import { diff, unmount, applyRef } from './index';\nimport { createVNode, Fragment } from '../create-element';\nimport { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { removeNode } from '../util';\nimport { getDomSibling } from '../component';\n\n/**\n * Diff the children of a virtual node\n * @param {import('../internal').PreactElement} parentDom The DOM element whose\n * children are being diffed\n * @param {import('../index').ComponentChildren[]} renderResult\n * @param {import('../internal').VNode} newParentVNode The new virtual\n * node whose children should be diff'ed against oldParentVNode\n * @param {import('../internal').VNode} oldParentVNode The old virtual\n * node whose children should be diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by getChildContext\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {Node | Text} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} isHydrating Whether or not we are in hydration\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tnewParentVNode,\n\toldParentVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet i, j, oldVNode, childVNode, newDom, firstChildDom, refs;\n\n\t// This is a compression of oldParentVNode!=null && oldParentVNode != EMPTY_OBJ && oldParentVNode._children || EMPTY_ARR\n\t// as EMPTY_OBJ._children should be `undefined`.\n\tlet oldChildren = (oldParentVNode && oldParentVNode._children) || EMPTY_ARR;\n\n\tlet oldChildrenLength = oldChildren.length;\n\n\t// Only in very specific places should this logic be invoked (top level `render` and `diffElementNodes`).\n\t// I'm using `EMPTY_OBJ` to signal when `diffChildren` is invoked in these situations. I can't use `null`\n\t// for this purpose, because `null` is a valid value for `oldDom` which can mean to skip to this logic\n\t// (e.g. if mounting a new tree in which the old DOM should be ignored (usually for Fragments).\n\tif (oldDom == EMPTY_OBJ) {\n\t\tif (excessDomChildren != null) {\n\t\t\toldDom = excessDomChildren[0];\n\t\t} else if (oldChildrenLength) {\n\t\t\toldDom = getDomSibling(oldParentVNode, 0);\n\t\t} else {\n\t\t\toldDom = null;\n\t\t}\n\t}\n\n\tnewParentVNode._children = [];\n\tfor (i = 0; i < renderResult.length; i++) {\n\t\tchildVNode = renderResult[i];\n\n\t\tif (childVNode == null || typeof childVNode == 'boolean') {\n\t\t\tchildVNode = newParentVNode._children[i] = null;\n\t\t}\n\t\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t\t// it's own DOM & etc. pointers\n\t\telse if (typeof childVNode == 'string' || typeof childVNode == 'number') {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tnull,\n\t\t\t\tchildVNode,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tchildVNode\n\t\t\t);\n\t\t} else if (Array.isArray(childVNode)) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tFragment,\n\t\t\t\t{ children: childVNode },\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull\n\t\t\t);\n\t\t} else if (childVNode._dom != null || childVNode._component != null) {\n\t\t\tchildVNode = newParentVNode._children[i] = createVNode(\n\t\t\t\tchildVNode.type,\n\t\t\t\tchildVNode.props,\n\t\t\t\tchildVNode.key,\n\t\t\t\tnull,\n\t\t\t\tchildVNode._original\n\t\t\t);\n\t\t} else {\n\t\t\tchildVNode = newParentVNode._children[i] = childVNode;\n\t\t}\n\n\t\t// Terser removes the `continue` here and wraps the loop body\n\t\t// in a `if (childVNode) { ... } condition\n\t\tif (childVNode == null) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildVNode._parent = newParentVNode;\n\t\tchildVNode._depth = newParentVNode._depth + 1;\n\n\t\t// Check if we find a corresponding element in oldChildren.\n\t\t// If found, delete the array item by setting to `undefined`.\n\t\t// We use `undefined`, as `null` is reserved for empty placeholders\n\t\t// (holes).\n\t\toldVNode = oldChildren[i];\n\n\t\tif (\n\t\t\toldVNode === null ||\n\t\t\t(oldVNode &&\n\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\tchildVNode.type === oldVNode.type)\n\t\t) {\n\t\t\toldChildren[i] = undefined;\n\t\t} else {\n\t\t\t// Either oldVNode === undefined or oldChildrenLength > 0,\n\t\t\t// so after this loop oldVNode == null or oldVNode is a valid value.\n\t\t\tfor (j = 0; j < oldChildrenLength; j++) {\n\t\t\t\toldVNode = oldChildren[j];\n\t\t\t\t// If childVNode is unkeyed, we only match similarly unkeyed nodes, otherwise we match by key.\n\t\t\t\t// We always match by type (in either case).\n\t\t\t\tif (\n\t\t\t\t\toldVNode &&\n\t\t\t\t\tchildVNode.key == oldVNode.key &&\n\t\t\t\t\tchildVNode.type === oldVNode.type\n\t\t\t\t) {\n\t\t\t\t\toldChildren[j] = undefined;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\toldVNode = null;\n\t\t\t}\n\t\t}\n\n\t\toldVNode = oldVNode || EMPTY_OBJ;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tnewDom = diff(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\toldVNode,\n\t\t\tglobalContext,\n\t\t\tisSvg,\n\t\t\texcessDomChildren,\n\t\t\tcommitQueue,\n\t\t\toldDom,\n\t\t\tisHydrating\n\t\t);\n\n\t\tif ((j = childVNode.ref) && oldVNode.ref != j) {\n\t\t\tif (!refs) refs = [];\n\t\t\tif (oldVNode.ref) refs.push(oldVNode.ref, null, childVNode);\n\t\t\trefs.push(j, childVNode._component || newDom, childVNode);\n\t\t}\n\n\t\tif (newDom != null) {\n\t\t\tif (firstChildDom == null) {\n\t\t\t\tfirstChildDom = newDom;\n\t\t\t}\n\n\t\t\toldDom = placeChild(\n\t\t\t\tparentDom,\n\t\t\t\tchildVNode,\n\t\t\t\toldVNode,\n\t\t\t\toldChildren,\n\t\t\t\texcessDomChildren,\n\t\t\t\tnewDom,\n\t\t\t\toldDom\n\t\t\t);\n\n\t\t\t// Browsers will infer an option's `value` from `textContent` when\n\t\t\t// no value is present. This essentially bypasses our code to set it\n\t\t\t// later in `diff()`. It works fine in all browsers except for IE11\n\t\t\t// where it breaks setting `select.value`. There it will be always set\n\t\t\t// to an empty string. Re-applying an options value will fix that, so\n\t\t\t// there are probably some internal data structures that aren't\n\t\t\t// updated properly.\n\t\t\t//\n\t\t\t// To fix it we make sure to reset the inferred value, so that our own\n\t\t\t// value check in `diff()` won't be skipped.\n\t\t\tif (!isHydrating && newParentVNode.type == 'option') {\n\t\t\t\tparentDom.value = '';\n\t\t\t} else if (typeof newParentVNode.type == 'function') {\n\t\t\t\t// Because the newParentVNode is Fragment-like, we need to set it's\n\t\t\t\t// _nextDom property to the nextSibling of its last child DOM node.\n\t\t\t\t//\n\t\t\t\t// `oldDom` contains the correct value here because if the last child\n\t\t\t\t// is a Fragment-like, then oldDom has already been set to that child's _nextDom.\n\t\t\t\t// If the last child is a DOM VNode, then oldDom will be set to that DOM\n\t\t\t\t// node's nextSibling.\n\t\t\t\tnewParentVNode._nextDom = oldDom;\n\t\t\t}\n\t\t} else if (\n\t\t\toldDom &&\n\t\t\toldVNode._dom == oldDom &&\n\t\t\toldDom.parentNode != parentDom\n\t\t) {\n\t\t\t// The above condition is to handle null placeholders. See test in placeholder.test.js:\n\t\t\t// `efficiently replace null placeholders in parent rerenders`\n\t\t\toldDom = getDomSibling(oldVNode);\n\t\t}\n\t}\n\n\tnewParentVNode._dom = firstChildDom;\n\n\t// Remove children that are not part of any vnode.\n\tif (excessDomChildren != null && typeof newParentVNode.type != 'function') {\n\t\tfor (i = excessDomChildren.length; i--; ) {\n\t\t\tif (excessDomChildren[i] != null) removeNode(excessDomChildren[i]);\n\t\t}\n\t}\n\n\t// Remove remaining oldChildren if there are any.\n\tfor (i = oldChildrenLength; i--; ) {\n\t\tif (oldChildren[i] != null) unmount(oldChildren[i], oldChildren[i]);\n\t}\n\n\t// Set refs only after unmount\n\tif (refs) {\n\t\tfor (i = 0; i < refs.length; i++) {\n\t\t\tapplyRef(refs[i], refs[++i], refs[++i]);\n\t\t}\n\t}\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {import('../index').ComponentChildren} children The unflattened\n * children of a virtual node\n * @returns {import('../internal').VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (Array.isArray(children)) {\n\t\tchildren.some(child => {\n\t\t\ttoChildArray(child, out);\n\t\t});\n\t} else {\n\t\tout.push(children);\n\t}\n\treturn out;\n}\n\nexport function placeChild(\n\tparentDom,\n\tchildVNode,\n\toldVNode,\n\toldChildren,\n\texcessDomChildren,\n\tnewDom,\n\toldDom\n) {\n\tlet nextDom;\n\tif (childVNode._nextDom !== undefined) {\n\t\t// Only Fragments or components that return Fragment like VNodes will\n\t\t// have a non-undefined _nextDom. Continue the diff from the sibling\n\t\t// of last DOM child of this child VNode\n\t\tnextDom = childVNode._nextDom;\n\n\t\t// Eagerly cleanup _nextDom. We don't need to persist the value because\n\t\t// it is only used by `diffChildren` to determine where to resume the diff after\n\t\t// diffing Components and Fragments. Once we store it the nextDOM local var, we\n\t\t// can clean up the property\n\t\tchildVNode._nextDom = undefined;\n\t} else if (\n\t\texcessDomChildren == oldVNode ||\n\t\tnewDom != oldDom ||\n\t\tnewDom.parentNode == null\n\t) {\n\t\t// NOTE: excessDomChildren==oldVNode above:\n\t\t// This is a compression of excessDomChildren==null && oldVNode==null!\n\t\t// The values only have the same type when `null`.\n\n\t\touter: if (oldDom == null || oldDom.parentNode !== parentDom) {\n\t\t\tparentDom.appendChild(newDom);\n\t\t\tnextDom = null;\n\t\t} else {\n\t\t\t// `j<oldChildrenLength; j+=2` is an alternative to `j++<oldChildrenLength/2`\n\t\t\tfor (\n\t\t\t\tlet sibDom = oldDom, j = 0;\n\t\t\t\t(sibDom = sibDom.nextSibling) && j < oldChildren.length;\n\t\t\t\tj += 2\n\t\t\t) {\n\t\t\t\tif (sibDom == newDom) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparentDom.insertBefore(newDom, oldDom);\n\t\t\tnextDom = oldDom;\n\t\t}\n\t}\n\n\t// If we have pre-calculated the nextDOM node, use it. Else calculate it now\n\t// Strictly check for `undefined` here cuz `null` is a valid value of `nextDom`.\n\t// See more detail in create-element.js:createVNode\n\tif (nextDom !== undefined) {\n\t\toldDom = nextDom;\n\t} else {\n\t\toldDom = newDom.nextSibling;\n\t}\n\n\treturn oldDom;\n}\n","import { IS_NON_DIMENSIONAL } from '../constants';\nimport options from '../options';\n\n/**\n * Diff the old and new properties of a VNode and apply changes to the DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to apply\n * changes to\n * @param {object} newProps The new props\n * @param {object} oldProps The old props\n * @param {boolean} isSvg Whether or not this node is an SVG node\n * @param {boolean} hydrate Whether or not we are in hydration mode\n */\nexport function diffProps(dom, newProps, oldProps, isSvg, hydrate) {\n\tlet i;\n\n\tfor (i in oldProps) {\n\t\tif (i !== 'children' && i !== 'key' && !(i in newProps)) {\n\t\t\tsetProperty(dom, i, null, oldProps[i], isSvg);\n\t\t}\n\t}\n\n\tfor (i in newProps) {\n\t\tif (\n\t\t\t(!hydrate || typeof newProps[i] == 'function') &&\n\t\t\ti !== 'children' &&\n\t\t\ti !== 'key' &&\n\t\t\ti !== 'value' &&\n\t\t\ti !== 'checked' &&\n\t\t\toldProps[i] !== newProps[i]\n\t\t) {\n\t\t\tsetProperty(dom, i, newProps[i], oldProps[i], isSvg);\n\t\t}\n\t}\n}\n\nfunction setStyle(style, key, value) {\n\tif (key[0] === '-') {\n\t\tstyle.setProperty(key, value);\n\t} else if (value == null) {\n\t\tstyle[key] = '';\n\t} else if (typeof value != 'number' || IS_NON_DIMENSIONAL.test(key)) {\n\t\tstyle[key] = value;\n\t} else {\n\t\tstyle[key] = value + 'px';\n\t}\n}\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node or not\n */\nexport function setProperty(dom, name, value, oldValue, isSvg) {\n\tlet useCapture, nameLower, proxy;\n\n\tif (isSvg && name == 'className') name = 'class';\n\n\t// if (isSvg) {\n\t// \tif (name === 'className') name = 'class';\n\t// } else if (name === 'class') name += 'Name';\n\n\tif (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture = name !== (name = name.replace(/Capture$/, ''));\n\t\tnameLower = name.toLowerCase();\n\t\tif (nameLower in dom) name = nameLower;\n\t\tname = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tproxy = useCapture ? eventProxyCapture : eventProxy;\n\t\tif (value) {\n\t\t\tif (!oldValue) dom.addEventListener(name, proxy, useCapture);\n\t\t} else {\n\t\t\tdom.removeEventListener(name, proxy, useCapture);\n\t\t}\n\t} else if (\n\t\tname !== 'list' &&\n\t\tname !== 'tagName' &&\n\t\t// HTMLButtonElement.form and HTMLInputElement.form are read-only but can be set using\n\t\t// setAttribute\n\t\tname !== 'form' &&\n\t\tname !== 'type' &&\n\t\tname !== 'size' &&\n\t\tname !== 'download' &&\n\t\tname !== 'href' &&\n\t\t!isSvg &&\n\t\tname in dom\n\t) {\n\t\tdom[name] = value == null ? '' : value;\n\t} else if (typeof value != 'function' && name !== 'dangerouslySetInnerHTML') {\n\t\tif (name !== (name = name.replace(/xlink:?/, ''))) {\n\t\t\tif (value == null || value === false) {\n\t\t\t\tdom.removeAttributeNS(\n\t\t\t\t\t'http://www.w3.org/1999/xlink',\n\t\t\t\t\tname.toLowerCase()\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tdom.setAttributeNS(\n\t\t\t\t\t'http://www.w3.org/1999/xlink',\n\t\t\t\t\tname.toLowerCase(),\n\t\t\t\t\tvalue\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (\n\t\t\tvalue == null ||\n\t\t\t(value === false &&\n\t\t\t\t// ARIA-attributes have a different notion of boolean values.\n\t\t\t\t// The value `false` is different from the attribute not\n\t\t\t\t// existing on the DOM, so we can't remove it. For non-boolean\n\t\t\t\t// ARIA-attributes we could treat false as a removal, but the\n\t\t\t\t// amount of exceptions would cost us too many bytes. On top of\n\t\t\t\t// that other VDOM frameworks also always stringify `false`.\n\t\t\t\t!/^ar/.test(name))\n\t\t) {\n\t\t\tdom.removeAttribute(name);\n\t\t} else {\n\t\t\tdom.setAttribute(name, value);\n\t\t}\n\t}\n}\n\n/**\n * Proxy an event to hooked event handlers\n * @param {Event} e The event object from the browser\n * @private\n */\nfunction eventProxy(e) {\n\tthis._listeners[e.type + false](options.event ? options.event(e) : e);\n}\n\nfunction eventProxyCapture(e) {\n\tthis._listeners[e.type + true](options.event ? options.event(e) : e);\n}\n","import { EMPTY_OBJ, EMPTY_ARR } from '../constants';\nimport { Component } from '../component';\nimport { Fragment } from '../create-element';\nimport { diffChildren, placeChild } from './children';\nimport { diffProps, setProperty } from './props';\nimport { assign, removeNode } from '../util';\nimport options from '../options';\n\nfunction reorderChildren(newVNode, oldDom, parentDom) {\n\tfor (let tmp = 0; tmp < newVNode._children.length; tmp++) {\n\t\tconst vnode = newVNode._children[tmp];\n\t\tif (vnode) {\n\t\t\tvnode._parent = newVNode;\n\n\t\t\tif (vnode._dom) {\n\t\t\t\tif (typeof vnode.type == 'function' && vnode._children.length > 1) {\n\t\t\t\t\treorderChildren(vnode, oldDom, parentDom);\n\t\t\t\t}\n\n\t\t\t\toldDom = placeChild(\n\t\t\t\t\tparentDom,\n\t\t\t\t\tvnode,\n\t\t\t\t\tvnode,\n\t\t\t\t\tnewVNode._children,\n\t\t\t\t\tnull,\n\t\t\t\t\tvnode._dom,\n\t\t\t\t\toldDom\n\t\t\t\t);\n\n\t\t\t\tif (typeof newVNode.type == 'function') {\n\t\t\t\t\tnewVNode._nextDom = oldDom;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').PreactElement} parentDom The parent of the DOM element\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object. Modified by getChildContext\n * @param {boolean} isSvg Whether or not this element is an SVG node\n * @param {Array<import('../internal').PreactElement>} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {Element | Text} oldDom The current attached DOM\n * element any new dom elements should be placed around. Likely `null` on first\n * render (except when hydrating). Can be a sibling DOM element when diffing\n * Fragments that have siblings. In most cases, it starts out as `oldChildren[0]._dom`.\n * @param {boolean} [isHydrating] Whether or not we are in hydration\n */\nexport function diff(\n\tparentDom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\toldDom,\n\tisHydrating\n) {\n\tlet tmp,\n\t\tnewType = newVNode.type;\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== undefined) return null;\n\n\tif ((tmp = options._diff)) tmp(newVNode);\n\n\ttry {\n\t\touter: if (typeof newType == 'function') {\n\t\t\tlet c, isNew, oldProps, oldState, snapshot, clearProcessingException;\n\t\t\tlet newProps = newVNode.props;\n\n\t\t\t// Necessary for createContext api. Setting this property will pass\n\t\t\t// the context value as `this.context` just for this component.\n\t\t\ttmp = newType.contextType;\n\t\t\tlet provider = tmp && globalContext[tmp._id];\n\t\t\tlet componentContext = tmp\n\t\t\t\t? provider\n\t\t\t\t\t? provider.props.value\n\t\t\t\t\t: tmp._defaultValue\n\t\t\t\t: globalContext;\n\n\t\t\t// Get component and set it to `c`\n\t\t\tif (oldVNode._component) {\n\t\t\t\tc = newVNode._component = oldVNode._component;\n\t\t\t\tclearProcessingException = c._processingException = c._pendingError;\n\t\t\t} else {\n\t\t\t\t// Instantiate the new component\n\t\t\t\tif ('prototype' in newType && newType.prototype.render) {\n\t\t\t\t\tnewVNode._component = c = new newType(newProps, componentContext); // eslint-disable-line new-cap\n\t\t\t\t} else {\n\t\t\t\t\tnewVNode._component = c = new Component(newProps, componentContext);\n\t\t\t\t\tc.constructor = newType;\n\t\t\t\t\tc.render = doRender;\n\t\t\t\t}\n\t\t\t\tif (provider) provider.sub(c);\n\n\t\t\t\tc.props = newProps;\n\t\t\t\tif (!c.state) c.state = {};\n\t\t\t\tc.context = componentContext;\n\t\t\t\tc._globalContext = globalContext;\n\t\t\t\tisNew = c._dirty = true;\n\t\t\t\tc._renderCallbacks = [];\n\t\t\t}\n\n\t\t\t// Invoke getDerivedStateFromProps\n\t\t\tif (c._nextState == null) {\n\t\t\t\tc._nextState = c.state;\n\t\t\t}\n\t\t\tif (newType.getDerivedStateFromProps != null) {\n\t\t\t\tif (c._nextState == c.state) {\n\t\t\t\t\tc._nextState = assign({}, c._nextState);\n\t\t\t\t}\n\n\t\t\t\tassign(\n\t\t\t\t\tc._nextState,\n\t\t\t\t\tnewType.getDerivedStateFromProps(newProps, c._nextState)\n\t\t\t\t);\n\t\t\t}\n\n\t\t\toldProps = c.props;\n\t\t\toldState = c.state;\n\n\t\t\t// Invoke pre-render lifecycle methods\n\t\t\tif (isNew) {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tc.componentWillMount != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillMount();\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidMount != null) {\n\t\t\t\t\tc._renderCallbacks.push(c.componentDidMount);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\tnewType.getDerivedStateFromProps == null &&\n\t\t\t\t\tnewProps !== oldProps &&\n\t\t\t\t\tc.componentWillReceiveProps != null\n\t\t\t\t) {\n\t\t\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t(!c._force &&\n\t\t\t\t\t\tc.shouldComponentUpdate != null &&\n\t\t\t\t\t\tc.shouldComponentUpdate(\n\t\t\t\t\t\t\tnewProps,\n\t\t\t\t\t\t\tc._nextState,\n\t\t\t\t\t\t\tcomponentContext\n\t\t\t\t\t\t) === false) ||\n\t\t\t\t\tnewVNode._original === oldVNode._original\n\t\t\t\t) {\n\t\t\t\t\tc.props = newProps;\n\t\t\t\t\tc.state = c._nextState;\n\t\t\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\t\t\tif (newVNode._original !== oldVNode._original) c._dirty = false;\n\t\t\t\t\tc._vnode = newVNode;\n\t\t\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t\t\t\tnewVNode._children = oldVNode._children;\n\t\t\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\t\t\tcommitQueue.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\treorderChildren(newVNode, oldDom, parentDom);\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\n\t\t\t\tif (c.componentWillUpdate != null) {\n\t\t\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t\t\t}\n\n\t\t\t\tif (c.componentDidUpdate != null) {\n\t\t\t\t\tc._renderCallbacks.push(() => {\n\t\t\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.context = componentContext;\n\t\t\tc.props = newProps;\n\t\t\tc.state = c._nextState;\n\n\t\t\tif ((tmp = options._render)) tmp(newVNode);\n\n\t\t\tc._dirty = false;\n\t\t\tc._vnode = newVNode;\n\t\t\tc._parentDom = parentDom;\n\n\t\t\ttmp = c.render(c.props, c.state, c.context);\n\n\t\t\t// Handle setState called in render, see #2553\n\t\t\tc.state = c._nextState;\n\n\t\t\tif (c.getChildContext != null) {\n\t\t\t\tglobalContext = assign(assign({}, globalContext), c.getChildContext());\n\t\t\t}\n\n\t\t\tif (!isNew && c.getSnapshotBeforeUpdate != null) {\n\t\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t\t}\n\n\t\t\tlet isTopLevelFragment =\n\t\t\t\ttmp != null && tmp.type == Fragment && tmp.key == null;\n\t\t\tlet renderResult = isTopLevelFragment ? tmp.props.children : tmp;\n\n\t\t\tdiffChildren(\n\t\t\t\tparentDom,\n\t\t\t\tArray.isArray(renderResult) ? renderResult : [renderResult],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\toldDom,\n\t\t\t\tisHydrating\n\t\t\t);\n\n\t\t\tc.base = newVNode._dom;\n\n\t\t\tif (c._renderCallbacks.length) {\n\t\t\t\tcommitQueue.push(c);\n\t\t\t}\n\n\t\t\tif (clearProcessingException) {\n\t\t\t\tc._pendingError = c._processingException = null;\n\t\t\t}\n\n\t\t\tc._force = false;\n\t\t} else if (\n\t\t\texcessDomChildren == null &&\n\t\t\tnewVNode._original === oldVNode._original\n\t\t) {\n\t\t\tnewVNode._children = oldVNode._children;\n\t\t\tnewVNode._dom = oldVNode._dom;\n\t\t} else {\n\t\t\tnewVNode._dom = diffElementNodes(\n\t\t\t\toldVNode._dom,\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tisSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\tif ((tmp = options.diffed)) tmp(newVNode);\n\t} catch (e) {\n\t\tnewVNode._original = null;\n\t\toptions._catchError(e, newVNode, oldVNode);\n\t}\n\n\treturn newVNode._dom;\n}\n\n/**\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').VNode} root\n */\nexport function commitRoot(commitQueue, root) {\n\tif (options._commit) options._commit(root, commitQueue);\n\n\tcommitQueue.some(c => {\n\t\ttry {\n\t\t\tcommitQueue = c._renderCallbacks;\n\t\t\tc._renderCallbacks = [];\n\t\t\tcommitQueue.some(cb => {\n\t\t\t\tcb.call(c);\n\t\t\t});\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t});\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {import('../internal').PreactElement} dom The DOM element representing\n * the virtual nodes being diffed\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').VNode} oldVNode The old virtual node\n * @param {object} globalContext The current context object\n * @param {boolean} isSvg Whether or not this DOM node is an SVG node\n * @param {*} excessDomChildren\n * @param {Array<import('../internal').Component>} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {boolean} isHydrating Whether or not we are in hydration\n * @returns {import('../internal').PreactElement}\n */\nfunction diffElementNodes(\n\tdom,\n\tnewVNode,\n\toldVNode,\n\tglobalContext,\n\tisSvg,\n\texcessDomChildren,\n\tcommitQueue,\n\tisHydrating\n) {\n\tlet i;\n\tlet oldProps = oldVNode.props;\n\tlet newProps = newVNode.props;\n\n\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\tisSvg = newVNode.type === 'svg' || isSvg;\n\n\tif (excessDomChildren != null) {\n\t\tfor (i = 0; i < excessDomChildren.length; i++) {\n\t\t\tconst child = excessDomChildren[i];\n\n\t\t\t// if newVNode matches an element in excessDomChildren or the `dom`\n\t\t\t// argument matches an element in excessDomChildren, remove it from\n\t\t\t// excessDomChildren so it isn't later removed in diffChildren\n\t\t\tif (\n\t\t\t\tchild != null &&\n\t\t\t\t((newVNode.type === null\n\t\t\t\t\t? child.nodeType === 3\n\t\t\t\t\t: child.localName === newVNode.type) ||\n\t\t\t\t\tdom == child)\n\t\t\t) {\n\t\t\t\tdom = child;\n\t\t\t\texcessDomChildren[i] = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dom == null) {\n\t\tif (newVNode.type === null) {\n\t\t\treturn document.createTextNode(newProps);\n\t\t}\n\n\t\tdom = isSvg\n\t\t\t? document.createElementNS('http://www.w3.org/2000/svg', newVNode.type)\n\t\t\t: document.createElement(\n\t\t\t\t\tnewVNode.type,\n\t\t\t\t\tnewProps.is && { is: newProps.is }\n\t\t\t  );\n\t\t// we created a new parent, so none of the previously attached children can be reused:\n\t\texcessDomChildren = null;\n\t\t// we are creating a new node, so we can assume this is a new subtree (in case we are hydrating), this deopts the hydrate\n\t\tisHydrating = false;\n\t}\n\n\tif (newVNode.type === null) {\n\t\tif (oldProps !== newProps && dom.data !== newProps) {\n\t\t\tdom.data = newProps;\n\t\t}\n\t} else {\n\t\tif (excessDomChildren != null) {\n\t\t\texcessDomChildren = EMPTY_ARR.slice.call(dom.childNodes);\n\t\t}\n\n\t\toldProps = oldVNode.props || EMPTY_OBJ;\n\n\t\tlet oldHtml = oldProps.dangerouslySetInnerHTML;\n\t\tlet newHtml = newProps.dangerouslySetInnerHTML;\n\n\t\t// During hydration, props are not diffed at all (including dangerouslySetInnerHTML)\n\t\t// @TODO we should warn in debug mode when props don't match here.\n\t\tif (!isHydrating) {\n\t\t\t// But, if we are in a situation where we are using existing DOM (e.g. replaceNode)\n\t\t\t// we should read the existing DOM attributes to diff them\n\t\t\tif (excessDomChildren != null) {\n\t\t\t\toldProps = {};\n\t\t\t\tfor (let i = 0; i < dom.attributes.length; i++) {\n\t\t\t\t\toldProps[dom.attributes[i].name] = dom.attributes[i].value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (newHtml || oldHtml) {\n\t\t\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\t\t\tif (\n\t\t\t\t\t!newHtml ||\n\t\t\t\t\t((!oldHtml || newHtml.__html != oldHtml.__html) &&\n\t\t\t\t\t\tnewHtml.__html !== dom.innerHTML)\n\t\t\t\t) {\n\t\t\t\t\tdom.innerHTML = (newHtml && newHtml.__html) || '';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdiffProps(dom, newProps, oldProps, isSvg, isHydrating);\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\tnewVNode._children = [];\n\t\t} else {\n\t\t\ti = newVNode.props.children;\n\t\t\tdiffChildren(\n\t\t\t\tdom,\n\t\t\t\tArray.isArray(i) ? i : [i],\n\t\t\t\tnewVNode,\n\t\t\t\toldVNode,\n\t\t\t\tglobalContext,\n\t\t\t\tnewVNode.type === 'foreignObject' ? false : isSvg,\n\t\t\t\texcessDomChildren,\n\t\t\t\tcommitQueue,\n\t\t\t\tEMPTY_OBJ,\n\t\t\t\tisHydrating\n\t\t\t);\n\t\t}\n\n\t\t// (as above, don't diff props during hydration)\n\t\tif (!isHydrating) {\n\t\t\tif (\n\t\t\t\t'value' in newProps &&\n\t\t\t\t(i = newProps.value) !== undefined &&\n\t\t\t\ti !== dom.value\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'value', i, oldProps.value, false);\n\t\t\t}\n\t\t\tif (\n\t\t\t\t'checked' in newProps &&\n\t\t\t\t(i = newProps.checked) !== undefined &&\n\t\t\t\ti !== dom.checked\n\t\t\t) {\n\t\t\t\tsetProperty(dom, 'checked', i, oldProps.checked, false);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {object|function} ref\n * @param {any} value\n * @param {import('../internal').VNode} vnode\n */\nexport function applyRef(ref, value, vnode) {\n\ttry {\n\t\tif (typeof ref == 'function') ref(value);\n\t\telse ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, vnode);\n\t}\n}\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {import('../internal').VNode} vnode The virtual node to unmount\n * @param {import('../internal').VNode} parentVNode The parent of the VNode that\n * initiated the unmount\n * @param {boolean} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(vnode, parentVNode, skipRemove) {\n\tlet r;\n\tif (options.unmount) options.unmount(vnode);\n\n\tif ((r = vnode.ref)) {\n\t\tif (!r.current || r.current === vnode._dom) applyRef(r, null, parentVNode);\n\t}\n\n\tlet dom;\n\tif (!skipRemove && typeof vnode.type != 'function') {\n\t\tskipRemove = (dom = vnode._dom) != null;\n\t}\n\n\t// Must be set to `undefined` to properly clean up `_nextDom`\n\t// for which `null` is a valid value. See comment in `create-element.js`\n\tvnode._dom = vnode._nextDom = undefined;\n\n\tif ((r = vnode._component) != null) {\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentVNode);\n\t\t\t}\n\t\t}\n\n\t\tr.base = r._parentDom = null;\n\t}\n\n\tif ((r = vnode._children)) {\n\t\tfor (let i = 0; i < r.length; i++) {\n\t\t\tif (r[i]) unmount(r[i], parentVNode, skipRemove);\n\t\t}\n\t}\n\n\tif (dom != null) removeNode(dom);\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n","import { enqueueRender } from '../component';\n\n/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').VNode} vnode The vnode that threw\n * the error that was caught (except for unmounting when this parameter\n * is the highest parent that was being unmounted)\n */\nexport function _catchError(error, vnode) {\n\t/** @type {import('../internal').Component} */\n\tlet component, hasCaught;\n\n\tfor (; (vnode = vnode._parent); ) {\n\t\tif ((component = vnode._component) && !component._processingException) {\n\t\t\ttry {\n\t\t\t\tif (\n\t\t\t\t\tcomponent.constructor &&\n\t\t\t\t\tcomponent.constructor.getDerivedStateFromError != null\n\t\t\t\t) {\n\t\t\t\t\thasCaught = true;\n\t\t\t\t\tcomponent.setState(\n\t\t\t\t\t\tcomponent.constructor.getDerivedStateFromError(error)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (component.componentDidCatch != null) {\n\t\t\t\t\thasCaught = true;\n\t\t\t\t\tcomponent.componentDidCatch(error);\n\t\t\t\t}\n\n\t\t\t\tif (hasCaught)\n\t\t\t\t\treturn enqueueRender((component._pendingError = component));\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n","import { assign } from './util';\nimport { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./index').ComponentChildren>} rest Any additional arguments will be used as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (i == 'key') key = props[i];\n\t\telse if (i == 'ref') ref = props[i];\n\t\telse normalizedProps[i] = props[i];\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\tif (children != null) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\tnull\n\t);\n}\n"],"names":["options","isValidElement","rerenderQueue","defer","prevDebounce","IS_HYDRATE","i","EMPTY_OBJ","EMPTY_ARR","IS_NON_DIMENSIONAL","assign","obj","props","removeNode","node","parentNode","removeChild","createElement","type","children","key","ref","normalizedProps","arguments","length","push","defaultProps","undefined","createVNode","original","vnode","constructor","Fragment","Component","context","getDomSibling","childIndex","indexOf","sibling","updateParentDomPointers","child","base","enqueueRender","c","process","debounceRendering","queue","sort","a","b","some","component","commitQueue","oldVNode","newDom","oldDom","parentDom","diff","ownerSVGElement","commitRoot","diffChildren","renderResult","newParentVNode","oldParentVNode","globalContext","isSvg","excessDomChildren","isHydrating","j","childVNode","firstChildDom","refs","oldChildren","oldChildrenLength","Array","isArray","placeChild","value","unmount","applyRef","nextDom","sibDom","outer","appendChild","nextSibling","insertBefore","diffProps","dom","newProps","oldProps","hydrate","setProperty","setStyle","style","test","name","oldValue","useCapture","nameLower","proxy","cssText","replace","toLowerCase","slice","_listeners","eventProxyCapture","eventProxy","addEventListener","removeEventListener","removeAttributeNS","setAttributeNS","removeAttribute","setAttribute","e","event","reorderChildren","newVNode","tmp","isNew","oldState","snapshot","clearProcessingException","provider","componentContext","newType","contextType","prototype","render","doRender","sub","state","getDerivedStateFromProps","componentWillMount","componentDidMount","componentWillReceiveProps","shouldComponentUpdate","componentWillUpdate","componentDidUpdate","getChildContext","getSnapshotBeforeUpdate","diffElementNodes","diffed","root","cb","call","oldHtml","newHtml","nodeType","localName","document","createTextNode","createElementNS","is","data","childNodes","dangerouslySetInnerHTML","attributes","innerHTML","checked","current","parentVNode","skipRemove","r","componentWillUnmount","this","replaceNode","error","hasCaught","getDerivedStateFromError","setState","componentDidCatch","update","callback","s","forceUpdate","Promise","then","bind","resolve","setTimeout","defaultValue","contextId","Consumer","contextValue","Provider","subs","ctx","_props","old","splice","toChildArray","out"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/preact/hooks/dist/hooks.js b/node_modules/preact/hooks/dist/hooks.js
index 00aa0cd..aecb4b3 100644
--- a/node_modules/preact/hooks/dist/hooks.js
+++ b/node_modules/preact/hooks/dist/hooks.js
@@ -1,2 +1,2 @@
-var n,t,r,u=require("preact"),o=0,i=[],c=u.options.__r,e=u.options.diffed,f=u.options.__c,a=u.options.unmount;function p(n,r){u.options.__h&&u.options.__h(t,n,o||r),o=0;var i=t.__H||(t.__H={__:[],__h:[]});return n>=i.__.length&&i.__.push({}),i.__[n]}function v(n){return o=1,s(A,n)}function s(r,u,o){var i=p(n++,2);return i.t=r,i.__c||(i.__c=t,i.__=[o?o(u):A(void 0,u),function(n){var t=i.t(i.__[0],n);i.__[0]!==t&&(i.__=[t,i.__[1]],i.__c.setState({}))}]),i.__}function x(r,o){var i=p(n++,4);!u.options.__s&&q(i.__H,o)&&(i.__=r,i.__H=o,t.__h.push(i))}function m(t,r){var u=p(n++,7);return q(u.__H,r)?(u.__H=r,u.__h=t,u.__=t()):u.__}function y(){i.some(function(n){if(n.__P)try{n.__H.__h.forEach(h),n.__H.__h.forEach(_),n.__H.__h=[]}catch(t){return n.__H.__h=[],u.options.__e(t,n.__v),!0}}),i=[]}u.options.__r=function(r){c&&c(r),n=0;var u=(t=r.__c).__H;u&&(u.__h.forEach(h),u.__h.forEach(_),u.__h=[])},u.options.diffed=function(n){e&&e(n);var t=n.__c;t&&t.__H&&t.__H.__h.length&&(1!==i.push(t)&&r===u.options.requestAnimationFrame||((r=u.options.requestAnimationFrame)||function(n){var t,r=function(){clearTimeout(u),l&&cancelAnimationFrame(t),setTimeout(n)},u=setTimeout(r,100);l&&(t=requestAnimationFrame(r))})(y))},u.options.__c=function(n,t){t.some(function(n){try{n.__h.forEach(h),n.__h=n.__h.filter(function(n){return!n.__||_(n)})}catch(r){t.some(function(n){n.__h&&(n.__h=[])}),t=[],u.options.__e(r,n.__v)}}),f&&f(n,t)},u.options.unmount=function(n){a&&a(n);var t=n.__c;if(t&&t.__H)try{t.__H.__.forEach(h)}catch(n){u.options.__e(n,t.__v)}};var l="function"==typeof requestAnimationFrame;function h(n){"function"==typeof n.u&&n.u()}function _(n){n.u=n.__()}function q(n,t){return!n||t.some(function(t,r){return t!==n[r]})}function A(n,t){return"function"==typeof t?t(n):t}exports.useState=v,exports.useReducer=s,exports.useEffect=function(r,o){var i=p(n++,3);!u.options.__s&&q(i.__H,o)&&(i.__=r,i.__H=o,t.__H.__h.push(i))},exports.useLayoutEffect=x,exports.useRef=function(n){return o=5,m(function(){return{current:n}},[])},exports.useImperativeHandle=function(n,t,r){o=6,x(function(){"function"==typeof n?n(t()):n&&(n.current=t())},null==r?r:r.concat(n))},exports.useMemo=m,exports.useCallback=function(n,t){return o=8,m(function(){return n},t)},exports.useContext=function(r){var u=t.context[r.__c],o=p(n++,9);return o.__c=r,u?(null==o.__&&(o.__=!0,u.sub(t)),u.props.value):r.__},exports.useDebugValue=function(n,t){u.options.useDebugValue&&u.options.useDebugValue(t?t(n):n)},exports.useErrorBoundary=function(r){var u=p(n++,10),o=v();return u.__=r,t.componentDidCatch||(t.componentDidCatch=function(n){u.__&&u.__(n),o[1](n)}),[o[0],function(){o[1](void 0)}]};
+var n,t,r,u=require("preact"),o=0,i=[],c=u.options.__r,e=u.options.diffed,f=u.options.__c,a=u.options.unmount;function p(n,r){u.options.__h&&u.options.__h(t,n,o||r),o=0;var i=t.__H||(t.__H={__:[],__h:[]});return n>=i.__.length&&i.__.push({}),i.__[n]}function v(n){return o=1,s(A,n)}function s(r,u,o){var i=p(n++,2);return i.t=r,i.__c||(i.__c=t,i.__=[o?o(u):A(void 0,u),function(n){var t=i.t(i.__[0],n);i.__[0]!==t&&(i.__=[t,i.__[1]],i.__c.setState({}))}]),i.__}function x(r,o){var i=p(n++,4);!u.options.__s&&q(i.__H,o)&&(i.__=r,i.__H=o,t.__h.push(i))}function m(t,r){var u=p(n++,7);return q(u.__H,r)?(u.__H=r,u.__h=t,u.__=t()):u.__}function y(){i.some(function(n){if(n.__P)try{n.__H.__h.forEach(h),n.__H.__h.forEach(_),n.__H.__h=[]}catch(t){return n.__H.__h=[],u.options.__e(t,n.__v),!0}}),i=[]}u.options.__r=function(r){c&&c(r),n=0;var u=(t=r.__c).__H;u&&(u.__h.forEach(h),u.__h.forEach(_),u.__h=[])},u.options.diffed=function(n){e&&e(n);var t=n.__c;t&&t.__H&&t.__H.__h.length&&(1!==i.push(t)&&r===u.options.requestAnimationFrame||((r=u.options.requestAnimationFrame)||function(n){var t,r=function(){clearTimeout(u),l&&cancelAnimationFrame(t),setTimeout(n)},u=setTimeout(r,100);l&&(t=requestAnimationFrame(r))})(y))},u.options.__c=function(n,t){t.some(function(n){try{n.__h.forEach(h),n.__h=n.__h.filter(function(n){return!n.__||_(n)})}catch(r){t.some(function(n){n.__h&&(n.__h=[])}),t=[],u.options.__e(r,n.__v)}}),f&&f(n,t)},u.options.unmount=function(n){a&&a(n);var t=n.__c;if(t&&t.__H)try{t.__H.__.forEach(h)}catch(n){u.options.__e(n,t.__v)}};var l="function"==typeof requestAnimationFrame;function h(n){"function"==typeof n.u&&n.u()}function _(n){n.u=n.__()}function q(n,t){return!n||n.length!==t.length||t.some(function(t,r){return t!==n[r]})}function A(n,t){return"function"==typeof t?t(n):t}exports.useState=v,exports.useReducer=s,exports.useEffect=function(r,o){var i=p(n++,3);!u.options.__s&&q(i.__H,o)&&(i.__=r,i.__H=o,t.__H.__h.push(i))},exports.useLayoutEffect=x,exports.useRef=function(n){return o=5,m(function(){return{current:n}},[])},exports.useImperativeHandle=function(n,t,r){o=6,x(function(){"function"==typeof n?n(t()):n&&(n.current=t())},null==r?r:r.concat(n))},exports.useMemo=m,exports.useCallback=function(n,t){return o=8,m(function(){return n},t)},exports.useContext=function(r){var u=t.context[r.__c],o=p(n++,9);return o.__c=r,u?(null==o.__&&(o.__=!0,u.sub(t)),u.props.value):r.__},exports.useDebugValue=function(n,t){u.options.useDebugValue&&u.options.useDebugValue(t?t(n):n)},exports.useErrorBoundary=function(r){var u=p(n++,10),o=v();return u.__=r,t.componentDidCatch||(t.componentDidCatch=function(n){u.__&&u.__(n),o[1](n)}),[o[0],function(){o[1](void 0)}]};
 //# sourceMappingURL=hooks.js.map
diff --git a/node_modules/preact/hooks/dist/hooks.js.map b/node_modules/preact/hooks/dist/hooks.js.map
index 6330a9c..73100c6 100644
--- a/node_modules/preact/hooks/dist/hooks.js.map
+++ b/node_modules/preact/hooks/dist/hooks.js.map
@@ -1 +1 @@
-{"version":3,"file":"hooks.js","sources":["../src/index.js"],"sourcesContent":["import { options } from 'preact';\n\n/** @type {number} */\nlet currentIndex;\n\n/** @type {import('./internal').Component} */\nlet currentComponent;\n\n/** @type {number} */\nlet currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nlet afterPaintEffects = [];\n\nlet oldBeforeRender = options._render;\nlet oldAfterDiff = options.diffed;\nlet oldCommit = options._commit;\nlet oldBeforeUnmount = options.unmount;\n\nconst RAF_TIMEOUT = 100;\nlet prevRaf;\n\noptions._render = vnode => {\n\tif (oldBeforeRender) oldBeforeRender(vnode);\n\n\tcurrentComponent = vnode._component;\n\tcurrentIndex = 0;\n\n\tconst hooks = currentComponent.__hooks;\n\tif (hooks) {\n\t\thooks._pendingEffects.forEach(invokeCleanup);\n\t\thooks._pendingEffects.forEach(invokeEffect);\n\t\thooks._pendingEffects = [];\n\t}\n};\n\noptions.diffed = vnode => {\n\tif (oldAfterDiff) oldAfterDiff(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks && c.__hooks._pendingEffects.length) {\n\t\tafterPaint(afterPaintEffects.push(c));\n\t}\n};\n\noptions._commit = (vnode, commitQueue) => {\n\tcommitQueue.some(component => {\n\t\ttry {\n\t\t\tcomponent._renderCallbacks.forEach(invokeCleanup);\n\t\t\tcomponent._renderCallbacks = component._renderCallbacks.filter(cb =>\n\t\t\t\tcb._value ? invokeEffect(cb) : true\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tcommitQueue.some(c => {\n\t\t\t\tif (c._renderCallbacks) c._renderCallbacks = [];\n\t\t\t});\n\t\t\tcommitQueue = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t});\n\n\tif (oldCommit) oldCommit(vnode, commitQueue);\n};\n\noptions.unmount = vnode => {\n\tif (oldBeforeUnmount) oldBeforeUnmount(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\ttry {\n\t\t\tc.__hooks._list.forEach(invokeCleanup);\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t}\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {import('./internal').HookState}\n */\nfunction getHookState(index, type) {\n\tif (options._hook) {\n\t\toptions._hook(currentComponent, index, currentHook || type);\n\t}\n\tcurrentHook = 0;\n\n\t// Largely inspired by:\n\t// * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n\t// * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n\t// Other implementations to look at:\n\t// * https://codesandbox.io/s/mnox05qp8\n\tconst hooks =\n\t\tcurrentComponent.__hooks ||\n\t\t(currentComponent.__hooks = {\n\t\t\t_list: [],\n\t\t\t_pendingEffects: []\n\t\t});\n\n\tif (index >= hooks._list.length) {\n\t\thooks._list.push({});\n\t}\n\treturn hooks._list[index];\n}\n\n/**\n * @param {import('./index').StateUpdater<any>} initialState\n */\nexport function useState(initialState) {\n\tcurrentHook = 1;\n\treturn useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @param {import('./index').Reducer<any, any>} reducer\n * @param {import('./index').StateUpdater<any>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ any, (state: any) => void ]}\n */\nexport function useReducer(reducer, initialState, init) {\n\t/** @type {import('./internal').ReducerHookState} */\n\tconst hookState = getHookState(currentIndex++, 2);\n\thookState._reducer = reducer;\n\tif (!hookState._component) {\n\t\thookState._component = currentComponent;\n\n\t\thookState._value = [\n\t\t\t!init ? invokeOrReturn(undefined, initialState) : init(initialState),\n\n\t\t\taction => {\n\t\t\t\tconst nextValue = hookState._reducer(hookState._value[0], action);\n\t\t\t\tif (hookState._value[0] !== nextValue) {\n\t\t\t\t\thookState._value = [nextValue, hookState._value[1]];\n\t\t\t\t\thookState._component.setState({});\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\t}\n\n\treturn hookState._value;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {any[]} args\n */\nexport function useEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 3);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._args = args;\n\n\t\tcurrentComponent.__hooks._pendingEffects.push(state);\n\t}\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {any[]} args\n */\nexport function useLayoutEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 4);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._args = args;\n\n\t\tcurrentComponent._renderCallbacks.push(state);\n\t}\n}\n\nexport function useRef(initialValue) {\n\tcurrentHook = 5;\n\treturn useMemo(() => ({ current: initialValue }), []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {any[]} args\n */\nexport function useImperativeHandle(ref, createHandle, args) {\n\tcurrentHook = 6;\n\tuseLayoutEffect(\n\t\t() => {\n\t\t\tif (typeof ref == 'function') ref(createHandle());\n\t\t\telse if (ref) ref.current = createHandle();\n\t\t},\n\t\targs == null ? args : args.concat(ref)\n\t);\n}\n\n/**\n * @param {() => any} factory\n * @param {any[]} args\n */\nexport function useMemo(factory, args) {\n\t/** @type {import('./internal').MemoHookState} */\n\tconst state = getHookState(currentIndex++, 7);\n\tif (argsChanged(state._args, args)) {\n\t\tstate._args = args;\n\t\tstate._factory = factory;\n\t\treturn (state._value = factory());\n\t}\n\n\treturn state._value;\n}\n\n/**\n * @param {() => void} callback\n * @param {any[]} args\n */\nexport function useCallback(callback, args) {\n\tcurrentHook = 8;\n\treturn useMemo(() => callback, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nexport function useContext(context) {\n\tconst provider = currentComponent.context[context._id];\n\t// We could skip this call here, but than we'd not call\n\t// `options._hook`. We need to do that in order to make\n\t// the devtools aware of this hook.\n\tconst state = getHookState(currentIndex++, 9);\n\t// The devtools needs access to the context object to\n\t// be able to pull of the default value when no provider\n\t// is present in the tree.\n\tstate._context = context;\n\tif (!provider) return context._defaultValue;\n\t// This is probably not safe to convert to \"!\"\n\tif (state._value == null) {\n\t\tstate._value = true;\n\t\tprovider.sub(currentComponent);\n\t}\n\treturn provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nexport function useDebugValue(value, formatter) {\n\tif (options.useDebugValue) {\n\t\toptions.useDebugValue(formatter ? formatter(value) : value);\n\t}\n}\n\nexport function useErrorBoundary(cb) {\n\tconst state = getHookState(currentIndex++, 10);\n\tconst errState = useState();\n\tstate._value = cb;\n\tif (!currentComponent.componentDidCatch) {\n\t\tcurrentComponent.componentDidCatch = err => {\n\t\t\tif (state._value) state._value(err);\n\t\t\terrState[1](err);\n\t\t};\n\t}\n\treturn [\n\t\terrState[0],\n\t\t() => {\n\t\t\terrState[1](undefined);\n\t\t}\n\t];\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n\tafterPaintEffects.some(component => {\n\t\tif (component._parentDom) {\n\t\t\ttry {\n\t\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\t} catch (e) {\n\t\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\t\toptions._catchError(e, component._vnode);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t});\n\tafterPaintEffects = [];\n}\n\nlet HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tif (HAS_RAF) cancelAnimationFrame(raf);\n\t\tsetTimeout(callback);\n\t};\n\tconst timeout = setTimeout(done, RAF_TIMEOUT);\n\n\tlet raf;\n\tif (HAS_RAF) {\n\t\traf = requestAnimationFrame(done);\n\t}\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n */\nfunction afterPaint(newQueueLength) {\n\tif (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n\t\tprevRaf = options.requestAnimationFrame;\n\t\t(prevRaf || afterNextFrame)(flushAfterPaintEffects);\n\t}\n}\n\n/**\n * @param {import('./internal').EffectHookState} hook\n */\nfunction invokeCleanup(hook) {\n\tif (typeof hook._cleanup == 'function') hook._cleanup();\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n */\nfunction invokeEffect(hook) {\n\thook._cleanup = hook._value();\n}\n\n/**\n * @param {any[]} oldArgs\n * @param {any[]} newArgs\n */\nfunction argsChanged(oldArgs, newArgs) {\n\treturn !oldArgs || newArgs.some((arg, index) => arg !== oldArgs[index]);\n}\n\nfunction invokeOrReturn(arg, f) {\n\treturn typeof f == 'function' ? f(arg) : f;\n}\n"],"names":["currentIndex","currentComponent","prevRaf","currentHook","afterPaintEffects","oldBeforeRender","options","oldAfterDiff","diffed","oldCommit","oldBeforeUnmount","unmount","getHookState","index","type","hooks","length","push","useState","initialState","useReducer","invokeOrReturn","reducer","init","hookState","_reducer","undefined","action","nextValue","setState","useLayoutEffect","callback","args","state","argsChanged","useMemo","factory","flushAfterPaintEffects","some","component","forEach","invokeCleanup","invokeEffect","e","vnode","c","requestAnimationFrame","raf","done","clearTimeout","timeout","HAS_RAF","cancelAnimationFrame","setTimeout","commitQueue","filter","cb","hook","_cleanup","oldArgs","newArgs","arg","f","initialValue","current","ref","createHandle","concat","context","provider","sub","props","value","formatter","useDebugValue","errState","componentDidCatch","err"],"mappings":"IAGIA,EAGAC,EAcAC,sBAXAC,EAAc,EAGdC,EAAoB,GAEpBC,EAAkBC,cAClBC,EAAeD,UAAQE,OACvBC,EAAYH,cACZI,EAAmBJ,UAAQK,QAkE/B,SAASC,EAAaC,EAAOC,GACxBR,eACHA,cAAcL,EAAkBY,EAAOV,GAAeW,GAEvDX,EAAc,MAORY,EACLd,QACCA,MAA2B,IACpB,OACU,YAGfY,GAASE,KAAYC,QACxBD,KAAYE,KAAK,IAEXF,KAAYF,GAMb,SAASK,EAASC,UACxBhB,EAAc,EACPiB,EAAWC,EAAgBF,GASnC,SAAgBC,EAAWE,EAASH,EAAcI,OAE3CC,EAAYZ,EAAaZ,IAAgB,UAC/CwB,EAAUC,EAAWH,EAChBE,QACJA,MAAuBvB,EAEvBuB,KAAmB,CACjBD,EAAiDA,EAAKJ,GAA/CE,OAAeK,EAAWP,GAElC,SAAAQ,OACOC,EAAYJ,EAAUC,EAASD,KAAiB,GAAIG,GACtDH,KAAiB,KAAOI,IAC3BJ,KAAmB,CAACI,EAAWJ,KAAiB,IAChDA,MAAqBK,SAAS,QAM3BL,KAsBD,SAASM,EAAgBC,EAAUC,OAEnCC,EAAQrB,EAAaZ,IAAgB,IACtCM,eAAwB4B,EAAYD,MAAaD,KACrDC,KAAeF,EACfE,MAAcD,EAEd/B,MAAkCgB,KAAKgB,IA6BlC,SAASE,EAAQC,EAASJ,OAE1BC,EAAQrB,EAAaZ,IAAgB,UACvCkC,EAAYD,MAAaD,IAC5BC,MAAcD,EACdC,MAAiBG,EACTH,KAAeG,KAGjBH,KAiER,SAASI,IACRjC,EAAkBkC,KAAK,SAAAC,MAClBA,UAEFA,UAAkCC,QAAQC,GAC1CF,UAAkCC,QAAQE,GAC1CH,UAAoC,GACnC,MAAOI,UACRJ,UAAoC,GACpCjC,cAAoBqC,EAAGJ,QAChB,KAIVnC,EAAoB,GAzQrBE,cAAkB,SAAAsC,GACbvC,GAAiBA,EAAgBuC,GAGrC5C,EAAe,MAETe,GAHNd,EAAmB2C,WAIf7B,IACHA,MAAsByB,QAAQC,GAC9B1B,MAAsByB,QAAQE,GAC9B3B,MAAwB,KAI1BT,UAAQE,OAAS,SAAAoC,GACZrC,GAAcA,EAAaqC,OAEzBC,EAAID,MACNC,GAAKA,OAAaA,UAA0B7B,SA4RzB,IA3RXZ,EAAkBa,KAAK4B,IA2RP3C,IAAYI,UAAQwC,yBAC/C5C,EAAUI,UAAQwC,wBAvBpB,SAAwBf,OAQnBgB,EAPEC,EAAO,WACZC,aAAaC,GACTC,GAASC,qBAAqBL,GAClCM,WAAWtB,IAENmB,EAAUG,WAAWL,EAjSR,KAoSfG,IACHJ,EAAMD,sBAAsBE,MAcAX,KAzR9B/B,cAAkB,SAACsC,EAAOU,GACzBA,EAAYhB,KAAK,SAAAC,OAEfA,MAA2BC,QAAQC,GACnCF,MAA6BA,MAA2BgB,OAAO,SAAAC,UAC9DA,MAAYd,EAAac,KAEzB,MAAOb,GACRW,EAAYhB,KAAK,SAAAO,GACZA,QAAoBA,MAAqB,MAE9CS,EAAc,GACdhD,cAAoBqC,EAAGJ,UAIrB9B,GAAWA,EAAUmC,EAAOU,IAGjChD,UAAQK,QAAU,SAAAiC,GACblC,GAAkBA,EAAiBkC,OAEjCC,EAAID,SACNC,GAAKA,UAEPA,SAAgBL,QAAQC,GACvB,MAAOE,GACRrC,cAAoBqC,EAAGE,SA0N1B,IAAIM,EAA0C,mBAAzBL,sBA2CrB,SAASL,EAAcgB,GACM,mBAAjBA,EAAKC,GAAwBD,EAAKC,IAO9C,SAAShB,EAAae,GACrBA,EAAKC,EAAWD,OAOjB,SAASvB,EAAYyB,EAASC,UACrBD,GAAWC,EAAQtB,KAAK,SAACuB,EAAKhD,UAAUgD,IAAQF,EAAQ9C,KAGjE,SAASQ,EAAewC,EAAKC,SACT,mBAALA,EAAkBA,EAAED,GAAOC,4DA9MnC,SAAmB/B,EAAUC,OAE7BC,EAAQrB,EAAaZ,IAAgB,IACtCM,eAAwB4B,EAAYD,MAAaD,KACrDC,KAAeF,EACfE,MAAcD,EAEd/B,UAAyCgB,KAAKgB,8CAmBzC,SAAgB8B,UACtB5D,EAAc,EACPgC,EAAQ,iBAAO,CAAE6B,QAASD,IAAiB,iCAQnD,SAAoCE,EAAKC,EAAclC,GACtD7B,EAAc,EACd2B,EACC,WACmB,mBAAPmC,EAAmBA,EAAIC,KACzBD,IAAKA,EAAID,QAAUE,MAErB,MAARlC,EAAeA,EAAOA,EAAKmC,OAAOF,2CAwB7B,SAAqBlC,EAAUC,UACrC7B,EAAc,EACPgC,EAAQ,kBAAMJ,GAAUC,uBAMzB,SAAoBoC,OACpBC,EAAWpE,EAAiBmE,QAAQA,OAIpCnC,EAAQrB,EAAaZ,IAAgB,UAI3CiC,MAAiBmC,EACZC,GAEe,MAAhBpC,OACHA,MAAe,EACfoC,EAASC,IAAIrE,IAEPoE,EAASE,MAAMC,OANAJ,4BAahB,SAAuBI,EAAOC,GAChCnE,UAAQoE,eACXpE,UAAQoE,cAAcD,EAAYA,EAAUD,GAASA,6BAIhD,SAA0BhB,OAC1BvB,EAAQrB,EAAaZ,IAAgB,IACrC2E,EAAWzD,WACjBe,KAAeuB,EACVvD,EAAiB2E,oBACrB3E,EAAiB2E,kBAAoB,SAAAC,GAChC5C,MAAcA,KAAa4C,GAC/BF,EAAS,GAAGE,KAGP,CACNF,EAAS,GACT,WACCA,EAAS,QAAGjD"}
\ No newline at end of file
+{"version":3,"file":"hooks.js","sources":["../src/index.js"],"sourcesContent":["import { options } from 'preact';\n\n/** @type {number} */\nlet currentIndex;\n\n/** @type {import('./internal').Component} */\nlet currentComponent;\n\n/** @type {number} */\nlet currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nlet afterPaintEffects = [];\n\nlet oldBeforeRender = options._render;\nlet oldAfterDiff = options.diffed;\nlet oldCommit = options._commit;\nlet oldBeforeUnmount = options.unmount;\n\nconst RAF_TIMEOUT = 100;\nlet prevRaf;\n\noptions._render = vnode => {\n\tif (oldBeforeRender) oldBeforeRender(vnode);\n\n\tcurrentComponent = vnode._component;\n\tcurrentIndex = 0;\n\n\tconst hooks = currentComponent.__hooks;\n\tif (hooks) {\n\t\thooks._pendingEffects.forEach(invokeCleanup);\n\t\thooks._pendingEffects.forEach(invokeEffect);\n\t\thooks._pendingEffects = [];\n\t}\n};\n\noptions.diffed = vnode => {\n\tif (oldAfterDiff) oldAfterDiff(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks && c.__hooks._pendingEffects.length) {\n\t\tafterPaint(afterPaintEffects.push(c));\n\t}\n};\n\noptions._commit = (vnode, commitQueue) => {\n\tcommitQueue.some(component => {\n\t\ttry {\n\t\t\tcomponent._renderCallbacks.forEach(invokeCleanup);\n\t\t\tcomponent._renderCallbacks = component._renderCallbacks.filter(cb =>\n\t\t\t\tcb._value ? invokeEffect(cb) : true\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tcommitQueue.some(c => {\n\t\t\t\tif (c._renderCallbacks) c._renderCallbacks = [];\n\t\t\t});\n\t\t\tcommitQueue = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t});\n\n\tif (oldCommit) oldCommit(vnode, commitQueue);\n};\n\noptions.unmount = vnode => {\n\tif (oldBeforeUnmount) oldBeforeUnmount(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\ttry {\n\t\t\tc.__hooks._list.forEach(invokeCleanup);\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t}\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {import('./internal').HookState}\n */\nfunction getHookState(index, type) {\n\tif (options._hook) {\n\t\toptions._hook(currentComponent, index, currentHook || type);\n\t}\n\tcurrentHook = 0;\n\n\t// Largely inspired by:\n\t// * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n\t// * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n\t// Other implementations to look at:\n\t// * https://codesandbox.io/s/mnox05qp8\n\tconst hooks =\n\t\tcurrentComponent.__hooks ||\n\t\t(currentComponent.__hooks = {\n\t\t\t_list: [],\n\t\t\t_pendingEffects: []\n\t\t});\n\n\tif (index >= hooks._list.length) {\n\t\thooks._list.push({});\n\t}\n\treturn hooks._list[index];\n}\n\n/**\n * @param {import('./index').StateUpdater<any>} initialState\n */\nexport function useState(initialState) {\n\tcurrentHook = 1;\n\treturn useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @param {import('./index').Reducer<any, any>} reducer\n * @param {import('./index').StateUpdater<any>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ any, (state: any) => void ]}\n */\nexport function useReducer(reducer, initialState, init) {\n\t/** @type {import('./internal').ReducerHookState} */\n\tconst hookState = getHookState(currentIndex++, 2);\n\thookState._reducer = reducer;\n\tif (!hookState._component) {\n\t\thookState._component = currentComponent;\n\n\t\thookState._value = [\n\t\t\t!init ? invokeOrReturn(undefined, initialState) : init(initialState),\n\n\t\t\taction => {\n\t\t\t\tconst nextValue = hookState._reducer(hookState._value[0], action);\n\t\t\t\tif (hookState._value[0] !== nextValue) {\n\t\t\t\t\thookState._value = [nextValue, hookState._value[1]];\n\t\t\t\t\thookState._component.setState({});\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\t}\n\n\treturn hookState._value;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {any[]} args\n */\nexport function useEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 3);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._args = args;\n\n\t\tcurrentComponent.__hooks._pendingEffects.push(state);\n\t}\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {any[]} args\n */\nexport function useLayoutEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 4);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._args = args;\n\n\t\tcurrentComponent._renderCallbacks.push(state);\n\t}\n}\n\nexport function useRef(initialValue) {\n\tcurrentHook = 5;\n\treturn useMemo(() => ({ current: initialValue }), []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {any[]} args\n */\nexport function useImperativeHandle(ref, createHandle, args) {\n\tcurrentHook = 6;\n\tuseLayoutEffect(\n\t\t() => {\n\t\t\tif (typeof ref == 'function') ref(createHandle());\n\t\t\telse if (ref) ref.current = createHandle();\n\t\t},\n\t\targs == null ? args : args.concat(ref)\n\t);\n}\n\n/**\n * @param {() => any} factory\n * @param {any[]} args\n */\nexport function useMemo(factory, args) {\n\t/** @type {import('./internal').MemoHookState} */\n\tconst state = getHookState(currentIndex++, 7);\n\tif (argsChanged(state._args, args)) {\n\t\tstate._args = args;\n\t\tstate._factory = factory;\n\t\treturn (state._value = factory());\n\t}\n\n\treturn state._value;\n}\n\n/**\n * @param {() => void} callback\n * @param {any[]} args\n */\nexport function useCallback(callback, args) {\n\tcurrentHook = 8;\n\treturn useMemo(() => callback, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nexport function useContext(context) {\n\tconst provider = currentComponent.context[context._id];\n\t// We could skip this call here, but than we'd not call\n\t// `options._hook`. We need to do that in order to make\n\t// the devtools aware of this hook.\n\tconst state = getHookState(currentIndex++, 9);\n\t// The devtools needs access to the context object to\n\t// be able to pull of the default value when no provider\n\t// is present in the tree.\n\tstate._context = context;\n\tif (!provider) return context._defaultValue;\n\t// This is probably not safe to convert to \"!\"\n\tif (state._value == null) {\n\t\tstate._value = true;\n\t\tprovider.sub(currentComponent);\n\t}\n\treturn provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nexport function useDebugValue(value, formatter) {\n\tif (options.useDebugValue) {\n\t\toptions.useDebugValue(formatter ? formatter(value) : value);\n\t}\n}\n\nexport function useErrorBoundary(cb) {\n\tconst state = getHookState(currentIndex++, 10);\n\tconst errState = useState();\n\tstate._value = cb;\n\tif (!currentComponent.componentDidCatch) {\n\t\tcurrentComponent.componentDidCatch = err => {\n\t\t\tif (state._value) state._value(err);\n\t\t\terrState[1](err);\n\t\t};\n\t}\n\treturn [\n\t\terrState[0],\n\t\t() => {\n\t\t\terrState[1](undefined);\n\t\t}\n\t];\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n\tafterPaintEffects.some(component => {\n\t\tif (component._parentDom) {\n\t\t\ttry {\n\t\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\t} catch (e) {\n\t\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\t\toptions._catchError(e, component._vnode);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t});\n\tafterPaintEffects = [];\n}\n\nlet HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tif (HAS_RAF) cancelAnimationFrame(raf);\n\t\tsetTimeout(callback);\n\t};\n\tconst timeout = setTimeout(done, RAF_TIMEOUT);\n\n\tlet raf;\n\tif (HAS_RAF) {\n\t\traf = requestAnimationFrame(done);\n\t}\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n */\nfunction afterPaint(newQueueLength) {\n\tif (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n\t\tprevRaf = options.requestAnimationFrame;\n\t\t(prevRaf || afterNextFrame)(flushAfterPaintEffects);\n\t}\n}\n\n/**\n * @param {import('./internal').EffectHookState} hook\n */\nfunction invokeCleanup(hook) {\n\tif (typeof hook._cleanup == 'function') hook._cleanup();\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n */\nfunction invokeEffect(hook) {\n\thook._cleanup = hook._value();\n}\n\n/**\n * @param {any[]} oldArgs\n * @param {any[]} newArgs\n */\nfunction argsChanged(oldArgs, newArgs) {\n\treturn !oldArgs || oldArgs.length !== newArgs.length || newArgs.some((arg, index) => arg !== oldArgs[index]);\n}\n\nfunction invokeOrReturn(arg, f) {\n\treturn typeof f == 'function' ? f(arg) : f;\n}\n"],"names":["currentIndex","currentComponent","prevRaf","currentHook","afterPaintEffects","oldBeforeRender","options","oldAfterDiff","diffed","oldCommit","oldBeforeUnmount","unmount","getHookState","index","type","hooks","length","push","useState","initialState","useReducer","invokeOrReturn","reducer","init","hookState","_reducer","undefined","action","nextValue","setState","useLayoutEffect","callback","args","state","argsChanged","useMemo","factory","flushAfterPaintEffects","some","component","forEach","invokeCleanup","invokeEffect","e","vnode","c","requestAnimationFrame","raf","done","clearTimeout","timeout","HAS_RAF","cancelAnimationFrame","setTimeout","commitQueue","filter","cb","hook","_cleanup","oldArgs","newArgs","arg","f","initialValue","current","ref","createHandle","concat","context","provider","sub","props","value","formatter","useDebugValue","errState","componentDidCatch","err"],"mappings":"IAGIA,EAGAC,EAcAC,sBAXAC,EAAc,EAGdC,EAAoB,GAEpBC,EAAkBC,cAClBC,EAAeD,UAAQE,OACvBC,EAAYH,cACZI,EAAmBJ,UAAQK,QAkE/B,SAASC,EAAaC,EAAOC,GACxBR,eACHA,cAAcL,EAAkBY,EAAOV,GAAeW,GAEvDX,EAAc,MAORY,EACLd,QACCA,MAA2B,IACpB,OACU,YAGfY,GAASE,KAAYC,QACxBD,KAAYE,KAAK,IAEXF,KAAYF,GAMb,SAASK,EAASC,UACxBhB,EAAc,EACPiB,EAAWC,EAAgBF,GASnC,SAAgBC,EAAWE,EAASH,EAAcI,OAE3CC,EAAYZ,EAAaZ,IAAgB,UAC/CwB,EAAUC,EAAWH,EAChBE,QACJA,MAAuBvB,EAEvBuB,KAAmB,CACjBD,EAAiDA,EAAKJ,GAA/CE,OAAeK,EAAWP,GAElC,SAAAQ,OACOC,EAAYJ,EAAUC,EAASD,KAAiB,GAAIG,GACtDH,KAAiB,KAAOI,IAC3BJ,KAAmB,CAACI,EAAWJ,KAAiB,IAChDA,MAAqBK,SAAS,QAM3BL,KAsBD,SAASM,EAAgBC,EAAUC,OAEnCC,EAAQrB,EAAaZ,IAAgB,IACtCM,eAAwB4B,EAAYD,MAAaD,KACrDC,KAAeF,EACfE,MAAcD,EAEd/B,MAAkCgB,KAAKgB,IA6BlC,SAASE,EAAQC,EAASJ,OAE1BC,EAAQrB,EAAaZ,IAAgB,UACvCkC,EAAYD,MAAaD,IAC5BC,MAAcD,EACdC,MAAiBG,EACTH,KAAeG,KAGjBH,KAiER,SAASI,IACRjC,EAAkBkC,KAAK,SAAAC,MAClBA,UAEFA,UAAkCC,QAAQC,GAC1CF,UAAkCC,QAAQE,GAC1CH,UAAoC,GACnC,MAAOI,UACRJ,UAAoC,GACpCjC,cAAoBqC,EAAGJ,QAChB,KAIVnC,EAAoB,GAzQrBE,cAAkB,SAAAsC,GACbvC,GAAiBA,EAAgBuC,GAGrC5C,EAAe,MAETe,GAHNd,EAAmB2C,WAIf7B,IACHA,MAAsByB,QAAQC,GAC9B1B,MAAsByB,QAAQE,GAC9B3B,MAAwB,KAI1BT,UAAQE,OAAS,SAAAoC,GACZrC,GAAcA,EAAaqC,OAEzBC,EAAID,MACNC,GAAKA,OAAaA,UAA0B7B,SA4RzB,IA3RXZ,EAAkBa,KAAK4B,IA2RP3C,IAAYI,UAAQwC,yBAC/C5C,EAAUI,UAAQwC,wBAvBpB,SAAwBf,OAQnBgB,EAPEC,EAAO,WACZC,aAAaC,GACTC,GAASC,qBAAqBL,GAClCM,WAAWtB,IAENmB,EAAUG,WAAWL,EAjSR,KAoSfG,IACHJ,EAAMD,sBAAsBE,MAcAX,KAzR9B/B,cAAkB,SAACsC,EAAOU,GACzBA,EAAYhB,KAAK,SAAAC,OAEfA,MAA2BC,QAAQC,GACnCF,MAA6BA,MAA2BgB,OAAO,SAAAC,UAC9DA,MAAYd,EAAac,KAEzB,MAAOb,GACRW,EAAYhB,KAAK,SAAAO,GACZA,QAAoBA,MAAqB,MAE9CS,EAAc,GACdhD,cAAoBqC,EAAGJ,UAIrB9B,GAAWA,EAAUmC,EAAOU,IAGjChD,UAAQK,QAAU,SAAAiC,GACblC,GAAkBA,EAAiBkC,OAEjCC,EAAID,SACNC,GAAKA,UAEPA,SAAgBL,QAAQC,GACvB,MAAOE,GACRrC,cAAoBqC,EAAGE,SA0N1B,IAAIM,EAA0C,mBAAzBL,sBA2CrB,SAASL,EAAcgB,GACM,mBAAjBA,EAAKC,GAAwBD,EAAKC,IAO9C,SAAShB,EAAae,GACrBA,EAAKC,EAAWD,OAOjB,SAASvB,EAAYyB,EAASC,UACrBD,GAAWA,EAAQ3C,SAAW4C,EAAQ5C,QAAU4C,EAAQtB,KAAK,SAACuB,EAAKhD,UAAUgD,IAAQF,EAAQ9C,KAGtG,SAASQ,EAAewC,EAAKC,SACT,mBAALA,EAAkBA,EAAED,GAAOC,4DA9MnC,SAAmB/B,EAAUC,OAE7BC,EAAQrB,EAAaZ,IAAgB,IACtCM,eAAwB4B,EAAYD,MAAaD,KACrDC,KAAeF,EACfE,MAAcD,EAEd/B,UAAyCgB,KAAKgB,8CAmBzC,SAAgB8B,UACtB5D,EAAc,EACPgC,EAAQ,iBAAO,CAAE6B,QAASD,IAAiB,iCAQnD,SAAoCE,EAAKC,EAAclC,GACtD7B,EAAc,EACd2B,EACC,WACmB,mBAAPmC,EAAmBA,EAAIC,KACzBD,IAAKA,EAAID,QAAUE,MAErB,MAARlC,EAAeA,EAAOA,EAAKmC,OAAOF,2CAwB7B,SAAqBlC,EAAUC,UACrC7B,EAAc,EACPgC,EAAQ,kBAAMJ,GAAUC,uBAMzB,SAAoBoC,OACpBC,EAAWpE,EAAiBmE,QAAQA,OAIpCnC,EAAQrB,EAAaZ,IAAgB,UAI3CiC,MAAiBmC,EACZC,GAEe,MAAhBpC,OACHA,MAAe,EACfoC,EAASC,IAAIrE,IAEPoE,EAASE,MAAMC,OANAJ,4BAahB,SAAuBI,EAAOC,GAChCnE,UAAQoE,eACXpE,UAAQoE,cAAcD,EAAYA,EAAUD,GAASA,6BAIhD,SAA0BhB,OAC1BvB,EAAQrB,EAAaZ,IAAgB,IACrC2E,EAAWzD,WACjBe,KAAeuB,EACVvD,EAAiB2E,oBACrB3E,EAAiB2E,kBAAoB,SAAAC,GAChC5C,MAAcA,KAAa4C,GAC/BF,EAAS,GAAGE,KAGP,CACNF,EAAS,GACT,WACCA,EAAS,QAAGjD"}
\ No newline at end of file
diff --git a/node_modules/preact/hooks/dist/hooks.mjs b/node_modules/preact/hooks/dist/hooks.mjs
index ec31b15..e0b8bcb 100644
--- a/node_modules/preact/hooks/dist/hooks.mjs
+++ b/node_modules/preact/hooks/dist/hooks.mjs
@@ -1,2 +1,2 @@
-import{options as n}from"preact";var t,u,r,o=0,i=[],c=n.__r,f=n.diffed,e=n.__c,a=n.unmount;function v(t,r){n.__h&&n.__h(u,t,o||r),o=0;var i=u.__H||(u.__H={__:[],__h:[]});return t>=i.__.length&&i.__.push({}),i.__[t]}function m(n){return o=1,p(k,n)}function p(n,r,o){var i=v(t++,2);return i.t=n,i.__c||(i.__c=u,i.__=[o?o(r):k(void 0,r),function(n){var t=i.t(i.__[0],n);i.__[0]!==t&&(i.__=[t,i.__[1]],i.__c.setState({}))}]),i.__}function y(r,o){var i=v(t++,3);!n.__s&&j(i.__H,o)&&(i.__=r,i.__H=o,u.__H.__h.push(i))}function l(r,o){var i=v(t++,4);!n.__s&&j(i.__H,o)&&(i.__=r,i.__H=o,u.__h.push(i))}function h(n){return o=5,_(function(){return{current:n}},[])}function s(n,t,u){o=6,l(function(){"function"==typeof n?n(t()):n&&(n.current=t())},null==u?u:u.concat(n))}function _(n,u){var r=v(t++,7);return j(r.__H,u)?(r.__H=u,r.__h=n,r.__=n()):r.__}function A(n,t){return o=8,_(function(){return n},t)}function F(n){var r=u.context[n.__c],o=v(t++,9);return o.__c=n,r?(null==o.__&&(o.__=!0,r.sub(u)),r.props.value):n.__}function T(t,u){n.useDebugValue&&n.useDebugValue(u?u(t):t)}function d(n){var r=v(t++,10),o=m();return r.__=n,u.componentDidCatch||(u.componentDidCatch=function(n){r.__&&r.__(n),o[1](n)}),[o[0],function(){o[1](void 0)}]}function q(){i.some(function(t){if(t.__P)try{t.__H.__h.forEach(b),t.__H.__h.forEach(g),t.__H.__h=[]}catch(u){return t.__H.__h=[],n.__e(u,t.__v),!0}}),i=[]}n.__r=function(n){c&&c(n),t=0;var r=(u=n.__c).__H;r&&(r.__h.forEach(b),r.__h.forEach(g),r.__h=[])},n.diffed=function(t){f&&f(t);var u=t.__c;u&&u.__H&&u.__H.__h.length&&(1!==i.push(u)&&r===n.requestAnimationFrame||((r=n.requestAnimationFrame)||function(n){var t,u=function(){clearTimeout(r),x&&cancelAnimationFrame(t),setTimeout(n)},r=setTimeout(u,100);x&&(t=requestAnimationFrame(u))})(q))},n.__c=function(t,u){u.some(function(t){try{t.__h.forEach(b),t.__h=t.__h.filter(function(n){return!n.__||g(n)})}catch(r){u.some(function(n){n.__h&&(n.__h=[])}),u=[],n.__e(r,t.__v)}}),e&&e(t,u)},n.unmount=function(t){a&&a(t);var u=t.__c;if(u&&u.__H)try{u.__H.__.forEach(b)}catch(t){n.__e(t,u.__v)}};var x="function"==typeof requestAnimationFrame;function b(n){"function"==typeof n.u&&n.u()}function g(n){n.u=n.__()}function j(n,t){return!n||t.some(function(t,u){return t!==n[u]})}function k(n,t){return"function"==typeof t?t(n):t}export{m as useState,p as useReducer,y as useEffect,l as useLayoutEffect,h as useRef,s as useImperativeHandle,_ as useMemo,A as useCallback,F as useContext,T as useDebugValue,d as useErrorBoundary};
+import{options as n}from"preact";var t,u,r,o=0,i=[],c=n.__r,f=n.diffed,e=n.__c,a=n.unmount;function v(t,r){n.__h&&n.__h(u,t,o||r),o=0;var i=u.__H||(u.__H={__:[],__h:[]});return t>=i.__.length&&i.__.push({}),i.__[t]}function m(n){return o=1,p(k,n)}function p(n,r,o){var i=v(t++,2);return i.t=n,i.__c||(i.__c=u,i.__=[o?o(r):k(void 0,r),function(n){var t=i.t(i.__[0],n);i.__[0]!==t&&(i.__=[t,i.__[1]],i.__c.setState({}))}]),i.__}function y(r,o){var i=v(t++,3);!n.__s&&j(i.__H,o)&&(i.__=r,i.__H=o,u.__H.__h.push(i))}function l(r,o){var i=v(t++,4);!n.__s&&j(i.__H,o)&&(i.__=r,i.__H=o,u.__h.push(i))}function h(n){return o=5,_(function(){return{current:n}},[])}function s(n,t,u){o=6,l(function(){"function"==typeof n?n(t()):n&&(n.current=t())},null==u?u:u.concat(n))}function _(n,u){var r=v(t++,7);return j(r.__H,u)?(r.__H=u,r.__h=n,r.__=n()):r.__}function A(n,t){return o=8,_(function(){return n},t)}function F(n){var r=u.context[n.__c],o=v(t++,9);return o.__c=n,r?(null==o.__&&(o.__=!0,r.sub(u)),r.props.value):n.__}function T(t,u){n.useDebugValue&&n.useDebugValue(u?u(t):t)}function d(n){var r=v(t++,10),o=m();return r.__=n,u.componentDidCatch||(u.componentDidCatch=function(n){r.__&&r.__(n),o[1](n)}),[o[0],function(){o[1](void 0)}]}function q(){i.some(function(t){if(t.__P)try{t.__H.__h.forEach(b),t.__H.__h.forEach(g),t.__H.__h=[]}catch(u){return t.__H.__h=[],n.__e(u,t.__v),!0}}),i=[]}n.__r=function(n){c&&c(n),t=0;var r=(u=n.__c).__H;r&&(r.__h.forEach(b),r.__h.forEach(g),r.__h=[])},n.diffed=function(t){f&&f(t);var u=t.__c;u&&u.__H&&u.__H.__h.length&&(1!==i.push(u)&&r===n.requestAnimationFrame||((r=n.requestAnimationFrame)||function(n){var t,u=function(){clearTimeout(r),x&&cancelAnimationFrame(t),setTimeout(n)},r=setTimeout(u,100);x&&(t=requestAnimationFrame(u))})(q))},n.__c=function(t,u){u.some(function(t){try{t.__h.forEach(b),t.__h=t.__h.filter(function(n){return!n.__||g(n)})}catch(r){u.some(function(n){n.__h&&(n.__h=[])}),u=[],n.__e(r,t.__v)}}),e&&e(t,u)},n.unmount=function(t){a&&a(t);var u=t.__c;if(u&&u.__H)try{u.__H.__.forEach(b)}catch(t){n.__e(t,u.__v)}};var x="function"==typeof requestAnimationFrame;function b(n){"function"==typeof n.u&&n.u()}function g(n){n.u=n.__()}function j(n,t){return!n||n.length!==t.length||t.some(function(t,u){return t!==n[u]})}function k(n,t){return"function"==typeof t?t(n):t}export{m as useState,p as useReducer,y as useEffect,l as useLayoutEffect,h as useRef,s as useImperativeHandle,_ as useMemo,A as useCallback,F as useContext,T as useDebugValue,d as useErrorBoundary};
 //# sourceMappingURL=hooks.module.js.map
diff --git a/node_modules/preact/hooks/dist/hooks.module.js b/node_modules/preact/hooks/dist/hooks.module.js
index ec31b15..e0b8bcb 100644
--- a/node_modules/preact/hooks/dist/hooks.module.js
+++ b/node_modules/preact/hooks/dist/hooks.module.js
@@ -1,2 +1,2 @@
-import{options as n}from"preact";var t,u,r,o=0,i=[],c=n.__r,f=n.diffed,e=n.__c,a=n.unmount;function v(t,r){n.__h&&n.__h(u,t,o||r),o=0;var i=u.__H||(u.__H={__:[],__h:[]});return t>=i.__.length&&i.__.push({}),i.__[t]}function m(n){return o=1,p(k,n)}function p(n,r,o){var i=v(t++,2);return i.t=n,i.__c||(i.__c=u,i.__=[o?o(r):k(void 0,r),function(n){var t=i.t(i.__[0],n);i.__[0]!==t&&(i.__=[t,i.__[1]],i.__c.setState({}))}]),i.__}function y(r,o){var i=v(t++,3);!n.__s&&j(i.__H,o)&&(i.__=r,i.__H=o,u.__H.__h.push(i))}function l(r,o){var i=v(t++,4);!n.__s&&j(i.__H,o)&&(i.__=r,i.__H=o,u.__h.push(i))}function h(n){return o=5,_(function(){return{current:n}},[])}function s(n,t,u){o=6,l(function(){"function"==typeof n?n(t()):n&&(n.current=t())},null==u?u:u.concat(n))}function _(n,u){var r=v(t++,7);return j(r.__H,u)?(r.__H=u,r.__h=n,r.__=n()):r.__}function A(n,t){return o=8,_(function(){return n},t)}function F(n){var r=u.context[n.__c],o=v(t++,9);return o.__c=n,r?(null==o.__&&(o.__=!0,r.sub(u)),r.props.value):n.__}function T(t,u){n.useDebugValue&&n.useDebugValue(u?u(t):t)}function d(n){var r=v(t++,10),o=m();return r.__=n,u.componentDidCatch||(u.componentDidCatch=function(n){r.__&&r.__(n),o[1](n)}),[o[0],function(){o[1](void 0)}]}function q(){i.some(function(t){if(t.__P)try{t.__H.__h.forEach(b),t.__H.__h.forEach(g),t.__H.__h=[]}catch(u){return t.__H.__h=[],n.__e(u,t.__v),!0}}),i=[]}n.__r=function(n){c&&c(n),t=0;var r=(u=n.__c).__H;r&&(r.__h.forEach(b),r.__h.forEach(g),r.__h=[])},n.diffed=function(t){f&&f(t);var u=t.__c;u&&u.__H&&u.__H.__h.length&&(1!==i.push(u)&&r===n.requestAnimationFrame||((r=n.requestAnimationFrame)||function(n){var t,u=function(){clearTimeout(r),x&&cancelAnimationFrame(t),setTimeout(n)},r=setTimeout(u,100);x&&(t=requestAnimationFrame(u))})(q))},n.__c=function(t,u){u.some(function(t){try{t.__h.forEach(b),t.__h=t.__h.filter(function(n){return!n.__||g(n)})}catch(r){u.some(function(n){n.__h&&(n.__h=[])}),u=[],n.__e(r,t.__v)}}),e&&e(t,u)},n.unmount=function(t){a&&a(t);var u=t.__c;if(u&&u.__H)try{u.__H.__.forEach(b)}catch(t){n.__e(t,u.__v)}};var x="function"==typeof requestAnimationFrame;function b(n){"function"==typeof n.u&&n.u()}function g(n){n.u=n.__()}function j(n,t){return!n||t.some(function(t,u){return t!==n[u]})}function k(n,t){return"function"==typeof t?t(n):t}export{m as useState,p as useReducer,y as useEffect,l as useLayoutEffect,h as useRef,s as useImperativeHandle,_ as useMemo,A as useCallback,F as useContext,T as useDebugValue,d as useErrorBoundary};
+import{options as n}from"preact";var t,u,r,o=0,i=[],c=n.__r,f=n.diffed,e=n.__c,a=n.unmount;function v(t,r){n.__h&&n.__h(u,t,o||r),o=0;var i=u.__H||(u.__H={__:[],__h:[]});return t>=i.__.length&&i.__.push({}),i.__[t]}function m(n){return o=1,p(k,n)}function p(n,r,o){var i=v(t++,2);return i.t=n,i.__c||(i.__c=u,i.__=[o?o(r):k(void 0,r),function(n){var t=i.t(i.__[0],n);i.__[0]!==t&&(i.__=[t,i.__[1]],i.__c.setState({}))}]),i.__}function y(r,o){var i=v(t++,3);!n.__s&&j(i.__H,o)&&(i.__=r,i.__H=o,u.__H.__h.push(i))}function l(r,o){var i=v(t++,4);!n.__s&&j(i.__H,o)&&(i.__=r,i.__H=o,u.__h.push(i))}function h(n){return o=5,_(function(){return{current:n}},[])}function s(n,t,u){o=6,l(function(){"function"==typeof n?n(t()):n&&(n.current=t())},null==u?u:u.concat(n))}function _(n,u){var r=v(t++,7);return j(r.__H,u)?(r.__H=u,r.__h=n,r.__=n()):r.__}function A(n,t){return o=8,_(function(){return n},t)}function F(n){var r=u.context[n.__c],o=v(t++,9);return o.__c=n,r?(null==o.__&&(o.__=!0,r.sub(u)),r.props.value):n.__}function T(t,u){n.useDebugValue&&n.useDebugValue(u?u(t):t)}function d(n){var r=v(t++,10),o=m();return r.__=n,u.componentDidCatch||(u.componentDidCatch=function(n){r.__&&r.__(n),o[1](n)}),[o[0],function(){o[1](void 0)}]}function q(){i.some(function(t){if(t.__P)try{t.__H.__h.forEach(b),t.__H.__h.forEach(g),t.__H.__h=[]}catch(u){return t.__H.__h=[],n.__e(u,t.__v),!0}}),i=[]}n.__r=function(n){c&&c(n),t=0;var r=(u=n.__c).__H;r&&(r.__h.forEach(b),r.__h.forEach(g),r.__h=[])},n.diffed=function(t){f&&f(t);var u=t.__c;u&&u.__H&&u.__H.__h.length&&(1!==i.push(u)&&r===n.requestAnimationFrame||((r=n.requestAnimationFrame)||function(n){var t,u=function(){clearTimeout(r),x&&cancelAnimationFrame(t),setTimeout(n)},r=setTimeout(u,100);x&&(t=requestAnimationFrame(u))})(q))},n.__c=function(t,u){u.some(function(t){try{t.__h.forEach(b),t.__h=t.__h.filter(function(n){return!n.__||g(n)})}catch(r){u.some(function(n){n.__h&&(n.__h=[])}),u=[],n.__e(r,t.__v)}}),e&&e(t,u)},n.unmount=function(t){a&&a(t);var u=t.__c;if(u&&u.__H)try{u.__H.__.forEach(b)}catch(t){n.__e(t,u.__v)}};var x="function"==typeof requestAnimationFrame;function b(n){"function"==typeof n.u&&n.u()}function g(n){n.u=n.__()}function j(n,t){return!n||n.length!==t.length||t.some(function(t,u){return t!==n[u]})}function k(n,t){return"function"==typeof t?t(n):t}export{m as useState,p as useReducer,y as useEffect,l as useLayoutEffect,h as useRef,s as useImperativeHandle,_ as useMemo,A as useCallback,F as useContext,T as useDebugValue,d as useErrorBoundary};
 //# sourceMappingURL=hooks.module.js.map
diff --git a/node_modules/preact/hooks/dist/hooks.module.js.map b/node_modules/preact/hooks/dist/hooks.module.js.map
index c91de1f..bc113dc 100644
--- a/node_modules/preact/hooks/dist/hooks.module.js.map
+++ b/node_modules/preact/hooks/dist/hooks.module.js.map
@@ -1 +1 @@
-{"version":3,"file":"hooks.module.js","sources":["../src/index.js"],"sourcesContent":["import { options } from 'preact';\n\n/** @type {number} */\nlet currentIndex;\n\n/** @type {import('./internal').Component} */\nlet currentComponent;\n\n/** @type {number} */\nlet currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nlet afterPaintEffects = [];\n\nlet oldBeforeRender = options._render;\nlet oldAfterDiff = options.diffed;\nlet oldCommit = options._commit;\nlet oldBeforeUnmount = options.unmount;\n\nconst RAF_TIMEOUT = 100;\nlet prevRaf;\n\noptions._render = vnode => {\n\tif (oldBeforeRender) oldBeforeRender(vnode);\n\n\tcurrentComponent = vnode._component;\n\tcurrentIndex = 0;\n\n\tconst hooks = currentComponent.__hooks;\n\tif (hooks) {\n\t\thooks._pendingEffects.forEach(invokeCleanup);\n\t\thooks._pendingEffects.forEach(invokeEffect);\n\t\thooks._pendingEffects = [];\n\t}\n};\n\noptions.diffed = vnode => {\n\tif (oldAfterDiff) oldAfterDiff(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks && c.__hooks._pendingEffects.length) {\n\t\tafterPaint(afterPaintEffects.push(c));\n\t}\n};\n\noptions._commit = (vnode, commitQueue) => {\n\tcommitQueue.some(component => {\n\t\ttry {\n\t\t\tcomponent._renderCallbacks.forEach(invokeCleanup);\n\t\t\tcomponent._renderCallbacks = component._renderCallbacks.filter(cb =>\n\t\t\t\tcb._value ? invokeEffect(cb) : true\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tcommitQueue.some(c => {\n\t\t\t\tif (c._renderCallbacks) c._renderCallbacks = [];\n\t\t\t});\n\t\t\tcommitQueue = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t});\n\n\tif (oldCommit) oldCommit(vnode, commitQueue);\n};\n\noptions.unmount = vnode => {\n\tif (oldBeforeUnmount) oldBeforeUnmount(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\ttry {\n\t\t\tc.__hooks._list.forEach(invokeCleanup);\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t}\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {import('./internal').HookState}\n */\nfunction getHookState(index, type) {\n\tif (options._hook) {\n\t\toptions._hook(currentComponent, index, currentHook || type);\n\t}\n\tcurrentHook = 0;\n\n\t// Largely inspired by:\n\t// * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n\t// * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n\t// Other implementations to look at:\n\t// * https://codesandbox.io/s/mnox05qp8\n\tconst hooks =\n\t\tcurrentComponent.__hooks ||\n\t\t(currentComponent.__hooks = {\n\t\t\t_list: [],\n\t\t\t_pendingEffects: []\n\t\t});\n\n\tif (index >= hooks._list.length) {\n\t\thooks._list.push({});\n\t}\n\treturn hooks._list[index];\n}\n\n/**\n * @param {import('./index').StateUpdater<any>} initialState\n */\nexport function useState(initialState) {\n\tcurrentHook = 1;\n\treturn useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @param {import('./index').Reducer<any, any>} reducer\n * @param {import('./index').StateUpdater<any>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ any, (state: any) => void ]}\n */\nexport function useReducer(reducer, initialState, init) {\n\t/** @type {import('./internal').ReducerHookState} */\n\tconst hookState = getHookState(currentIndex++, 2);\n\thookState._reducer = reducer;\n\tif (!hookState._component) {\n\t\thookState._component = currentComponent;\n\n\t\thookState._value = [\n\t\t\t!init ? invokeOrReturn(undefined, initialState) : init(initialState),\n\n\t\t\taction => {\n\t\t\t\tconst nextValue = hookState._reducer(hookState._value[0], action);\n\t\t\t\tif (hookState._value[0] !== nextValue) {\n\t\t\t\t\thookState._value = [nextValue, hookState._value[1]];\n\t\t\t\t\thookState._component.setState({});\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\t}\n\n\treturn hookState._value;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {any[]} args\n */\nexport function useEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 3);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._args = args;\n\n\t\tcurrentComponent.__hooks._pendingEffects.push(state);\n\t}\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {any[]} args\n */\nexport function useLayoutEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 4);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._args = args;\n\n\t\tcurrentComponent._renderCallbacks.push(state);\n\t}\n}\n\nexport function useRef(initialValue) {\n\tcurrentHook = 5;\n\treturn useMemo(() => ({ current: initialValue }), []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {any[]} args\n */\nexport function useImperativeHandle(ref, createHandle, args) {\n\tcurrentHook = 6;\n\tuseLayoutEffect(\n\t\t() => {\n\t\t\tif (typeof ref == 'function') ref(createHandle());\n\t\t\telse if (ref) ref.current = createHandle();\n\t\t},\n\t\targs == null ? args : args.concat(ref)\n\t);\n}\n\n/**\n * @param {() => any} factory\n * @param {any[]} args\n */\nexport function useMemo(factory, args) {\n\t/** @type {import('./internal').MemoHookState} */\n\tconst state = getHookState(currentIndex++, 7);\n\tif (argsChanged(state._args, args)) {\n\t\tstate._args = args;\n\t\tstate._factory = factory;\n\t\treturn (state._value = factory());\n\t}\n\n\treturn state._value;\n}\n\n/**\n * @param {() => void} callback\n * @param {any[]} args\n */\nexport function useCallback(callback, args) {\n\tcurrentHook = 8;\n\treturn useMemo(() => callback, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nexport function useContext(context) {\n\tconst provider = currentComponent.context[context._id];\n\t// We could skip this call here, but than we'd not call\n\t// `options._hook`. We need to do that in order to make\n\t// the devtools aware of this hook.\n\tconst state = getHookState(currentIndex++, 9);\n\t// The devtools needs access to the context object to\n\t// be able to pull of the default value when no provider\n\t// is present in the tree.\n\tstate._context = context;\n\tif (!provider) return context._defaultValue;\n\t// This is probably not safe to convert to \"!\"\n\tif (state._value == null) {\n\t\tstate._value = true;\n\t\tprovider.sub(currentComponent);\n\t}\n\treturn provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nexport function useDebugValue(value, formatter) {\n\tif (options.useDebugValue) {\n\t\toptions.useDebugValue(formatter ? formatter(value) : value);\n\t}\n}\n\nexport function useErrorBoundary(cb) {\n\tconst state = getHookState(currentIndex++, 10);\n\tconst errState = useState();\n\tstate._value = cb;\n\tif (!currentComponent.componentDidCatch) {\n\t\tcurrentComponent.componentDidCatch = err => {\n\t\t\tif (state._value) state._value(err);\n\t\t\terrState[1](err);\n\t\t};\n\t}\n\treturn [\n\t\terrState[0],\n\t\t() => {\n\t\t\terrState[1](undefined);\n\t\t}\n\t];\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n\tafterPaintEffects.some(component => {\n\t\tif (component._parentDom) {\n\t\t\ttry {\n\t\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\t} catch (e) {\n\t\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\t\toptions._catchError(e, component._vnode);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t});\n\tafterPaintEffects = [];\n}\n\nlet HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tif (HAS_RAF) cancelAnimationFrame(raf);\n\t\tsetTimeout(callback);\n\t};\n\tconst timeout = setTimeout(done, RAF_TIMEOUT);\n\n\tlet raf;\n\tif (HAS_RAF) {\n\t\traf = requestAnimationFrame(done);\n\t}\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n */\nfunction afterPaint(newQueueLength) {\n\tif (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n\t\tprevRaf = options.requestAnimationFrame;\n\t\t(prevRaf || afterNextFrame)(flushAfterPaintEffects);\n\t}\n}\n\n/**\n * @param {import('./internal').EffectHookState} hook\n */\nfunction invokeCleanup(hook) {\n\tif (typeof hook._cleanup == 'function') hook._cleanup();\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n */\nfunction invokeEffect(hook) {\n\thook._cleanup = hook._value();\n}\n\n/**\n * @param {any[]} oldArgs\n * @param {any[]} newArgs\n */\nfunction argsChanged(oldArgs, newArgs) {\n\treturn !oldArgs || newArgs.some((arg, index) => arg !== oldArgs[index]);\n}\n\nfunction invokeOrReturn(arg, f) {\n\treturn typeof f == 'function' ? f(arg) : f;\n}\n"],"names":["currentIndex","currentComponent","prevRaf","currentHook","afterPaintEffects","oldBeforeRender","options","oldAfterDiff","diffed","oldCommit","oldBeforeUnmount","unmount","getHookState","index","type","hooks","length","push","useState","initialState","useReducer","invokeOrReturn","reducer","init","hookState","_reducer","undefined","action","nextValue","setState","useEffect","callback","args","state","argsChanged","useLayoutEffect","useRef","initialValue","useMemo","current","useImperativeHandle","ref","createHandle","concat","factory","useCallback","useContext","context","provider","sub","props","value","useDebugValue","formatter","useErrorBoundary","cb","errState","componentDidCatch","err","flushAfterPaintEffects","some","component","forEach","invokeCleanup","invokeEffect","e","vnode","c","requestAnimationFrame","raf","done","clearTimeout","timeout","HAS_RAF","cancelAnimationFrame","setTimeout","commitQueue","filter","hook","_cleanup","oldArgs","newArgs","arg","f"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"hooks.module.js","sources":["../src/index.js"],"sourcesContent":["import { options } from 'preact';\n\n/** @type {number} */\nlet currentIndex;\n\n/** @type {import('./internal').Component} */\nlet currentComponent;\n\n/** @type {number} */\nlet currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nlet afterPaintEffects = [];\n\nlet oldBeforeRender = options._render;\nlet oldAfterDiff = options.diffed;\nlet oldCommit = options._commit;\nlet oldBeforeUnmount = options.unmount;\n\nconst RAF_TIMEOUT = 100;\nlet prevRaf;\n\noptions._render = vnode => {\n\tif (oldBeforeRender) oldBeforeRender(vnode);\n\n\tcurrentComponent = vnode._component;\n\tcurrentIndex = 0;\n\n\tconst hooks = currentComponent.__hooks;\n\tif (hooks) {\n\t\thooks._pendingEffects.forEach(invokeCleanup);\n\t\thooks._pendingEffects.forEach(invokeEffect);\n\t\thooks._pendingEffects = [];\n\t}\n};\n\noptions.diffed = vnode => {\n\tif (oldAfterDiff) oldAfterDiff(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks && c.__hooks._pendingEffects.length) {\n\t\tafterPaint(afterPaintEffects.push(c));\n\t}\n};\n\noptions._commit = (vnode, commitQueue) => {\n\tcommitQueue.some(component => {\n\t\ttry {\n\t\t\tcomponent._renderCallbacks.forEach(invokeCleanup);\n\t\t\tcomponent._renderCallbacks = component._renderCallbacks.filter(cb =>\n\t\t\t\tcb._value ? invokeEffect(cb) : true\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tcommitQueue.some(c => {\n\t\t\t\tif (c._renderCallbacks) c._renderCallbacks = [];\n\t\t\t});\n\t\t\tcommitQueue = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t});\n\n\tif (oldCommit) oldCommit(vnode, commitQueue);\n};\n\noptions.unmount = vnode => {\n\tif (oldBeforeUnmount) oldBeforeUnmount(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\ttry {\n\t\t\tc.__hooks._list.forEach(invokeCleanup);\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t}\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {import('./internal').HookState}\n */\nfunction getHookState(index, type) {\n\tif (options._hook) {\n\t\toptions._hook(currentComponent, index, currentHook || type);\n\t}\n\tcurrentHook = 0;\n\n\t// Largely inspired by:\n\t// * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n\t// * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n\t// Other implementations to look at:\n\t// * https://codesandbox.io/s/mnox05qp8\n\tconst hooks =\n\t\tcurrentComponent.__hooks ||\n\t\t(currentComponent.__hooks = {\n\t\t\t_list: [],\n\t\t\t_pendingEffects: []\n\t\t});\n\n\tif (index >= hooks._list.length) {\n\t\thooks._list.push({});\n\t}\n\treturn hooks._list[index];\n}\n\n/**\n * @param {import('./index').StateUpdater<any>} initialState\n */\nexport function useState(initialState) {\n\tcurrentHook = 1;\n\treturn useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @param {import('./index').Reducer<any, any>} reducer\n * @param {import('./index').StateUpdater<any>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ any, (state: any) => void ]}\n */\nexport function useReducer(reducer, initialState, init) {\n\t/** @type {import('./internal').ReducerHookState} */\n\tconst hookState = getHookState(currentIndex++, 2);\n\thookState._reducer = reducer;\n\tif (!hookState._component) {\n\t\thookState._component = currentComponent;\n\n\t\thookState._value = [\n\t\t\t!init ? invokeOrReturn(undefined, initialState) : init(initialState),\n\n\t\t\taction => {\n\t\t\t\tconst nextValue = hookState._reducer(hookState._value[0], action);\n\t\t\t\tif (hookState._value[0] !== nextValue) {\n\t\t\t\t\thookState._value = [nextValue, hookState._value[1]];\n\t\t\t\t\thookState._component.setState({});\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\t}\n\n\treturn hookState._value;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {any[]} args\n */\nexport function useEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 3);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._args = args;\n\n\t\tcurrentComponent.__hooks._pendingEffects.push(state);\n\t}\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {any[]} args\n */\nexport function useLayoutEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 4);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._args = args;\n\n\t\tcurrentComponent._renderCallbacks.push(state);\n\t}\n}\n\nexport function useRef(initialValue) {\n\tcurrentHook = 5;\n\treturn useMemo(() => ({ current: initialValue }), []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {any[]} args\n */\nexport function useImperativeHandle(ref, createHandle, args) {\n\tcurrentHook = 6;\n\tuseLayoutEffect(\n\t\t() => {\n\t\t\tif (typeof ref == 'function') ref(createHandle());\n\t\t\telse if (ref) ref.current = createHandle();\n\t\t},\n\t\targs == null ? args : args.concat(ref)\n\t);\n}\n\n/**\n * @param {() => any} factory\n * @param {any[]} args\n */\nexport function useMemo(factory, args) {\n\t/** @type {import('./internal').MemoHookState} */\n\tconst state = getHookState(currentIndex++, 7);\n\tif (argsChanged(state._args, args)) {\n\t\tstate._args = args;\n\t\tstate._factory = factory;\n\t\treturn (state._value = factory());\n\t}\n\n\treturn state._value;\n}\n\n/**\n * @param {() => void} callback\n * @param {any[]} args\n */\nexport function useCallback(callback, args) {\n\tcurrentHook = 8;\n\treturn useMemo(() => callback, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nexport function useContext(context) {\n\tconst provider = currentComponent.context[context._id];\n\t// We could skip this call here, but than we'd not call\n\t// `options._hook`. We need to do that in order to make\n\t// the devtools aware of this hook.\n\tconst state = getHookState(currentIndex++, 9);\n\t// The devtools needs access to the context object to\n\t// be able to pull of the default value when no provider\n\t// is present in the tree.\n\tstate._context = context;\n\tif (!provider) return context._defaultValue;\n\t// This is probably not safe to convert to \"!\"\n\tif (state._value == null) {\n\t\tstate._value = true;\n\t\tprovider.sub(currentComponent);\n\t}\n\treturn provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nexport function useDebugValue(value, formatter) {\n\tif (options.useDebugValue) {\n\t\toptions.useDebugValue(formatter ? formatter(value) : value);\n\t}\n}\n\nexport function useErrorBoundary(cb) {\n\tconst state = getHookState(currentIndex++, 10);\n\tconst errState = useState();\n\tstate._value = cb;\n\tif (!currentComponent.componentDidCatch) {\n\t\tcurrentComponent.componentDidCatch = err => {\n\t\t\tif (state._value) state._value(err);\n\t\t\terrState[1](err);\n\t\t};\n\t}\n\treturn [\n\t\terrState[0],\n\t\t() => {\n\t\t\terrState[1](undefined);\n\t\t}\n\t];\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n\tafterPaintEffects.some(component => {\n\t\tif (component._parentDom) {\n\t\t\ttry {\n\t\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\t} catch (e) {\n\t\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\t\toptions._catchError(e, component._vnode);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t});\n\tafterPaintEffects = [];\n}\n\nlet HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tif (HAS_RAF) cancelAnimationFrame(raf);\n\t\tsetTimeout(callback);\n\t};\n\tconst timeout = setTimeout(done, RAF_TIMEOUT);\n\n\tlet raf;\n\tif (HAS_RAF) {\n\t\traf = requestAnimationFrame(done);\n\t}\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n */\nfunction afterPaint(newQueueLength) {\n\tif (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n\t\tprevRaf = options.requestAnimationFrame;\n\t\t(prevRaf || afterNextFrame)(flushAfterPaintEffects);\n\t}\n}\n\n/**\n * @param {import('./internal').EffectHookState} hook\n */\nfunction invokeCleanup(hook) {\n\tif (typeof hook._cleanup == 'function') hook._cleanup();\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n */\nfunction invokeEffect(hook) {\n\thook._cleanup = hook._value();\n}\n\n/**\n * @param {any[]} oldArgs\n * @param {any[]} newArgs\n */\nfunction argsChanged(oldArgs, newArgs) {\n\treturn !oldArgs || oldArgs.length !== newArgs.length || newArgs.some((arg, index) => arg !== oldArgs[index]);\n}\n\nfunction invokeOrReturn(arg, f) {\n\treturn typeof f == 'function' ? f(arg) : f;\n}\n"],"names":["currentIndex","currentComponent","prevRaf","currentHook","afterPaintEffects","oldBeforeRender","options","oldAfterDiff","diffed","oldCommit","oldBeforeUnmount","unmount","getHookState","index","type","hooks","length","push","useState","initialState","useReducer","invokeOrReturn","reducer","init","hookState","_reducer","undefined","action","nextValue","setState","useEffect","callback","args","state","argsChanged","useLayoutEffect","useRef","initialValue","useMemo","current","useImperativeHandle","ref","createHandle","concat","factory","useCallback","useContext","context","provider","sub","props","value","useDebugValue","formatter","useErrorBoundary","cb","errState","componentDidCatch","err","flushAfterPaintEffects","some","component","forEach","invokeCleanup","invokeEffect","e","vnode","c","requestAnimationFrame","raf","done","clearTimeout","timeout","HAS_RAF","cancelAnimationFrame","setTimeout","commitQueue","filter","hook","_cleanup","oldArgs","newArgs","arg","f"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/preact/hooks/dist/hooks.umd.js b/node_modules/preact/hooks/dist/hooks.umd.js
index a8741d0..ab4ab6c 100644
--- a/node_modules/preact/hooks/dist/hooks.umd.js
+++ b/node_modules/preact/hooks/dist/hooks.umd.js
@@ -1,2 +1,2 @@
-!function(n,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("preact")):"function"==typeof define&&define.amd?define(["exports","preact"],t):t(n.preactHooks={},n.preact)}(this,function(n,t){var u,r,o,i=0,c=[],e=t.options.__r,f=t.options.diffed,a=t.options.__c,v=t.options.unmount;function p(n,u){t.options.__h&&t.options.__h(r,n,i||u),i=0;var o=r.__H||(r.__H={__:[],__h:[]});return n>=o.__.length&&o.__.push({}),o.__[n]}function m(n){return i=1,y(A,n)}function y(n,t,o){var i=p(u++,2);return i.t=n,i.__c||(i.__c=r,i.__=[o?o(t):A(void 0,t),function(n){var t=i.t(i.__[0],n);i.__[0]!==t&&(i.__=[t,i.__[1]],i.__c.setState({}))}]),i.__}function d(n,o){var i=p(u++,4);!t.options.__s&&x(i.__H,o)&&(i.__=n,i.__H=o,r.__h.push(i))}function s(n,t){var r=p(u++,7);return x(r.__H,t)?(r.__H=t,r.__h=n,r.__=n()):r.__}function l(){c.some(function(n){if(n.__P)try{n.__H.__h.forEach(_),n.__H.__h.forEach(q),n.__H.__h=[]}catch(u){return n.__H.__h=[],t.options.__e(u,n.__v),!0}}),c=[]}t.options.__r=function(n){e&&e(n),u=0;var t=(r=n.__c).__H;t&&(t.__h.forEach(_),t.__h.forEach(q),t.__h=[])},t.options.diffed=function(n){f&&f(n);var u=n.__c;u&&u.__H&&u.__H.__h.length&&(1!==c.push(u)&&o===t.options.requestAnimationFrame||((o=t.options.requestAnimationFrame)||function(n){var t,u=function(){clearTimeout(r),h&&cancelAnimationFrame(t),setTimeout(n)},r=setTimeout(u,100);h&&(t=requestAnimationFrame(u))})(l))},t.options.__c=function(n,u){u.some(function(n){try{n.__h.forEach(_),n.__h=n.__h.filter(function(n){return!n.__||q(n)})}catch(r){u.some(function(n){n.__h&&(n.__h=[])}),u=[],t.options.__e(r,n.__v)}}),a&&a(n,u)},t.options.unmount=function(n){v&&v(n);var u=n.__c;if(u&&u.__H)try{u.__H.__.forEach(_)}catch(n){t.options.__e(n,u.__v)}};var h="function"==typeof requestAnimationFrame;function _(n){"function"==typeof n.u&&n.u()}function q(n){n.u=n.__()}function x(n,t){return!n||t.some(function(t,u){return t!==n[u]})}function A(n,t){return"function"==typeof t?t(n):t}n.useState=m,n.useReducer=y,n.useEffect=function(n,o){var i=p(u++,3);!t.options.__s&&x(i.__H,o)&&(i.__=n,i.__H=o,r.__H.__h.push(i))},n.useLayoutEffect=d,n.useRef=function(n){return i=5,s(function(){return{current:n}},[])},n.useImperativeHandle=function(n,t,u){i=6,d(function(){"function"==typeof n?n(t()):n&&(n.current=t())},null==u?u:u.concat(n))},n.useMemo=s,n.useCallback=function(n,t){return i=8,s(function(){return n},t)},n.useContext=function(n){var t=r.context[n.__c],o=p(u++,9);return o.__c=n,t?(null==o.__&&(o.__=!0,t.sub(r)),t.props.value):n.__},n.useDebugValue=function(n,u){t.options.useDebugValue&&t.options.useDebugValue(u?u(n):n)},n.useErrorBoundary=function(n){var t=p(u++,10),o=m();return t.__=n,r.componentDidCatch||(r.componentDidCatch=function(n){t.__&&t.__(n),o[1](n)}),[o[0],function(){o[1](void 0)}]}});
+!function(n,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("preact")):"function"==typeof define&&define.amd?define(["exports","preact"],t):t(n.preactHooks={},n.preact)}(this,function(n,t){var u,r,o,i=0,c=[],e=t.options.__r,f=t.options.diffed,a=t.options.__c,v=t.options.unmount;function p(n,u){t.options.__h&&t.options.__h(r,n,i||u),i=0;var o=r.__H||(r.__H={__:[],__h:[]});return n>=o.__.length&&o.__.push({}),o.__[n]}function m(n){return i=1,y(A,n)}function y(n,t,o){var i=p(u++,2);return i.t=n,i.__c||(i.__c=r,i.__=[o?o(t):A(void 0,t),function(n){var t=i.t(i.__[0],n);i.__[0]!==t&&(i.__=[t,i.__[1]],i.__c.setState({}))}]),i.__}function d(n,o){var i=p(u++,4);!t.options.__s&&x(i.__H,o)&&(i.__=n,i.__H=o,r.__h.push(i))}function s(n,t){var r=p(u++,7);return x(r.__H,t)?(r.__H=t,r.__h=n,r.__=n()):r.__}function l(){c.some(function(n){if(n.__P)try{n.__H.__h.forEach(_),n.__H.__h.forEach(q),n.__H.__h=[]}catch(u){return n.__H.__h=[],t.options.__e(u,n.__v),!0}}),c=[]}t.options.__r=function(n){e&&e(n),u=0;var t=(r=n.__c).__H;t&&(t.__h.forEach(_),t.__h.forEach(q),t.__h=[])},t.options.diffed=function(n){f&&f(n);var u=n.__c;u&&u.__H&&u.__H.__h.length&&(1!==c.push(u)&&o===t.options.requestAnimationFrame||((o=t.options.requestAnimationFrame)||function(n){var t,u=function(){clearTimeout(r),h&&cancelAnimationFrame(t),setTimeout(n)},r=setTimeout(u,100);h&&(t=requestAnimationFrame(u))})(l))},t.options.__c=function(n,u){u.some(function(n){try{n.__h.forEach(_),n.__h=n.__h.filter(function(n){return!n.__||q(n)})}catch(r){u.some(function(n){n.__h&&(n.__h=[])}),u=[],t.options.__e(r,n.__v)}}),a&&a(n,u)},t.options.unmount=function(n){v&&v(n);var u=n.__c;if(u&&u.__H)try{u.__H.__.forEach(_)}catch(n){t.options.__e(n,u.__v)}};var h="function"==typeof requestAnimationFrame;function _(n){"function"==typeof n.u&&n.u()}function q(n){n.u=n.__()}function x(n,t){return!n||n.length!==t.length||t.some(function(t,u){return t!==n[u]})}function A(n,t){return"function"==typeof t?t(n):t}n.useState=m,n.useReducer=y,n.useEffect=function(n,o){var i=p(u++,3);!t.options.__s&&x(i.__H,o)&&(i.__=n,i.__H=o,r.__H.__h.push(i))},n.useLayoutEffect=d,n.useRef=function(n){return i=5,s(function(){return{current:n}},[])},n.useImperativeHandle=function(n,t,u){i=6,d(function(){"function"==typeof n?n(t()):n&&(n.current=t())},null==u?u:u.concat(n))},n.useMemo=s,n.useCallback=function(n,t){return i=8,s(function(){return n},t)},n.useContext=function(n){var t=r.context[n.__c],o=p(u++,9);return o.__c=n,t?(null==o.__&&(o.__=!0,t.sub(r)),t.props.value):n.__},n.useDebugValue=function(n,u){t.options.useDebugValue&&t.options.useDebugValue(u?u(n):n)},n.useErrorBoundary=function(n){var t=p(u++,10),o=m();return t.__=n,r.componentDidCatch||(r.componentDidCatch=function(n){t.__&&t.__(n),o[1](n)}),[o[0],function(){o[1](void 0)}]}});
 //# sourceMappingURL=hooks.umd.js.map
diff --git a/node_modules/preact/hooks/dist/hooks.umd.js.map b/node_modules/preact/hooks/dist/hooks.umd.js.map
index 10b7360..752cfff 100644
--- a/node_modules/preact/hooks/dist/hooks.umd.js.map
+++ b/node_modules/preact/hooks/dist/hooks.umd.js.map
@@ -1 +1 @@
-{"version":3,"file":"hooks.umd.js","sources":["../src/index.js"],"sourcesContent":["import { options } from 'preact';\n\n/** @type {number} */\nlet currentIndex;\n\n/** @type {import('./internal').Component} */\nlet currentComponent;\n\n/** @type {number} */\nlet currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nlet afterPaintEffects = [];\n\nlet oldBeforeRender = options._render;\nlet oldAfterDiff = options.diffed;\nlet oldCommit = options._commit;\nlet oldBeforeUnmount = options.unmount;\n\nconst RAF_TIMEOUT = 100;\nlet prevRaf;\n\noptions._render = vnode => {\n\tif (oldBeforeRender) oldBeforeRender(vnode);\n\n\tcurrentComponent = vnode._component;\n\tcurrentIndex = 0;\n\n\tconst hooks = currentComponent.__hooks;\n\tif (hooks) {\n\t\thooks._pendingEffects.forEach(invokeCleanup);\n\t\thooks._pendingEffects.forEach(invokeEffect);\n\t\thooks._pendingEffects = [];\n\t}\n};\n\noptions.diffed = vnode => {\n\tif (oldAfterDiff) oldAfterDiff(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks && c.__hooks._pendingEffects.length) {\n\t\tafterPaint(afterPaintEffects.push(c));\n\t}\n};\n\noptions._commit = (vnode, commitQueue) => {\n\tcommitQueue.some(component => {\n\t\ttry {\n\t\t\tcomponent._renderCallbacks.forEach(invokeCleanup);\n\t\t\tcomponent._renderCallbacks = component._renderCallbacks.filter(cb =>\n\t\t\t\tcb._value ? invokeEffect(cb) : true\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tcommitQueue.some(c => {\n\t\t\t\tif (c._renderCallbacks) c._renderCallbacks = [];\n\t\t\t});\n\t\t\tcommitQueue = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t});\n\n\tif (oldCommit) oldCommit(vnode, commitQueue);\n};\n\noptions.unmount = vnode => {\n\tif (oldBeforeUnmount) oldBeforeUnmount(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\ttry {\n\t\t\tc.__hooks._list.forEach(invokeCleanup);\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t}\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {import('./internal').HookState}\n */\nfunction getHookState(index, type) {\n\tif (options._hook) {\n\t\toptions._hook(currentComponent, index, currentHook || type);\n\t}\n\tcurrentHook = 0;\n\n\t// Largely inspired by:\n\t// * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n\t// * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n\t// Other implementations to look at:\n\t// * https://codesandbox.io/s/mnox05qp8\n\tconst hooks =\n\t\tcurrentComponent.__hooks ||\n\t\t(currentComponent.__hooks = {\n\t\t\t_list: [],\n\t\t\t_pendingEffects: []\n\t\t});\n\n\tif (index >= hooks._list.length) {\n\t\thooks._list.push({});\n\t}\n\treturn hooks._list[index];\n}\n\n/**\n * @param {import('./index').StateUpdater<any>} initialState\n */\nexport function useState(initialState) {\n\tcurrentHook = 1;\n\treturn useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @param {import('./index').Reducer<any, any>} reducer\n * @param {import('./index').StateUpdater<any>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ any, (state: any) => void ]}\n */\nexport function useReducer(reducer, initialState, init) {\n\t/** @type {import('./internal').ReducerHookState} */\n\tconst hookState = getHookState(currentIndex++, 2);\n\thookState._reducer = reducer;\n\tif (!hookState._component) {\n\t\thookState._component = currentComponent;\n\n\t\thookState._value = [\n\t\t\t!init ? invokeOrReturn(undefined, initialState) : init(initialState),\n\n\t\t\taction => {\n\t\t\t\tconst nextValue = hookState._reducer(hookState._value[0], action);\n\t\t\t\tif (hookState._value[0] !== nextValue) {\n\t\t\t\t\thookState._value = [nextValue, hookState._value[1]];\n\t\t\t\t\thookState._component.setState({});\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\t}\n\n\treturn hookState._value;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {any[]} args\n */\nexport function useEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 3);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._args = args;\n\n\t\tcurrentComponent.__hooks._pendingEffects.push(state);\n\t}\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {any[]} args\n */\nexport function useLayoutEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 4);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._args = args;\n\n\t\tcurrentComponent._renderCallbacks.push(state);\n\t}\n}\n\nexport function useRef(initialValue) {\n\tcurrentHook = 5;\n\treturn useMemo(() => ({ current: initialValue }), []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {any[]} args\n */\nexport function useImperativeHandle(ref, createHandle, args) {\n\tcurrentHook = 6;\n\tuseLayoutEffect(\n\t\t() => {\n\t\t\tif (typeof ref == 'function') ref(createHandle());\n\t\t\telse if (ref) ref.current = createHandle();\n\t\t},\n\t\targs == null ? args : args.concat(ref)\n\t);\n}\n\n/**\n * @param {() => any} factory\n * @param {any[]} args\n */\nexport function useMemo(factory, args) {\n\t/** @type {import('./internal').MemoHookState} */\n\tconst state = getHookState(currentIndex++, 7);\n\tif (argsChanged(state._args, args)) {\n\t\tstate._args = args;\n\t\tstate._factory = factory;\n\t\treturn (state._value = factory());\n\t}\n\n\treturn state._value;\n}\n\n/**\n * @param {() => void} callback\n * @param {any[]} args\n */\nexport function useCallback(callback, args) {\n\tcurrentHook = 8;\n\treturn useMemo(() => callback, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nexport function useContext(context) {\n\tconst provider = currentComponent.context[context._id];\n\t// We could skip this call here, but than we'd not call\n\t// `options._hook`. We need to do that in order to make\n\t// the devtools aware of this hook.\n\tconst state = getHookState(currentIndex++, 9);\n\t// The devtools needs access to the context object to\n\t// be able to pull of the default value when no provider\n\t// is present in the tree.\n\tstate._context = context;\n\tif (!provider) return context._defaultValue;\n\t// This is probably not safe to convert to \"!\"\n\tif (state._value == null) {\n\t\tstate._value = true;\n\t\tprovider.sub(currentComponent);\n\t}\n\treturn provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nexport function useDebugValue(value, formatter) {\n\tif (options.useDebugValue) {\n\t\toptions.useDebugValue(formatter ? formatter(value) : value);\n\t}\n}\n\nexport function useErrorBoundary(cb) {\n\tconst state = getHookState(currentIndex++, 10);\n\tconst errState = useState();\n\tstate._value = cb;\n\tif (!currentComponent.componentDidCatch) {\n\t\tcurrentComponent.componentDidCatch = err => {\n\t\t\tif (state._value) state._value(err);\n\t\t\terrState[1](err);\n\t\t};\n\t}\n\treturn [\n\t\terrState[0],\n\t\t() => {\n\t\t\terrState[1](undefined);\n\t\t}\n\t];\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n\tafterPaintEffects.some(component => {\n\t\tif (component._parentDom) {\n\t\t\ttry {\n\t\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\t} catch (e) {\n\t\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\t\toptions._catchError(e, component._vnode);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t});\n\tafterPaintEffects = [];\n}\n\nlet HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tif (HAS_RAF) cancelAnimationFrame(raf);\n\t\tsetTimeout(callback);\n\t};\n\tconst timeout = setTimeout(done, RAF_TIMEOUT);\n\n\tlet raf;\n\tif (HAS_RAF) {\n\t\traf = requestAnimationFrame(done);\n\t}\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n */\nfunction afterPaint(newQueueLength) {\n\tif (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n\t\tprevRaf = options.requestAnimationFrame;\n\t\t(prevRaf || afterNextFrame)(flushAfterPaintEffects);\n\t}\n}\n\n/**\n * @param {import('./internal').EffectHookState} hook\n */\nfunction invokeCleanup(hook) {\n\tif (typeof hook._cleanup == 'function') hook._cleanup();\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n */\nfunction invokeEffect(hook) {\n\thook._cleanup = hook._value();\n}\n\n/**\n * @param {any[]} oldArgs\n * @param {any[]} newArgs\n */\nfunction argsChanged(oldArgs, newArgs) {\n\treturn !oldArgs || newArgs.some((arg, index) => arg !== oldArgs[index]);\n}\n\nfunction invokeOrReturn(arg, f) {\n\treturn typeof f == 'function' ? f(arg) : f;\n}\n"],"names":["currentIndex","currentComponent","prevRaf","currentHook","afterPaintEffects","oldBeforeRender","options","oldAfterDiff","diffed","oldCommit","oldBeforeUnmount","unmount","getHookState","index","type","hooks","length","push","useState","initialState","useReducer","invokeOrReturn","reducer","init","hookState","_reducer","undefined","action","nextValue","setState","useLayoutEffect","callback","args","state","argsChanged","useMemo","factory","flushAfterPaintEffects","some","component","forEach","invokeCleanup","invokeEffect","e","vnode","c","requestAnimationFrame","raf","done","clearTimeout","timeout","HAS_RAF","cancelAnimationFrame","setTimeout","commitQueue","filter","cb","hook","_cleanup","oldArgs","newArgs","arg","f","initialValue","current","ref","createHandle","concat","context","provider","sub","props","value","formatter","useDebugValue","errState","componentDidCatch","err"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"hooks.umd.js","sources":["../src/index.js"],"sourcesContent":["import { options } from 'preact';\n\n/** @type {number} */\nlet currentIndex;\n\n/** @type {import('./internal').Component} */\nlet currentComponent;\n\n/** @type {number} */\nlet currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nlet afterPaintEffects = [];\n\nlet oldBeforeRender = options._render;\nlet oldAfterDiff = options.diffed;\nlet oldCommit = options._commit;\nlet oldBeforeUnmount = options.unmount;\n\nconst RAF_TIMEOUT = 100;\nlet prevRaf;\n\noptions._render = vnode => {\n\tif (oldBeforeRender) oldBeforeRender(vnode);\n\n\tcurrentComponent = vnode._component;\n\tcurrentIndex = 0;\n\n\tconst hooks = currentComponent.__hooks;\n\tif (hooks) {\n\t\thooks._pendingEffects.forEach(invokeCleanup);\n\t\thooks._pendingEffects.forEach(invokeEffect);\n\t\thooks._pendingEffects = [];\n\t}\n};\n\noptions.diffed = vnode => {\n\tif (oldAfterDiff) oldAfterDiff(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks && c.__hooks._pendingEffects.length) {\n\t\tafterPaint(afterPaintEffects.push(c));\n\t}\n};\n\noptions._commit = (vnode, commitQueue) => {\n\tcommitQueue.some(component => {\n\t\ttry {\n\t\t\tcomponent._renderCallbacks.forEach(invokeCleanup);\n\t\t\tcomponent._renderCallbacks = component._renderCallbacks.filter(cb =>\n\t\t\t\tcb._value ? invokeEffect(cb) : true\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tcommitQueue.some(c => {\n\t\t\t\tif (c._renderCallbacks) c._renderCallbacks = [];\n\t\t\t});\n\t\t\tcommitQueue = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t});\n\n\tif (oldCommit) oldCommit(vnode, commitQueue);\n};\n\noptions.unmount = vnode => {\n\tif (oldBeforeUnmount) oldBeforeUnmount(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\ttry {\n\t\t\tc.__hooks._list.forEach(invokeCleanup);\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, c._vnode);\n\t\t}\n\t}\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {import('./internal').HookState}\n */\nfunction getHookState(index, type) {\n\tif (options._hook) {\n\t\toptions._hook(currentComponent, index, currentHook || type);\n\t}\n\tcurrentHook = 0;\n\n\t// Largely inspired by:\n\t// * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n\t// * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n\t// Other implementations to look at:\n\t// * https://codesandbox.io/s/mnox05qp8\n\tconst hooks =\n\t\tcurrentComponent.__hooks ||\n\t\t(currentComponent.__hooks = {\n\t\t\t_list: [],\n\t\t\t_pendingEffects: []\n\t\t});\n\n\tif (index >= hooks._list.length) {\n\t\thooks._list.push({});\n\t}\n\treturn hooks._list[index];\n}\n\n/**\n * @param {import('./index').StateUpdater<any>} initialState\n */\nexport function useState(initialState) {\n\tcurrentHook = 1;\n\treturn useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @param {import('./index').Reducer<any, any>} reducer\n * @param {import('./index').StateUpdater<any>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ any, (state: any) => void ]}\n */\nexport function useReducer(reducer, initialState, init) {\n\t/** @type {import('./internal').ReducerHookState} */\n\tconst hookState = getHookState(currentIndex++, 2);\n\thookState._reducer = reducer;\n\tif (!hookState._component) {\n\t\thookState._component = currentComponent;\n\n\t\thookState._value = [\n\t\t\t!init ? invokeOrReturn(undefined, initialState) : init(initialState),\n\n\t\t\taction => {\n\t\t\t\tconst nextValue = hookState._reducer(hookState._value[0], action);\n\t\t\t\tif (hookState._value[0] !== nextValue) {\n\t\t\t\t\thookState._value = [nextValue, hookState._value[1]];\n\t\t\t\t\thookState._component.setState({});\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\t}\n\n\treturn hookState._value;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {any[]} args\n */\nexport function useEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 3);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._args = args;\n\n\t\tcurrentComponent.__hooks._pendingEffects.push(state);\n\t}\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {any[]} args\n */\nexport function useLayoutEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 4);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._args = args;\n\n\t\tcurrentComponent._renderCallbacks.push(state);\n\t}\n}\n\nexport function useRef(initialValue) {\n\tcurrentHook = 5;\n\treturn useMemo(() => ({ current: initialValue }), []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {any[]} args\n */\nexport function useImperativeHandle(ref, createHandle, args) {\n\tcurrentHook = 6;\n\tuseLayoutEffect(\n\t\t() => {\n\t\t\tif (typeof ref == 'function') ref(createHandle());\n\t\t\telse if (ref) ref.current = createHandle();\n\t\t},\n\t\targs == null ? args : args.concat(ref)\n\t);\n}\n\n/**\n * @param {() => any} factory\n * @param {any[]} args\n */\nexport function useMemo(factory, args) {\n\t/** @type {import('./internal').MemoHookState} */\n\tconst state = getHookState(currentIndex++, 7);\n\tif (argsChanged(state._args, args)) {\n\t\tstate._args = args;\n\t\tstate._factory = factory;\n\t\treturn (state._value = factory());\n\t}\n\n\treturn state._value;\n}\n\n/**\n * @param {() => void} callback\n * @param {any[]} args\n */\nexport function useCallback(callback, args) {\n\tcurrentHook = 8;\n\treturn useMemo(() => callback, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nexport function useContext(context) {\n\tconst provider = currentComponent.context[context._id];\n\t// We could skip this call here, but than we'd not call\n\t// `options._hook`. We need to do that in order to make\n\t// the devtools aware of this hook.\n\tconst state = getHookState(currentIndex++, 9);\n\t// The devtools needs access to the context object to\n\t// be able to pull of the default value when no provider\n\t// is present in the tree.\n\tstate._context = context;\n\tif (!provider) return context._defaultValue;\n\t// This is probably not safe to convert to \"!\"\n\tif (state._value == null) {\n\t\tstate._value = true;\n\t\tprovider.sub(currentComponent);\n\t}\n\treturn provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nexport function useDebugValue(value, formatter) {\n\tif (options.useDebugValue) {\n\t\toptions.useDebugValue(formatter ? formatter(value) : value);\n\t}\n}\n\nexport function useErrorBoundary(cb) {\n\tconst state = getHookState(currentIndex++, 10);\n\tconst errState = useState();\n\tstate._value = cb;\n\tif (!currentComponent.componentDidCatch) {\n\t\tcurrentComponent.componentDidCatch = err => {\n\t\t\tif (state._value) state._value(err);\n\t\t\terrState[1](err);\n\t\t};\n\t}\n\treturn [\n\t\terrState[0],\n\t\t() => {\n\t\t\terrState[1](undefined);\n\t\t}\n\t];\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n\tafterPaintEffects.some(component => {\n\t\tif (component._parentDom) {\n\t\t\ttry {\n\t\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\t} catch (e) {\n\t\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\t\toptions._catchError(e, component._vnode);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t});\n\tafterPaintEffects = [];\n}\n\nlet HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tif (HAS_RAF) cancelAnimationFrame(raf);\n\t\tsetTimeout(callback);\n\t};\n\tconst timeout = setTimeout(done, RAF_TIMEOUT);\n\n\tlet raf;\n\tif (HAS_RAF) {\n\t\traf = requestAnimationFrame(done);\n\t}\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n */\nfunction afterPaint(newQueueLength) {\n\tif (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n\t\tprevRaf = options.requestAnimationFrame;\n\t\t(prevRaf || afterNextFrame)(flushAfterPaintEffects);\n\t}\n}\n\n/**\n * @param {import('./internal').EffectHookState} hook\n */\nfunction invokeCleanup(hook) {\n\tif (typeof hook._cleanup == 'function') hook._cleanup();\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n */\nfunction invokeEffect(hook) {\n\thook._cleanup = hook._value();\n}\n\n/**\n * @param {any[]} oldArgs\n * @param {any[]} newArgs\n */\nfunction argsChanged(oldArgs, newArgs) {\n\treturn !oldArgs || oldArgs.length !== newArgs.length || newArgs.some((arg, index) => arg !== oldArgs[index]);\n}\n\nfunction invokeOrReturn(arg, f) {\n\treturn typeof f == 'function' ? f(arg) : f;\n}\n"],"names":["currentIndex","currentComponent","prevRaf","currentHook","afterPaintEffects","oldBeforeRender","options","oldAfterDiff","diffed","oldCommit","oldBeforeUnmount","unmount","getHookState","index","type","hooks","length","push","useState","initialState","useReducer","invokeOrReturn","reducer","init","hookState","_reducer","undefined","action","nextValue","setState","useLayoutEffect","callback","args","state","argsChanged","useMemo","factory","flushAfterPaintEffects","some","component","forEach","invokeCleanup","invokeEffect","e","vnode","c","requestAnimationFrame","raf","done","clearTimeout","timeout","HAS_RAF","cancelAnimationFrame","setTimeout","commitQueue","filter","cb","hook","_cleanup","oldArgs","newArgs","arg","f","initialValue","current","ref","createHandle","concat","context","provider","sub","props","value","formatter","useDebugValue","errState","componentDidCatch","err"],"mappings":"uNAGA,IAAIA,EAGAC,EAcAC,EAXAC,EAAc,EAGdC,EAAoB,GAEpBC,EAAkBC,cAClBC,EAAeD,UAAQE,OACvBC,EAAYH,cACZI,EAAmBJ,UAAQK,QAkE/B,SAASC,EAAaC,EAAOC,GACxBR,eACHA,cAAcL,EAAkBY,EAAOV,GAAeW,GAEvDX,EAAc,MAORY,EACLd,QACCA,MAA2B,IACpB,OACU,YAGfY,GAASE,KAAYC,QACxBD,KAAYE,KAAK,IAEXF,KAAYF,GAMb,SAASK,EAASC,UACxBhB,EAAc,EACPiB,EAAWC,EAAgBF,GAS5B,SAASC,EAAWE,EAASH,EAAcI,OAE3CC,EAAYZ,EAAaZ,IAAgB,UAC/CwB,EAAUC,EAAWH,EAChBE,QACJA,MAAuBvB,EAEvBuB,KAAmB,CACjBD,EAAiDA,EAAKJ,GAA/CE,OAAeK,EAAWP,GAElC,SAAAQ,OACOC,EAAYJ,EAAUC,EAASD,KAAiB,GAAIG,GACtDH,KAAiB,KAAOI,IAC3BJ,KAAmB,CAACI,EAAWJ,KAAiB,IAChDA,MAAqBK,SAAS,QAM3BL,KAsBD,SAASM,EAAgBC,EAAUC,OAEnCC,EAAQrB,EAAaZ,IAAgB,IACtCM,eAAwB4B,EAAYD,MAAaD,KACrDC,KAAeF,EACfE,MAAcD,EAEd/B,MAAkCgB,KAAKgB,IA6BlC,SAASE,EAAQC,EAASJ,OAE1BC,EAAQrB,EAAaZ,IAAgB,UACvCkC,EAAYD,MAAaD,IAC5BC,MAAcD,EACdC,MAAiBG,EACTH,KAAeG,KAGjBH,KAiER,SAASI,IACRjC,EAAkBkC,KAAK,SAAAC,MAClBA,UAEFA,UAAkCC,QAAQC,GAC1CF,UAAkCC,QAAQE,GAC1CH,UAAoC,GACnC,MAAOI,UACRJ,UAAoC,GACpCjC,cAAoBqC,EAAGJ,QAChB,KAIVnC,EAAoB,iBAzQH,SAAAwC,GACbvC,GAAiBA,EAAgBuC,GAGrC5C,EAAe,MAETe,GAHNd,EAAmB2C,WAIf7B,IACHA,MAAsByB,QAAQC,GAC9B1B,MAAsByB,QAAQE,GAC9B3B,MAAwB,eAIlBP,OAAS,SAAAoC,GACZrC,GAAcA,EAAaqC,OAEzBC,EAAID,MACNC,GAAKA,OAAaA,UAA0B7B,SA4RzB,IA3RXZ,EAAkBa,KAAK4B,IA2RP3C,IAAYI,UAAQwC,yBAC/C5C,EAAUI,UAAQwC,wBAvBpB,SAAwBf,OAQnBgB,EAPEC,EAAO,WACZC,aAAaC,GACTC,GAASC,qBAAqBL,GAClCM,WAAWtB,IAENmB,EAAUG,WAAWL,EAjSR,KAoSfG,IACHJ,EAAMD,sBAAsBE,MAcAX,mBAzRZ,SAACO,EAAOU,GACzBA,EAAYhB,KAAK,SAAAC,OAEfA,MAA2BC,QAAQC,GACnCF,MAA6BA,MAA2BgB,OAAO,SAAAC,UAC9DA,MAAYd,EAAac,KAEzB,MAAOb,GACRW,EAAYhB,KAAK,SAAAO,GACZA,QAAoBA,MAAqB,MAE9CS,EAAc,GACdhD,cAAoBqC,EAAGJ,UAIrB9B,GAAWA,EAAUmC,EAAOU,cAGzB3C,QAAU,SAAAiC,GACblC,GAAkBA,EAAiBkC,OAEjCC,EAAID,SACNC,GAAKA,UAEPA,SAAgBL,QAAQC,GACvB,MAAOE,GACRrC,cAAoBqC,EAAGE,SA0N1B,IAAIM,EAA0C,mBAAzBL,sBA2CrB,SAASL,EAAcgB,GACM,mBAAjBA,EAAKC,GAAwBD,EAAKC,IAO9C,SAAShB,EAAae,GACrBA,EAAKC,EAAWD,OAOjB,SAASvB,EAAYyB,EAASC,UACrBD,GAAWA,EAAQ3C,SAAW4C,EAAQ5C,QAAU4C,EAAQtB,KAAK,SAACuB,EAAKhD,UAAUgD,IAAQF,EAAQ9C,KAGtG,SAASQ,EAAewC,EAAKC,SACT,mBAALA,EAAkBA,EAAED,GAAOC,0CA9MnC,SAAmB/B,EAAUC,OAE7BC,EAAQrB,EAAaZ,IAAgB,IACtCM,eAAwB4B,EAAYD,MAAaD,KACrDC,KAAeF,EACfE,MAAcD,EAEd/B,UAAyCgB,KAAKgB,kCAmBzC,SAAgB8B,UACtB5D,EAAc,EACPgC,EAAQ,iBAAO,CAAE6B,QAASD,IAAiB,2BAQ5C,SAA6BE,EAAKC,EAAclC,GACtD7B,EAAc,EACd2B,EACC,WACmB,mBAAPmC,EAAmBA,EAAIC,KACzBD,IAAKA,EAAID,QAAUE,MAErB,MAARlC,EAAeA,EAAOA,EAAKmC,OAAOF,+BAwB7B,SAAqBlC,EAAUC,UACrC7B,EAAc,EACPgC,EAAQ,kBAAMJ,GAAUC,iBAMzB,SAAoBoC,OACpBC,EAAWpE,EAAiBmE,QAAQA,OAIpCnC,EAAQrB,EAAaZ,IAAgB,UAI3CiC,MAAiBmC,EACZC,GAEe,MAAhBpC,OACHA,MAAe,EACfoC,EAASC,IAAIrE,IAEPoE,EAASE,MAAMC,OANAJ,sBAahB,SAAuBI,EAAOC,GAChCnE,UAAQoE,eACXpE,UAAQoE,cAAcD,EAAYA,EAAUD,GAASA,uBAIhD,SAA0BhB,OAC1BvB,EAAQrB,EAAaZ,IAAgB,IACrC2E,EAAWzD,WACjBe,KAAeuB,EACVvD,EAAiB2E,oBACrB3E,EAAiB2E,kBAAoB,SAAAC,GAChC5C,MAAcA,KAAa4C,GAC/BF,EAAS,GAAGE,KAGP,CACNF,EAAS,GACT,WACCA,EAAS,QAAGjD"}
\ No newline at end of file
diff --git a/node_modules/preact/hooks/mangle.json b/node_modules/preact/hooks/mangle.json
new file mode 100644
index 0000000..506a6a4
--- /dev/null
+++ b/node_modules/preact/hooks/mangle.json
@@ -0,0 +1,21 @@
+{
+  "help": {
+    "what is this file?": "It controls protected/private property mangling so that minified builds have consistent property names.",
+    "why are there duplicate minified properties?": "Most properties are only used on one type of objects, so they can have the same name since they will never collide. Doing this reduces size."
+  },
+  "minify": {
+    "mangle": {
+      "properties": {
+        "regex": "^_[^_]",
+        "reserved": [
+          "__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED",
+          "__REACT_DEVTOOLS_GLOBAL_HOOK__",
+          "__PREACT_DEVTOOLS__",
+          "_renderers",
+          "__source",
+          "__self"
+        ]
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/node_modules/preact/hooks/src/index.js b/node_modules/preact/hooks/src/index.js
index 394e3fc..59862f7 100644
--- a/node_modules/preact/hooks/src/index.js
+++ b/node_modules/preact/hooks/src/index.js
@@ -348,7 +348,7 @@ function invokeEffect(hook) {
  * @param {any[]} newArgs
  */
 function argsChanged(oldArgs, newArgs) {
-	return !oldArgs || newArgs.some((arg, index) => arg !== oldArgs[index]);
+	return !oldArgs || oldArgs.length !== newArgs.length || newArgs.some((arg, index) => arg !== oldArgs[index]);
 }
 
 function invokeOrReturn(arg, f) {
diff --git a/node_modules/preact/hooks/test/_util/useEffectUtil.js b/node_modules/preact/hooks/test/_util/useEffectUtil.js
new file mode 100644
index 0000000..f04edc2
--- /dev/null
+++ b/node_modules/preact/hooks/test/_util/useEffectUtil.js
@@ -0,0 +1,10 @@
+export function scheduleEffectAssert(assertFn) {
+	return new Promise(resolve => {
+		requestAnimationFrame(() =>
+			setTimeout(() => {
+				assertFn();
+				resolve();
+			}, 0)
+		);
+	});
+}
diff --git a/node_modules/preact/hooks/test/browser/combinations.test.js b/node_modules/preact/hooks/test/browser/combinations.test.js
new file mode 100644
index 0000000..986533c
--- /dev/null
+++ b/node_modules/preact/hooks/test/browser/combinations.test.js
@@ -0,0 +1,301 @@
+import { setupRerender, act } from 'preact/test-utils';
+import { createElement, render, Component } from 'preact';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+import {
+	useState,
+	useReducer,
+	useEffect,
+	useLayoutEffect,
+	useRef
+} from 'preact/hooks';
+import { scheduleEffectAssert } from '../_util/useEffectUtil';
+
+/** @jsx createElement */
+
+describe('combinations', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	/** @type {() => void} */
+	let rerender;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+		rerender = setupRerender();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	it('can mix useState hooks', () => {
+		const states = {};
+		const setStates = {};
+
+		function Parent() {
+			const [state1, setState1] = useState(1);
+			const [state2, setState2] = useState(2);
+
+			Object.assign(states, { state1, state2 });
+			Object.assign(setStates, { setState1, setState2 });
+
+			return <Child />;
+		}
+
+		function Child() {
+			const [state3, setState3] = useState(3);
+			const [state4, setState4] = useState(4);
+
+			Object.assign(states, { state3, state4 });
+			Object.assign(setStates, { setState3, setState4 });
+
+			return null;
+		}
+
+		render(<Parent />, scratch);
+		expect(states).to.deep.equal({
+			state1: 1,
+			state2: 2,
+			state3: 3,
+			state4: 4
+		});
+
+		setStates.setState2(n => n * 10);
+		setStates.setState3(n => n * 10);
+		rerender();
+		expect(states).to.deep.equal({
+			state1: 1,
+			state2: 20,
+			state3: 30,
+			state4: 4
+		});
+	});
+
+	it('can rerender asynchronously from within an effect', () => {
+		const didRender = sinon.spy();
+
+		function Comp() {
+			const [counter, setCounter] = useState(0);
+
+			useEffect(() => {
+				if (counter === 0) setCounter(1);
+			});
+
+			didRender(counter);
+			return null;
+		}
+
+		render(<Comp />, scratch);
+
+		return scheduleEffectAssert(() => {
+			rerender();
+			expect(didRender).to.have.been.calledTwice.and.calledWith(1);
+		});
+	});
+
+	it('can rerender synchronously from within a layout effect', () => {
+		const didRender = sinon.spy();
+
+		function Comp() {
+			const [counter, setCounter] = useState(0);
+
+			useLayoutEffect(() => {
+				if (counter === 0) setCounter(1);
+			});
+
+			didRender(counter);
+			return null;
+		}
+
+		render(<Comp />, scratch);
+		rerender();
+
+		expect(didRender).to.have.been.calledTwice.and.calledWith(1);
+	});
+
+	it('can access refs from within a layout effect callback', () => {
+		let refAtLayoutTime;
+
+		function Comp() {
+			const input = useRef();
+
+			useLayoutEffect(() => {
+				refAtLayoutTime = input.current;
+			});
+
+			return <input ref={input} value="hello" />;
+		}
+
+		render(<Comp />, scratch);
+
+		expect(refAtLayoutTime.value).to.equal('hello');
+	});
+
+	it('can use multiple useState and useReducer hooks', () => {
+		let states = [];
+		let dispatchState4;
+
+		function reducer1(state, action) {
+			switch (action.type) {
+				case 'increment':
+					return state + action.count;
+			}
+		}
+
+		function reducer2(state, action) {
+			switch (action.type) {
+				case 'increment':
+					return state + action.count * 2;
+			}
+		}
+
+		function Comp() {
+			const [state1] = useState(0);
+			const [state2] = useReducer(reducer1, 10);
+			const [state3] = useState(1);
+			const [state4, dispatch] = useReducer(reducer2, 20);
+
+			dispatchState4 = dispatch;
+			states.push(state1, state2, state3, state4);
+
+			return null;
+		}
+
+		render(<Comp />, scratch);
+
+		expect(states).to.deep.equal([0, 10, 1, 20]);
+
+		states = [];
+
+		dispatchState4({ type: 'increment', count: 10 });
+		rerender();
+
+		expect(states).to.deep.equal([0, 10, 1, 40]);
+	});
+
+	it('ensures useEffect always schedule after the next paint following a redraw effect, when using the default debounce strategy', () => {
+		let effectCount = 0;
+
+		function Comp() {
+			const [counter, setCounter] = useState(0);
+
+			useEffect(() => {
+				if (counter === 0) setCounter(1);
+				effectCount++;
+			});
+
+			return null;
+		}
+
+		render(<Comp />, scratch);
+
+		return scheduleEffectAssert(() => {
+			expect(effectCount).to.equal(1);
+		});
+	});
+
+	it('should not reuse functional components with hooks', () => {
+		let updater = { first: undefined, second: undefined };
+		function Foo(props) {
+			let [v, setter] = useState(0);
+			updater[props.id] = () => setter(++v);
+			return <div>{v}</div>;
+		}
+
+		let updateParent;
+		class App extends Component {
+			constructor(props) {
+				super(props);
+				this.state = { active: true };
+				updateParent = () => this.setState(p => ({ active: !p.active }));
+			}
+
+			render() {
+				return (
+					<div>
+						{this.state.active && <Foo id="first" />}
+						<Foo id="second" />
+					</div>
+				);
+			}
+		}
+
+		render(<App />, scratch);
+		act(() => updater.second());
+		expect(scratch.textContent).to.equal('01');
+
+		updateParent();
+		rerender();
+		expect(scratch.textContent).to.equal('1');
+
+		updateParent();
+		rerender();
+
+		expect(scratch.textContent).to.equal('01');
+	});
+
+	it('should have a right call order with correct dom ref', () => {
+		let i = 0,
+			set;
+		const calls = [];
+
+		function Inner() {
+			useLayoutEffect(() => {
+				calls.push('layout inner call ' + scratch.innerHTML);
+				return () => calls.push('layout inner dispose ' + scratch.innerHTML);
+			});
+			useEffect(() => {
+				calls.push('effect inner call ' + scratch.innerHTML);
+				return () => calls.push('effect inner dispose ' + scratch.innerHTML);
+			});
+			return <span>hello {i}</span>;
+		}
+
+		function Outer() {
+			i++;
+			const [state, setState] = useState(false);
+			set = () => setState(!state);
+			useLayoutEffect(() => {
+				calls.push('layout outer call ' + scratch.innerHTML);
+				return () => calls.push('layout outer dispose ' + scratch.innerHTML);
+			});
+			useEffect(() => {
+				calls.push('effect outer call ' + scratch.innerHTML);
+				return () => calls.push('effect outer dispose ' + scratch.innerHTML);
+			});
+			return <Inner />;
+		}
+
+		act(() => render(<Outer />, scratch));
+		expect(calls).to.deep.equal([
+			'layout inner call <span>hello 1</span>',
+			'layout outer call <span>hello 1</span>',
+			'effect inner call <span>hello 1</span>',
+			'effect outer call <span>hello 1</span>'
+		]);
+
+		// NOTE: this order is (at the time of writing) intentionally different from
+		// React. React calls all disposes across all components, and then invokes all
+		// effects across all components. We call disposes and effects in order of components:
+		// for each component, call its disposes and then its effects. If presented with a
+		// compelling use case to support inter-component dispose dependencies, then rewrite this
+		// test to test React's order. In other words, if there is a use case to support calling
+		// all disposes across components then re-order the lines below to demonstrate the desired behavior.
+
+		act(() => set());
+		expect(calls).to.deep.equal([
+			'layout inner call <span>hello 1</span>',
+			'layout outer call <span>hello 1</span>',
+			'effect inner call <span>hello 1</span>',
+			'effect outer call <span>hello 1</span>',
+			'layout inner dispose <span>hello 2</span>',
+			'layout inner call <span>hello 2</span>',
+			'layout outer dispose <span>hello 2</span>',
+			'layout outer call <span>hello 2</span>',
+			'effect inner dispose <span>hello 2</span>',
+			'effect inner call <span>hello 2</span>',
+			'effect outer dispose <span>hello 2</span>',
+			'effect outer call <span>hello 2</span>'
+		]);
+	});
+});
diff --git a/node_modules/preact/hooks/test/browser/errorBoundary.test.js b/node_modules/preact/hooks/test/browser/errorBoundary.test.js
new file mode 100644
index 0000000..4c2f7f3
--- /dev/null
+++ b/node_modules/preact/hooks/test/browser/errorBoundary.test.js
@@ -0,0 +1,92 @@
+import { createElement, render } from 'preact';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+import { useErrorBoundary } from 'preact/hooks';
+import { setupRerender } from 'preact/test-utils';
+
+/** @jsx createElement */
+
+describe('errorBoundary', () => {
+	/** @type {HTMLDivElement} */
+	let scratch, rerender;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+		rerender = setupRerender();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	it('catches errors', () => {
+		let resetErr,
+			success = false;
+		const Throws = () => {
+			throw new Error('test');
+		};
+
+		const App = props => {
+			const [err, reset] = useErrorBoundary();
+			resetErr = reset;
+			return err ? <p>Error</p> : success ? <p>Success</p> : <Throws />;
+		};
+
+		render(<App />, scratch);
+		rerender();
+		expect(scratch.innerHTML).to.equal('<p>Error</p>');
+
+		success = true;
+		resetErr();
+		rerender();
+		expect(scratch.innerHTML).to.equal('<p>Success</p>');
+	});
+
+	it('calls the errorBoundary callback', () => {
+		const spy = sinon.spy();
+		const error = new Error('test');
+		const Throws = () => {
+			throw error;
+		};
+
+		const App = props => {
+			const [err] = useErrorBoundary(spy);
+			return err ? <p>Error</p> : <Throws />;
+		};
+
+		render(<App />, scratch);
+		rerender();
+		expect(scratch.innerHTML).to.equal('<p>Error</p>');
+		expect(spy).to.be.calledOnce;
+		expect(spy).to.be.calledWith(error);
+	});
+
+	it('does not leave a stale closure', () => {
+		const spy = sinon.spy(),
+			spy2 = sinon.spy();
+		let resetErr;
+		const error = new Error('test');
+		const Throws = () => {
+			throw error;
+		};
+
+		const App = props => {
+			const [err, reset] = useErrorBoundary(props.onError);
+			resetErr = reset;
+			return err ? <p>Error</p> : <Throws />;
+		};
+
+		render(<App onError={spy} />, scratch);
+		rerender();
+		expect(scratch.innerHTML).to.equal('<p>Error</p>');
+		expect(spy).to.be.calledOnce;
+		expect(spy).to.be.calledWith(error);
+
+		resetErr();
+		render(<App onError={spy2} />, scratch);
+		rerender();
+		expect(scratch.innerHTML).to.equal('<p>Error</p>');
+		expect(spy).to.be.calledOnce;
+		expect(spy2).to.be.calledOnce;
+		expect(spy2).to.be.calledWith(error);
+	});
+});
diff --git a/node_modules/preact/hooks/test/browser/hooks.options.test.js b/node_modules/preact/hooks/test/browser/hooks.options.test.js
new file mode 100644
index 0000000..ca88d1f
--- /dev/null
+++ b/node_modules/preact/hooks/test/browser/hooks.options.test.js
@@ -0,0 +1,154 @@
+import {
+	afterDiffSpy,
+	beforeRenderSpy,
+	unmountSpy,
+	hookSpy
+} from '../../../test/_util/optionSpies';
+
+import { setupRerender, act } from 'preact/test-utils';
+import { createElement, render, createContext, options } from 'preact';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+import {
+	useState,
+	useReducer,
+	useEffect,
+	useLayoutEffect,
+	useRef,
+	useImperativeHandle,
+	useMemo,
+	useCallback,
+	useContext,
+	useErrorBoundary
+} from 'preact/hooks';
+
+/** @jsx createElement */
+
+describe('hook options', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	/** @type {() => void} */
+	let rerender;
+
+	/** @type {() => void} */
+	let increment;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+		rerender = setupRerender();
+
+		afterDiffSpy.resetHistory();
+		unmountSpy.resetHistory();
+		beforeRenderSpy.resetHistory();
+		hookSpy.resetHistory();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	function App() {
+		const [count, setCount] = useState(0);
+		increment = () => setCount(prevCount => prevCount + 1);
+		return <div>{count}</div>;
+	}
+
+	it('should call old options on mount', () => {
+		render(<App />, scratch);
+
+		expect(beforeRenderSpy).to.have.been.called;
+		expect(afterDiffSpy).to.have.been.called;
+	});
+
+	it('should call old options.diffed on update', () => {
+		render(<App />, scratch);
+
+		increment();
+		rerender();
+
+		expect(beforeRenderSpy).to.have.been.called;
+		expect(afterDiffSpy).to.have.been.called;
+	});
+
+	it('should call old options on unmount', () => {
+		render(<App />, scratch);
+		render(null, scratch);
+
+		expect(unmountSpy).to.have.been.called;
+	});
+
+	it('should detect hooks', () => {
+		const USE_STATE = 1;
+		const USE_REDUCER = 2;
+		const USE_EFFECT = 3;
+		const USE_LAYOUT_EFFECT = 4;
+		const USE_REF = 5;
+		const USE_IMPERATIVE_HANDLE = 6;
+		const USE_MEMO = 7;
+		const USE_CALLBACK = 8;
+		const USE_CONTEXT = 9;
+		const USE_ERROR_BOUNDARY = 10;
+
+		const Ctx = createContext(null);
+
+		function App() {
+			useState(0);
+			useReducer(x => x, 0);
+			useEffect(() => null, []);
+			useLayoutEffect(() => null, []);
+			const ref = useRef(null);
+			useImperativeHandle(ref, () => null);
+			useMemo(() => null, []);
+			useCallback(() => null, []);
+			useContext(Ctx);
+			useErrorBoundary(() => null);
+		}
+
+		render(
+			<Ctx.Provider value="a">
+				<App />
+			</Ctx.Provider>,
+			scratch
+		);
+
+		expect(hookSpy.args.map(arg => [arg[1], arg[2]])).to.deep.equal([
+			[0, USE_STATE],
+			[1, USE_REDUCER],
+			[2, USE_EFFECT],
+			[3, USE_LAYOUT_EFFECT],
+			[4, USE_REF],
+			[5, USE_IMPERATIVE_HANDLE],
+			[6, USE_MEMO],
+			[7, USE_CALLBACK],
+			[8, USE_CONTEXT],
+			[9, USE_ERROR_BOUNDARY],
+			// Belongs to useErrorBoundary that uses multiple native hooks.
+			[10, USE_STATE]
+		]);
+	});
+
+	describe('Effects', () => {
+		beforeEach(() => {
+			options._skipEffects = options.__s = true;
+		});
+
+		afterEach(() => {
+			options._skipEffects = options.__s = false;
+		});
+
+		it('should skip effect hooks', () => {
+			const spy = sinon.spy();
+			function App() {
+				useEffect(spy, []);
+				useLayoutEffect(spy, []);
+				return null;
+			}
+
+			act(() => {
+				render(<App />, scratch);
+			});
+
+			expect(spy.callCount).to.equal(0);
+		});
+	});
+});
diff --git a/node_modules/preact/hooks/test/browser/useCallback.test.js b/node_modules/preact/hooks/test/browser/useCallback.test.js
new file mode 100644
index 0000000..151fed9
--- /dev/null
+++ b/node_modules/preact/hooks/test/browser/useCallback.test.js
@@ -0,0 +1,41 @@
+import { createElement, render } from 'preact';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+import { useCallback } from 'preact/hooks';
+
+/** @jsx createElement */
+
+describe('useCallback', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	it('only recomputes the callback when inputs change', () => {
+		const callbacks = [];
+
+		function Comp({ a, b }) {
+			const cb = useCallback(() => a + b, [a, b]);
+			callbacks.push(cb);
+			return null;
+		}
+
+		render(<Comp a={1} b={1} />, scratch);
+		render(<Comp a={1} b={1} />, scratch);
+
+		expect(callbacks[0]).to.equal(callbacks[1]);
+		expect(callbacks[0]()).to.equal(2);
+
+		render(<Comp a={1} b={2} />, scratch);
+		render(<Comp a={1} b={2} />, scratch);
+
+		expect(callbacks[1]).to.not.equal(callbacks[2]);
+		expect(callbacks[2]).to.equal(callbacks[3]);
+		expect(callbacks[2]()).to.equal(3);
+	});
+});
diff --git a/node_modules/preact/hooks/test/browser/useContext.test.js b/node_modules/preact/hooks/test/browser/useContext.test.js
new file mode 100644
index 0000000..67b7851
--- /dev/null
+++ b/node_modules/preact/hooks/test/browser/useContext.test.js
@@ -0,0 +1,351 @@
+import { createElement, render, createContext, Component } from 'preact';
+import { act } from 'preact/test-utils';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+import { useContext, useEffect, useState } from 'preact/hooks';
+
+/** @jsx createElement */
+
+describe('useContext', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	it('gets values from context', () => {
+		const values = [];
+		const Context = createContext(13);
+
+		function Comp() {
+			const value = useContext(Context);
+			values.push(value);
+			return null;
+		}
+
+		render(<Comp />, scratch);
+		render(
+			<Context.Provider value={42}>
+				<Comp />
+			</Context.Provider>,
+			scratch
+		);
+		render(
+			<Context.Provider value={69}>
+				<Comp />
+			</Context.Provider>,
+			scratch
+		);
+
+		expect(values).to.deep.equal([13, 42, 69]);
+	});
+
+	it('should use default value', () => {
+		const Foo = createContext(42);
+		const spy = sinon.spy();
+
+		function App() {
+			spy(useContext(Foo));
+			return <div />;
+		}
+
+		render(<App />, scratch);
+		expect(spy).to.be.calledWith(42);
+	});
+
+	it('should update when value changes with nonUpdating Component on top', done => {
+		const spy = sinon.spy();
+		const Ctx = createContext(0);
+
+		class NoUpdate extends Component {
+			shouldComponentUpdate() {
+				return false;
+			}
+			render() {
+				return this.props.children;
+			}
+		}
+
+		function App(props) {
+			return (
+				<Ctx.Provider value={props.value}>
+					<NoUpdate>
+						<Comp />
+					</NoUpdate>
+				</Ctx.Provider>
+			);
+		}
+
+		function Comp() {
+			const value = useContext(Ctx);
+			spy(value);
+			return <h1>{value}</h1>;
+		}
+
+		render(<App value={0} />, scratch);
+		expect(spy).to.be.calledOnce;
+		expect(spy).to.be.calledWith(0);
+		render(<App value={1} />, scratch);
+
+		// Wait for enqueued hook update
+		setTimeout(() => {
+			// Should not be called a third time
+			expect(spy).to.be.calledTwice;
+			expect(spy).to.be.calledWith(1);
+			done();
+		}, 0);
+	});
+
+	it('should only update when value has changed', done => {
+		const spy = sinon.spy();
+		const Ctx = createContext(0);
+
+		function App(props) {
+			return (
+				<Ctx.Provider value={props.value}>
+					<Comp />
+				</Ctx.Provider>
+			);
+		}
+
+		function Comp() {
+			const value = useContext(Ctx);
+			spy(value);
+			return <h1>{value}</h1>;
+		}
+
+		render(<App value={0} />, scratch);
+		expect(spy).to.be.calledOnce;
+		expect(spy).to.be.calledWith(0);
+		render(<App value={1} />, scratch);
+
+		expect(spy).to.be.calledTwice;
+		expect(spy).to.be.calledWith(1);
+
+		// Wait for enqueued hook update
+		setTimeout(() => {
+			// Should not be called a third time
+			expect(spy).to.be.calledTwice;
+			done();
+		}, 0);
+	});
+
+	it('should allow multiple context hooks at the same time', () => {
+		const Foo = createContext(0);
+		const Bar = createContext(10);
+		const spy = sinon.spy();
+		const unmountspy = sinon.spy();
+
+		function Comp() {
+			const foo = useContext(Foo);
+			const bar = useContext(Bar);
+			spy(foo, bar);
+			useEffect(() => () => unmountspy());
+
+			return <div />;
+		}
+
+		render(
+			<Foo.Provider value={0}>
+				<Bar.Provider value={10}>
+					<Comp />
+				</Bar.Provider>
+			</Foo.Provider>,
+			scratch
+		);
+
+		expect(spy).to.be.calledOnce;
+		expect(spy).to.be.calledWith(0, 10);
+
+		render(
+			<Foo.Provider value={11}>
+				<Bar.Provider value={42}>
+					<Comp />
+				</Bar.Provider>
+			</Foo.Provider>,
+			scratch
+		);
+
+		expect(spy).to.be.calledTwice;
+		expect(unmountspy).not.to.be.called;
+	});
+
+	it('should only subscribe a component once', () => {
+		const values = [];
+		const Context = createContext(13);
+		let provider, subSpy;
+
+		function Comp() {
+			const value = useContext(Context);
+			values.push(value);
+			return null;
+		}
+
+		render(<Comp />, scratch);
+
+		render(
+			<Context.Provider ref={p => (provider = p)} value={42}>
+				<Comp />
+			</Context.Provider>,
+			scratch
+		);
+		subSpy = sinon.spy(provider, 'sub');
+
+		render(
+			<Context.Provider value={69}>
+				<Comp />
+			</Context.Provider>,
+			scratch
+		);
+		expect(subSpy).to.not.have.been.called;
+
+		expect(values).to.deep.equal([13, 42, 69]);
+	});
+
+	it('should maintain context', done => {
+		const context = createContext(null);
+		const { Provider } = context;
+		const first = { name: 'first' };
+		const second = { name: 'second' };
+
+		const Input = () => {
+			const config = useContext(context);
+
+			// Avoid eslint complaining about unused first value
+			const state = useState('initial');
+			const set = state[1];
+
+			useEffect(() => {
+				// Schedule the update on the next frame
+				requestAnimationFrame(() => {
+					set('irrelevant');
+				});
+			}, [config]);
+
+			return <div>{config.name}</div>;
+		};
+
+		const App = props => {
+			const [config, setConfig] = useState({});
+
+			useEffect(() => {
+				setConfig(props.config);
+			}, [props.config]);
+
+			return (
+				<Provider value={config}>
+					<Input />
+				</Provider>
+			);
+		};
+
+		act(() => {
+			render(<App config={first} />, scratch);
+
+			// Create a new div to append the `second` case
+			const div = scratch.appendChild(document.createElement('div'));
+			render(<App config={second} />, div);
+		});
+
+		// Push the expect into the next frame
+		requestAnimationFrame(() => {
+			expect(scratch.innerHTML).equal(
+				'<div>first</div><div><div>second</div></div>'
+			);
+			done();
+		});
+	});
+
+	it('should not rerender consumers that have been unmounted', () => {
+		const context = createContext(0);
+		const Provider = context.Provider;
+
+		const Inner = sinon.spy(() => {
+			const value = useContext(context);
+			return <div>{value}</div>;
+		});
+
+		let toggleConsumer;
+		let changeValue;
+		class App extends Component {
+			constructor() {
+				super();
+
+				this.state = { value: 0, show: true };
+				changeValue = value => this.setState({ value });
+				toggleConsumer = () => this.setState(({ show }) => ({ show: !show }));
+			}
+			render(props, state) {
+				return (
+					<Provider value={state.value}>
+						<div>{state.show ? <Inner /> : null}</div>
+					</Provider>
+				);
+			}
+		}
+
+		render(<App />, scratch);
+		expect(scratch.innerHTML).to.equal('<div><div>0</div></div>');
+		expect(Inner).to.have.been.calledOnce;
+
+		act(() => changeValue(1));
+		expect(scratch.innerHTML).to.equal('<div><div>1</div></div>');
+		expect(Inner).to.have.been.calledTwice;
+
+		act(() => toggleConsumer());
+		expect(scratch.innerHTML).to.equal('<div></div>');
+		expect(Inner).to.have.been.calledTwice;
+
+		act(() => changeValue(2));
+		expect(scratch.innerHTML).to.equal('<div></div>');
+		expect(Inner).to.have.been.calledTwice;
+	});
+
+	it('should rerender when reset to defaultValue', () => {
+		const defaultValue = { state: 'hi' };
+		const context = createContext(defaultValue);
+		let set;
+
+		const Consumer = () => {
+			const ctx = useContext(context);
+			return <p>{ctx.state}</p>;
+		};
+
+		class NoUpdate extends Component {
+			shouldComponentUpdate() {
+				return false;
+			}
+
+			render() {
+				return <Consumer />;
+			}
+		}
+
+		const Provider = () => {
+			const [state, setState] = useState(defaultValue);
+			set = setState;
+			return (
+				<context.Provider value={state}>
+					<NoUpdate />
+				</context.Provider>
+			);
+		};
+
+		render(<Provider />, scratch);
+		expect(scratch.innerHTML).to.equal('<p>hi</p>');
+
+		act(() => {
+			set({ state: 'bye' });
+		});
+		expect(scratch.innerHTML).to.equal('<p>bye</p>');
+
+		act(() => {
+			set(defaultValue);
+		});
+		expect(scratch.innerHTML).to.equal('<p>hi</p>');
+	});
+});
diff --git a/node_modules/preact/hooks/test/browser/useDebugValue.test.js b/node_modules/preact/hooks/test/browser/useDebugValue.test.js
new file mode 100644
index 0000000..2d44834
--- /dev/null
+++ b/node_modules/preact/hooks/test/browser/useDebugValue.test.js
@@ -0,0 +1,71 @@
+import { createElement, render, options } from 'preact';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+import { useDebugValue, useState } from 'preact/hooks';
+
+/** @jsx createElement*/
+
+describe('useDebugValue', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+		delete options.useDebugValue;
+	});
+
+	it('should do nothing when no options hook is present', () => {
+		function useFoo() {
+			useDebugValue('foo');
+			return useState(0);
+		}
+
+		function App() {
+			let [v] = useFoo();
+			return <div>{v}</div>;
+		}
+
+		expect(() => render(<App />, scratch)).to.not.throw();
+	});
+
+	it('should call options hook with value', () => {
+		let spy = (options.useDebugValue = sinon.spy());
+
+		function useFoo() {
+			useDebugValue('foo');
+			return useState(0);
+		}
+
+		function App() {
+			let [v] = useFoo();
+			return <div>{v}</div>;
+		}
+
+		render(<App />, scratch);
+
+		expect(spy).to.be.calledOnce;
+		expect(spy).to.be.calledWith('foo');
+	});
+
+	it('should apply optional formatter', () => {
+		let spy = (options.useDebugValue = sinon.spy());
+
+		function useFoo() {
+			useDebugValue('foo', x => x + 'bar');
+			return useState(0);
+		}
+
+		function App() {
+			let [v] = useFoo();
+			return <div>{v}</div>;
+		}
+
+		render(<App />, scratch);
+
+		expect(spy).to.be.calledOnce;
+		expect(spy).to.be.calledWith('foobar');
+	});
+});
diff --git a/node_modules/preact/hooks/test/browser/useEffect.test.js b/node_modules/preact/hooks/test/browser/useEffect.test.js
new file mode 100644
index 0000000..b7d4091
--- /dev/null
+++ b/node_modules/preact/hooks/test/browser/useEffect.test.js
@@ -0,0 +1,269 @@
+import { act } from 'preact/test-utils';
+import { createElement, render, Fragment, Component } from 'preact';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+import { useEffect, useState } from 'preact/hooks';
+import { useEffectAssertions } from './useEffectAssertions.test';
+import { scheduleEffectAssert } from '../_util/useEffectUtil';
+
+/** @jsx createElement */
+
+describe('useEffect', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	useEffectAssertions(useEffect, scheduleEffectAssert);
+
+	it('calls the effect immediately if another render is about to start', () => {
+		const cleanupFunction = sinon.spy();
+		const callback = sinon.spy(() => cleanupFunction);
+
+		function Comp() {
+			useEffect(callback);
+			return null;
+		}
+
+		render(<Comp />, scratch);
+		render(<Comp />, scratch);
+
+		expect(cleanupFunction).to.be.not.called;
+		expect(callback).to.be.calledOnce;
+
+		render(<Comp />, scratch);
+
+		expect(cleanupFunction).to.be.calledOnce;
+		expect(callback).to.be.calledTwice;
+	});
+
+	it('cancels the effect when the component get unmounted before it had the chance to run it', () => {
+		const cleanupFunction = sinon.spy();
+		const callback = sinon.spy(() => cleanupFunction);
+
+		function Comp() {
+			useEffect(callback);
+			return null;
+		}
+
+		render(<Comp />, scratch);
+		render(null, scratch);
+
+		return scheduleEffectAssert(() => {
+			expect(cleanupFunction).to.not.be.called;
+			expect(callback).to.not.be.called;
+		});
+	});
+
+	it('should execute multiple effects in same component in the right order', () => {
+		let executionOrder = [];
+		const App = ({ i }) => {
+			executionOrder = [];
+			useEffect(() => {
+				executionOrder.push('action1');
+				return () => executionOrder.push('cleanup1');
+			}, [i]);
+			useEffect(() => {
+				executionOrder.push('action2');
+				return () => executionOrder.push('cleanup2');
+			}, [i]);
+			return <p>Test</p>;
+		};
+		act(() => render(<App i={0} />, scratch));
+		act(() => render(<App i={2} />, scratch));
+		expect(executionOrder).to.deep.equal([
+			'cleanup1',
+			'cleanup2',
+			'action1',
+			'action2'
+		]);
+	});
+
+	it('should throw an error upwards', () => {
+		const spy = sinon.spy();
+		let errored = false;
+
+		const Page1 = () => {
+			const [state, setState] = useState('loading');
+			useEffect(() => {
+				setState('loaded');
+			}, []);
+			return <p>{state}</p>;
+		};
+
+		const Page2 = () => {
+			useEffect(() => {
+				throw new Error('err');
+			}, []);
+			return <p>invisible</p>;
+		};
+
+		class App extends Component {
+			componentDidCatch(err) {
+				spy();
+				errored = err;
+			}
+
+			render(props, state) {
+				if (errored) {
+					return <p>Error</p>;
+				}
+
+				return <Fragment>{props.page === 1 ? <Page1 /> : <Page2 />}</Fragment>;
+			}
+		}
+
+		act(() => render(<App page={1} />, scratch));
+		expect(spy).to.not.be.called;
+		expect(scratch.innerHTML).to.equal('<p>loaded</p>');
+
+		act(() => render(<App page={2} />, scratch));
+		expect(spy).to.be.calledOnce;
+		expect(scratch.innerHTML).to.equal('<p>Error</p>');
+		errored = false;
+
+		act(() => render(<App page={1} />, scratch));
+		expect(spy).to.be.calledOnce;
+		expect(scratch.innerHTML).to.equal('<p>loaded</p>');
+	});
+
+	it('should throw an error upwards from return', () => {
+		const spy = sinon.spy();
+		let errored = false;
+
+		const Page1 = () => {
+			const [state, setState] = useState('loading');
+			useEffect(() => {
+				setState('loaded');
+			}, []);
+			return <p>{state}</p>;
+		};
+
+		const Page2 = () => {
+			useEffect(() => {
+				return () => {
+					throw new Error('err');
+				};
+			}, []);
+			return <p>Load</p>;
+		};
+
+		class App extends Component {
+			componentDidCatch(err) {
+				spy();
+				errored = err;
+			}
+
+			render(props, state) {
+				if (errored) {
+					return <p>Error</p>;
+				}
+
+				return <Fragment>{props.page === 1 ? <Page1 /> : <Page2 />}</Fragment>;
+			}
+		}
+
+		act(() => render(<App page={2} />, scratch));
+		expect(scratch.innerHTML).to.equal('<p>Load</p>');
+
+		act(() => render(<App page={1} />, scratch));
+		expect(spy).to.be.calledOnce;
+		expect(scratch.innerHTML).to.equal('<p>Error</p>');
+	});
+
+	it('catches errors when error is invoked during render', () => {
+		const spy = sinon.spy();
+		let errored;
+
+		function Comp() {
+			useEffect(() => {
+				throw new Error('hi');
+			});
+			return null;
+		}
+
+		class App extends Component {
+			componentDidCatch(err) {
+				spy();
+				errored = err;
+			}
+
+			render(props, state) {
+				if (errored) {
+					return <p>Error</p>;
+				}
+
+				return <Comp />;
+			}
+		}
+
+		render(<App />, scratch);
+		act(() => {
+			render(<App />, scratch);
+		});
+		expect(spy).to.be.calledOnce;
+		expect(scratch.innerHTML).to.equal('<p>Error</p>');
+	});
+
+	it('should allow creating a new root', () => {
+		const root = document.createElement('div');
+		const global = document.createElement('div');
+		scratch.appendChild(root);
+		scratch.appendChild(global);
+
+		const Modal = props => {
+			let [, setCanProceed] = useState(true);
+			let ChildProp = props.content;
+
+			return (
+				<div>
+					<ChildProp setCanProceed={setCanProceed} />
+				</div>
+			);
+		};
+
+		const Inner = () => {
+			useEffect(() => {
+				render(<div>global</div>, global);
+			}, []);
+
+			return <div>Inner</div>;
+		};
+
+		act(() => {
+			render(
+				<Modal
+					content={props => {
+						props.setCanProceed(false);
+						return <Inner />;
+					}}
+				/>,
+				root
+			);
+		});
+
+		expect(scratch.innerHTML).to.equal(
+			'<div><div><div>Inner</div></div></div><div><div>global</div></div>'
+		);
+	});
+
+	it('should not crash when effect returns truthy non-function value', () => {
+		const callback = sinon.spy(() => 'truthy');
+		function Comp() {
+			useEffect(callback);
+			return null;
+		}
+
+		render(<Comp />, scratch);
+		render(<Comp />, scratch);
+
+		expect(callback).to.have.been.calledOnce;
+
+		render(<div>Replacement</div>, scratch);
+	});
+});
diff --git a/node_modules/preact/hooks/test/browser/useEffectAssertions.test.js b/node_modules/preact/hooks/test/browser/useEffectAssertions.test.js
new file mode 100644
index 0000000..74ba232
--- /dev/null
+++ b/node_modules/preact/hooks/test/browser/useEffectAssertions.test.js
@@ -0,0 +1,142 @@
+import { setupRerender } from 'preact/test-utils';
+import { createElement, render } from 'preact';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+
+/** @jsx createElement */
+
+// Common behaviors between all effect hooks
+export function useEffectAssertions(useEffect, scheduleEffectAssert) {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	/** @type {() => void} */
+	let rerender;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+		rerender = setupRerender();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	it('performs the effect after every render by default', () => {
+		const callback = sinon.spy();
+
+		function Comp() {
+			useEffect(callback);
+			return null;
+		}
+
+		render(<Comp />, scratch);
+
+		return scheduleEffectAssert(() => expect(callback).to.be.calledOnce)
+			.then(() => scheduleEffectAssert(() => expect(callback).to.be.calledOnce))
+			.then(() => render(<Comp />, scratch))
+			.then(() =>
+				scheduleEffectAssert(() => expect(callback).to.be.calledTwice)
+			);
+	});
+
+	it('performs the effect only if one of the inputs changed', () => {
+		const callback = sinon.spy();
+
+		function Comp(props) {
+			useEffect(callback, [props.a, props.b]);
+			return null;
+		}
+
+		render(<Comp a={1} b={2} />, scratch);
+
+		return scheduleEffectAssert(() => expect(callback).to.be.calledOnce)
+			.then(() => render(<Comp a={1} b={2} />, scratch))
+			.then(() => scheduleEffectAssert(() => expect(callback).to.be.calledOnce))
+			.then(() => render(<Comp a={2} b={2} />, scratch))
+			.then(() =>
+				scheduleEffectAssert(() => expect(callback).to.be.calledTwice)
+			)
+			.then(() => render(<Comp a={2} b={2} />, scratch))
+			.then(() =>
+				scheduleEffectAssert(() => expect(callback).to.be.calledTwice)
+			);
+	});
+
+	it('performs the effect at mount time and never again if an empty input Array is passed', () => {
+		const callback = sinon.spy();
+
+		function Comp() {
+			useEffect(callback, []);
+			return null;
+		}
+
+		render(<Comp />, scratch);
+		render(<Comp />, scratch);
+
+		expect(callback).to.be.calledOnce;
+
+		return scheduleEffectAssert(() => expect(callback).to.be.calledOnce)
+			.then(() => render(<Comp />, scratch))
+			.then(() =>
+				scheduleEffectAssert(() => expect(callback).to.be.calledOnce)
+			);
+	});
+
+	it('calls the cleanup function followed by the effect after each render', () => {
+		const cleanupFunction = sinon.spy();
+		const callback = sinon.spy(() => cleanupFunction);
+
+		function Comp() {
+			useEffect(callback);
+			return null;
+		}
+
+		render(<Comp />, scratch);
+
+		return scheduleEffectAssert(() => {
+			expect(cleanupFunction).to.be.not.called;
+			expect(callback).to.be.calledOnce;
+		})
+			.then(() => scheduleEffectAssert(() => expect(callback).to.be.calledOnce))
+			.then(() => render(<Comp />, scratch))
+			.then(() =>
+				scheduleEffectAssert(() => {
+					expect(cleanupFunction).to.be.calledOnce;
+					expect(callback).to.be.calledTwice;
+					expect(callback.lastCall.calledAfter(cleanupFunction.lastCall));
+				})
+			);
+	});
+
+	it('cleanups the effect when the component get unmounted if the effect was called before', () => {
+		const cleanupFunction = sinon.spy();
+		const callback = sinon.spy(() => cleanupFunction);
+
+		function Comp() {
+			useEffect(callback);
+			return null;
+		}
+
+		render(<Comp />, scratch);
+
+		return scheduleEffectAssert(() => {
+			render(null, scratch);
+			rerender();
+			expect(cleanupFunction).to.be.calledOnce;
+		});
+	});
+
+	it('works with closure effect callbacks capturing props', () => {
+		const values = [];
+
+		function Comp(props) {
+			useEffect(() => values.push(props.value));
+			return null;
+		}
+
+		render(<Comp value={1} />, scratch);
+		render(<Comp value={2} />, scratch);
+
+		return scheduleEffectAssert(() => expect(values).to.deep.equal([1, 2]));
+	});
+}
diff --git a/node_modules/preact/hooks/test/browser/useImperativeHandle.test.js b/node_modules/preact/hooks/test/browser/useImperativeHandle.test.js
new file mode 100644
index 0000000..52cc073
--- /dev/null
+++ b/node_modules/preact/hooks/test/browser/useImperativeHandle.test.js
@@ -0,0 +1,182 @@
+import { createElement, render } from 'preact';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+import { useImperativeHandle, useRef, useState } from 'preact/hooks';
+import { setupRerender } from 'preact/test-utils';
+
+/** @jsx createElement */
+
+describe('useImperativeHandle', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	/** @type {() => void} */
+	let rerender;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+		rerender = setupRerender();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	it('Mutates given ref', () => {
+		let ref;
+
+		function Comp() {
+			ref = useRef({});
+			useImperativeHandle(ref, () => ({ test: () => 'test' }), []);
+			return <p>Test</p>;
+		}
+
+		render(<Comp />, scratch);
+		expect(ref.current).to.have.property('test');
+		expect(ref.current.test()).to.equal('test');
+	});
+
+	it('calls createHandle after every render by default', () => {
+		let ref,
+			createHandleSpy = sinon.spy();
+
+		function Comp() {
+			ref = useRef({});
+			useImperativeHandle(ref, createHandleSpy);
+			return <p>Test</p>;
+		}
+
+		render(<Comp />, scratch);
+		expect(createHandleSpy).to.have.been.calledOnce;
+
+		render(<Comp />, scratch);
+		expect(createHandleSpy).to.have.been.calledTwice;
+
+		render(<Comp />, scratch);
+		expect(createHandleSpy).to.have.been.calledThrice;
+	});
+
+	it('calls createHandle only on mount if an empty array is passed', () => {
+		let ref,
+			createHandleSpy = sinon.spy();
+
+		function Comp() {
+			ref = useRef({});
+			useImperativeHandle(ref, createHandleSpy, []);
+			return <p>Test</p>;
+		}
+
+		render(<Comp />, scratch);
+		expect(createHandleSpy).to.have.been.calledOnce;
+
+		render(<Comp />, scratch);
+		expect(createHandleSpy).to.have.been.calledOnce;
+	});
+
+	it('Updates given ref when args change', () => {
+		let ref,
+			createHandleSpy = sinon.spy();
+
+		function Comp({ a }) {
+			ref = useRef({});
+			useImperativeHandle(
+				ref,
+				() => {
+					createHandleSpy();
+					return { test: () => 'test' + a };
+				},
+				[a]
+			);
+			return <p>Test</p>;
+		}
+
+		render(<Comp a={0} />, scratch);
+		expect(createHandleSpy).to.have.been.calledOnce;
+		expect(ref.current).to.have.property('test');
+		expect(ref.current.test()).to.equal('test0');
+
+		render(<Comp a={1} />, scratch);
+		expect(createHandleSpy).to.have.been.calledTwice;
+		expect(ref.current).to.have.property('test');
+		expect(ref.current.test()).to.equal('test1');
+
+		render(<Comp a={0} />, scratch);
+		expect(createHandleSpy).to.have.been.calledThrice;
+		expect(ref.current).to.have.property('test');
+		expect(ref.current.test()).to.equal('test0');
+	});
+
+	it('Updates given ref when passed-in ref changes', () => {
+		let ref1, ref2;
+
+		/** @type {(arg: any) => void} */
+		let setRef;
+
+		/** @type {() => void} */
+		let updateState;
+
+		const createHandleSpy = sinon.spy(() => ({
+			test: () => 'test'
+		}));
+
+		function Comp() {
+			ref1 = useRef({});
+			ref2 = useRef({});
+
+			const [ref, setRefInternal] = useState(ref1);
+			setRef = setRefInternal;
+
+			let [value, setState] = useState(0);
+			updateState = () => setState((value + 1) % 2);
+
+			useImperativeHandle(ref, createHandleSpy, []);
+			return <p>Test</p>;
+		}
+
+		render(<Comp a={0} />, scratch);
+		expect(createHandleSpy).to.have.been.calledOnce;
+
+		updateState();
+		rerender();
+		expect(createHandleSpy).to.have.been.calledOnce;
+
+		setRef(ref2);
+		rerender();
+		expect(createHandleSpy).to.have.been.calledTwice;
+
+		updateState();
+		rerender();
+		expect(createHandleSpy).to.have.been.calledTwice;
+
+		setRef(ref1);
+		rerender();
+		expect(createHandleSpy).to.have.been.calledThrice;
+	});
+
+	it('should not update ref when args have not changed', () => {
+		let ref,
+			createHandleSpy = sinon.spy(() => ({ test: () => 'test' }));
+
+		function Comp() {
+			ref = useRef({});
+			useImperativeHandle(ref, createHandleSpy, [1]);
+			return <p>Test</p>;
+		}
+
+		render(<Comp />, scratch);
+		expect(createHandleSpy).to.have.been.calledOnce;
+		expect(ref.current.test()).to.equal('test');
+
+		render(<Comp />, scratch);
+		expect(createHandleSpy).to.have.been.calledOnce;
+		expect(ref.current.test()).to.equal('test');
+	});
+
+	it('should not throw with nullish ref', () => {
+		function Comp() {
+			useImperativeHandle(null, () => ({ test: () => 'test' }), [1]);
+			return <p>Test</p>;
+		}
+
+		expect(() => render(<Comp />, scratch)).to.not.throw();
+	});
+});
diff --git a/node_modules/preact/hooks/test/browser/useLayoutEffect.test.js b/node_modules/preact/hooks/test/browser/useLayoutEffect.test.js
new file mode 100644
index 0000000..ef4d16e
--- /dev/null
+++ b/node_modules/preact/hooks/test/browser/useLayoutEffect.test.js
@@ -0,0 +1,324 @@
+import { act } from 'preact/test-utils';
+import { createElement, render, Fragment, Component } from 'preact';
+import {
+	setupScratch,
+	teardown,
+	serializeHtml
+} from '../../../test/_util/helpers';
+import { useEffectAssertions } from './useEffectAssertions.test';
+import { useLayoutEffect, useRef, useState } from 'preact/hooks';
+
+/** @jsx createElement */
+
+describe('useLayoutEffect', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	// Layout effects fire synchronously
+	const scheduleEffectAssert = assertFn =>
+		new Promise(resolve => {
+			assertFn();
+			resolve();
+		});
+
+	useEffectAssertions(useLayoutEffect, scheduleEffectAssert);
+
+	it('calls the effect immediately after render', () => {
+		const cleanupFunction = sinon.spy();
+		const callback = sinon.spy(() => cleanupFunction);
+
+		function Comp() {
+			useLayoutEffect(callback);
+			return null;
+		}
+
+		render(<Comp />, scratch);
+		render(<Comp />, scratch);
+
+		expect(cleanupFunction).to.be.calledOnce;
+		expect(callback).to.be.calledTwice;
+
+		render(<Comp />, scratch);
+
+		expect(cleanupFunction).to.be.calledTwice;
+		expect(callback).to.be.calledThrice;
+	});
+
+	it('works on a nested component', () => {
+		const callback = sinon.spy();
+
+		function Parent() {
+			return (
+				<div>
+					<Child />
+				</div>
+			);
+		}
+
+		function Child() {
+			useLayoutEffect(callback);
+			return null;
+		}
+
+		render(<Parent />, scratch);
+
+		expect(callback).to.be.calledOnce;
+	});
+
+	it('should execute multiple layout effects in same component in the right order', () => {
+		let executionOrder = [];
+		const App = ({ i }) => {
+			executionOrder = [];
+			useLayoutEffect(() => {
+				executionOrder.push('action1');
+				return () => executionOrder.push('cleanup1');
+			}, [i]);
+			useLayoutEffect(() => {
+				executionOrder.push('action2');
+				return () => executionOrder.push('cleanup2');
+			}, [i]);
+			return <p>Test</p>;
+		};
+		render(<App i={0} />, scratch);
+		render(<App i={2} />, scratch);
+		expect(executionOrder).to.deep.equal([
+			'cleanup1',
+			'cleanup2',
+			'action1',
+			'action2'
+		]);
+	});
+
+	it('should correctly display DOM', () => {
+		function AutoResizeTextareaLayoutEffect(props) {
+			const ref = useRef(null);
+			useLayoutEffect(() => {
+				// IE & Edge put textarea's value as child of textarea when reading innerHTML so use
+				// cross browser serialize helper
+				const actualHtml = serializeHtml(scratch);
+				const expectedHTML = `<div class="${props.value}"><p>${props.value}</p><textarea></textarea></div>`;
+				expect(actualHtml).to.equal(expectedHTML);
+				expect(document.body.contains(ref.current)).to.equal(true);
+			});
+			return (
+				<Fragment>
+					<p>{props.value}</p>
+					<textarea ref={ref} value={props.value} onChange={props.onChange} />
+				</Fragment>
+			);
+		}
+
+		function App(props) {
+			return (
+				<div class={props.value}>
+					<AutoResizeTextareaLayoutEffect {...props} />
+				</div>
+			);
+		}
+
+		render(<App value="hi" />, scratch);
+		render(<App value="hii" />, scratch);
+	});
+
+	it('should invoke layout effects after subtree is fully connected', () => {
+		let ref;
+		let layoutEffect = sinon.spy(() => {
+			const isConnected = document.body.contains(ref.current);
+			expect(isConnected).to.equal(true, 'isConnected');
+		});
+
+		function Inner() {
+			ref = useRef(null);
+			useLayoutEffect(layoutEffect);
+			return (
+				<Fragment>
+					<textarea ref={ref} />
+					<span>hello</span>;
+				</Fragment>
+			);
+		}
+
+		function Outer() {
+			return (
+				<div>
+					<Inner />
+				</div>
+			);
+		}
+
+		render(<Outer />, scratch);
+		expect(layoutEffect).to.have.been.calledOnce;
+	});
+
+	// TODO: Make this test pass to resolve issue #1886
+	it.skip('should call effects correctly when unmounting', () => {
+		let onClick, calledFoo, calledBar, calledFooCleanup, calledBarCleanup;
+
+		const Foo = () => {
+			useLayoutEffect(() => {
+				if (!calledFoo) calledFoo = scratch.innerHTML;
+				return () => {
+					if (!calledFooCleanup) calledFooCleanup = scratch.innerHTML;
+				};
+			}, []);
+
+			return (
+				<div>
+					<p>Foo</p>
+				</div>
+			);
+		};
+
+		const Bar = () => {
+			useLayoutEffect(() => {
+				if (!calledBar) calledBar = scratch.innerHTML;
+				return () => {
+					if (!calledBarCleanup) calledBarCleanup = scratch.innerHTML;
+				};
+			}, []);
+
+			return (
+				<div>
+					<p>Bar</p>
+				</div>
+			);
+		};
+
+		function App() {
+			const [current, setCurrent] = useState('/foo');
+
+			onClick = () => setCurrent(current === '/foo' ? '/bar' : '/foo');
+
+			return (
+				<Fragment>
+					<button onClick={onClick}>next</button>
+
+					{current === '/foo' && <Foo />}
+					{current === '/bar' && <Bar />}
+				</Fragment>
+			);
+		}
+
+		render(<App />, scratch);
+		expect(calledFoo).to.equal(
+			'<button>next</button><div><p>Foo</p></div>',
+			'calledFoo'
+		);
+
+		act(() => onClick());
+		expect(calledFooCleanup).to.equal(
+			'<button>next</button><div><p>Bar</p></div>',
+			'calledFooCleanup'
+		);
+		expect(calledBar).to.equal(
+			'<button>next</button><div><p>Bar</p></div>',
+			'calledBar'
+		);
+
+		act(() => onClick());
+		expect(calledBarCleanup).to.equal(
+			'<button>next</button><div><p>Foo</p></div>',
+			'calledBarCleanup'
+		);
+	});
+
+	it('should throw an error upwards', () => {
+		const spy = sinon.spy();
+		let errored = false;
+
+		const Page1 = () => {
+			const [state, setState] = useState('loading');
+			useLayoutEffect(() => {
+				setState('loaded');
+			}, []);
+			return <p>{state}</p>;
+		};
+
+		const Page2 = () => {
+			useLayoutEffect(() => {
+				throw new Error('err');
+			}, []);
+			return <p>invisible</p>;
+		};
+
+		class App extends Component {
+			componentDidCatch(err) {
+				spy();
+				errored = err;
+			}
+
+			render(props, state) {
+				if (errored) {
+					return <p>Error</p>;
+				}
+
+				return <Fragment>{props.page === 1 ? <Page1 /> : <Page2 />}</Fragment>;
+			}
+		}
+
+		act(() => render(<App page={1} />, scratch));
+		expect(spy).to.not.be.called;
+		expect(scratch.innerHTML).to.equal('<p>loaded</p>');
+
+		act(() => render(<App page={2} />, scratch));
+		expect(spy).to.be.calledOnce;
+		expect(scratch.innerHTML).to.equal('<p>Error</p>');
+		errored = false;
+
+		act(() => render(<App page={1} />, scratch));
+		expect(spy).to.be.calledOnce;
+		expect(scratch.innerHTML).to.equal('<p>loaded</p>');
+	});
+
+	it('should throw an error upwards from return', () => {
+		const spy = sinon.spy();
+		let errored = false;
+
+		const Page1 = () => {
+			const [state, setState] = useState('loading');
+			useLayoutEffect(() => {
+				setState('loaded');
+			}, []);
+			return <p>{state}</p>;
+		};
+
+		const Page2 = () => {
+			useLayoutEffect(() => {
+				return () => {
+					throw new Error('err');
+				};
+			}, []);
+			return <p>Load</p>;
+		};
+
+		class App extends Component {
+			componentDidCatch(err) {
+				spy();
+				errored = err;
+			}
+
+			render(props, state) {
+				if (errored) {
+					return <p>Error</p>;
+				}
+
+				return <Fragment>{props.page === 1 ? <Page1 /> : <Page2 />}</Fragment>;
+			}
+		}
+
+		act(() => render(<App page={2} />, scratch));
+		expect(scratch.innerHTML).to.equal('<p>Load</p>');
+
+		act(() => render(<App page={1} />, scratch));
+		expect(spy).to.be.calledOnce;
+		expect(scratch.innerHTML).to.equal('<p>Error</p>');
+	});
+});
diff --git a/node_modules/preact/hooks/test/browser/useMemo.test.js b/node_modules/preact/hooks/test/browser/useMemo.test.js
new file mode 100644
index 0000000..646f924
--- /dev/null
+++ b/node_modules/preact/hooks/test/browser/useMemo.test.js
@@ -0,0 +1,103 @@
+import { createElement, render } from 'preact';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+import { useMemo } from 'preact/hooks';
+
+/** @jsx createElement */
+
+describe('useMemo', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	it('only recomputes the result when inputs change', () => {
+		let memoFunction = sinon.spy((a, b) => a + b);
+		const results = [];
+
+		function Comp({ a, b }) {
+			const result = useMemo(() => memoFunction(a, b), [a, b]);
+			results.push(result);
+			return null;
+		}
+
+		render(<Comp a={1} b={1} />, scratch);
+		render(<Comp a={1} b={1} />, scratch);
+
+		expect(results).to.deep.equal([2, 2]);
+		expect(memoFunction).to.have.been.calledOnce;
+
+		render(<Comp a={1} b={2} />, scratch);
+		render(<Comp a={1} b={2} />, scratch);
+
+		expect(results).to.deep.equal([2, 2, 3, 3]);
+		expect(memoFunction).to.have.been.calledTwice;
+	});
+
+	it('should rerun when deps length changes', () => {
+		let memoFunction = sinon.spy(() => 1 + 2);
+
+		function Comp({ all }) {
+			const deps = [1, all && 2].filter(Boolean);
+			const result = useMemo(() => memoFunction(), deps);
+			return result;
+		}
+
+		render(<Comp all />, scratch);
+		expect(memoFunction).to.have.been.calledOnce;
+		render(<Comp all={false} />, scratch);
+		expect(memoFunction).to.have.been.calledTwice;
+	});
+
+	it('short circuits diffing for memoized components', () => {
+		let spy = sinon.spy();
+		let spy2 = sinon.spy();
+		const X = ({ count }) => {
+			spy();
+			return <span>{count}</span>;
+		};
+
+		const Y = ({ count }) => {
+			spy2();
+			return <p>{count}</p>;
+		};
+
+		const App = ({ x }) => {
+			const y = useMemo(() => <Y count={x} />, [x]);
+			return (
+				<div>
+					<X count={x} />
+					{y}
+				</div>
+			);
+		};
+
+		render(<App x={0} />, scratch);
+		expect(spy).to.be.calledOnce;
+		expect(spy2).to.be.calledOnce;
+		expect(scratch.innerHTML).to.equal('<div><span>0</span><p>0</p></div>');
+
+		render(<App x={0} />, scratch);
+		expect(spy).to.be.calledTwice;
+		expect(spy2).to.be.calledOnce;
+		expect(scratch.innerHTML).to.equal('<div><span>0</span><p>0</p></div>');
+
+		render(<App x={1} />, scratch);
+		expect(spy).to.be.calledThrice;
+		expect(spy2).to.be.calledTwice;
+		expect(scratch.innerHTML).to.equal('<div><span>1</span><p>1</p></div>');
+
+		render(<App x={1} />, scratch);
+		expect(spy2).to.be.calledTwice;
+		expect(scratch.innerHTML).to.equal('<div><span>1</span><p>1</p></div>');
+
+		render(<App x={2} />, scratch);
+		expect(spy2).to.be.calledThrice;
+		expect(scratch.innerHTML).to.equal('<div><span>2</span><p>2</p></div>');
+	});
+});
diff --git a/node_modules/preact/hooks/test/browser/useReducer.test.js b/node_modules/preact/hooks/test/browser/useReducer.test.js
new file mode 100644
index 0000000..4b9d393
--- /dev/null
+++ b/node_modules/preact/hooks/test/browser/useReducer.test.js
@@ -0,0 +1,214 @@
+import { setupRerender, act } from 'preact/test-utils';
+import { createElement, render, createContext } from 'preact';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+import { useReducer, useEffect, useContext } from 'preact/hooks';
+
+/** @jsx createElement */
+
+describe('useReducer', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	/** @type {() => void} */
+	let rerender;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+		rerender = setupRerender();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	it('rerenders when dispatching an action', () => {
+		const states = [];
+		let _dispatch;
+
+		const initState = { count: 0 };
+
+		function reducer(state, action) {
+			switch (action.type) {
+				case 'increment':
+					return { count: state.count + action.by };
+			}
+		}
+
+		function Comp() {
+			const [state, dispatch] = useReducer(reducer, initState);
+			_dispatch = dispatch;
+			states.push(state);
+			return null;
+		}
+
+		render(<Comp />, scratch);
+
+		_dispatch({ type: 'increment', by: 10 });
+		rerender();
+
+		expect(states).to.deep.equal([{ count: 0 }, { count: 10 }]);
+	});
+
+	it('can be dispatched by another component', () => {
+		const initState = { count: 0 };
+
+		function reducer(state, action) {
+			switch (action.type) {
+				case 'increment':
+					return { count: state.count + action.by };
+			}
+		}
+
+		function ReducerComponent() {
+			const [state, dispatch] = useReducer(reducer, initState);
+			return (
+				<div>
+					<p>Count: {state.count}</p>
+					<DispatchComponent dispatch={dispatch} />
+				</div>
+			);
+		}
+
+		function DispatchComponent(props) {
+			return (
+				<button onClick={() => props.dispatch({ type: 'increment', by: 10 })}>
+					Increment
+				</button>
+			);
+		}
+
+		render(<ReducerComponent />, scratch);
+		expect(scratch.textContent).to.include('Count: 0');
+
+		const button = scratch.querySelector('button');
+		button.click();
+
+		rerender();
+		expect(scratch.textContent).to.include('Count: 10');
+	});
+
+	it('can lazily initialize its state with an action', () => {
+		const states = [];
+		let _dispatch;
+
+		function init(initialCount) {
+			return { count: initialCount };
+		}
+
+		function reducer(state, action) {
+			switch (action.type) {
+				case 'increment':
+					return { count: state.count + action.by };
+			}
+		}
+
+		function Comp({ initCount }) {
+			const [state, dispatch] = useReducer(reducer, initCount, init);
+			_dispatch = dispatch;
+			states.push(state);
+			return null;
+		}
+
+		render(<Comp initCount={10} />, scratch);
+
+		_dispatch({ type: 'increment', by: 10 });
+		rerender();
+
+		expect(states).to.deep.equal([{ count: 10 }, { count: 20 }]);
+	});
+
+	it('provides a stable reference for dispatch', () => {
+		const dispatches = [];
+		let _dispatch;
+
+		const initState = { count: 0 };
+
+		function reducer(state, action) {
+			switch (action.type) {
+				case 'increment':
+					return { count: state.count + action.by };
+			}
+		}
+
+		function Comp() {
+			const [, dispatch] = useReducer(reducer, initState);
+			_dispatch = dispatch;
+			dispatches.push(dispatch);
+			return null;
+		}
+
+		render(<Comp />, scratch);
+
+		_dispatch({ type: 'increment', by: 10 });
+		rerender();
+
+		expect(dispatches[0]).to.equal(dispatches[1]);
+	});
+
+	it('uses latest reducer', () => {
+		const states = [];
+		let _dispatch;
+
+		const initState = { count: 0 };
+
+		function Comp({ increment }) {
+			const [state, dispatch] = useReducer(function(state, action) {
+				switch (action.type) {
+					case 'increment':
+						return { count: state.count + increment };
+				}
+			}, initState);
+			_dispatch = dispatch;
+			states.push(state);
+			return null;
+		}
+
+		render(<Comp increment={10} />, scratch);
+
+		render(<Comp increment={20} />, scratch);
+
+		_dispatch({ type: 'increment' });
+		rerender();
+
+		expect(states).to.deep.equal([{ count: 0 }, { count: 0 }, { count: 20 }]);
+	});
+
+	// Relates to #2549
+	it('should not mutate the hookState', () => {
+		const reducer = (state, action) => ({
+			...state,
+			innerMessage: action.payload
+		});
+
+		const ContextMessage = ({ context }) => {
+			const [{ innerMessage }, dispatch] = useContext(context);
+			useEffect(() => {
+				dispatch({ payload: 'message' });
+			}, []);
+
+			return innerMessage && <p>{innerMessage}</p>;
+		};
+
+		const Wrapper = ({ children }) => <div>{children}</div>;
+
+		const badContextDefault = {};
+		const BadContext = createContext({});
+
+		const Abstraction = ({ reducer, defaultState, children }) => (
+			<BadContext.Provider value={useReducer(reducer, defaultState)}>
+				<Wrapper>{children}</Wrapper>
+			</BadContext.Provider>
+		);
+
+		const App = () => (
+			<Abstraction reducer={reducer} defaultState={badContextDefault}>
+				<ContextMessage context={BadContext} />
+			</Abstraction>
+		);
+
+		act(() => {
+			render(<App />, scratch);
+		});
+		expect(scratch.innerHTML).to.equal('<div><p>message</p></div>');
+	});
+});
diff --git a/node_modules/preact/hooks/test/browser/useRef.test.js b/node_modules/preact/hooks/test/browser/useRef.test.js
new file mode 100644
index 0000000..7d7a657
--- /dev/null
+++ b/node_modules/preact/hooks/test/browser/useRef.test.js
@@ -0,0 +1,50 @@
+import { createElement, render } from 'preact';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+import { useRef } from 'preact/hooks';
+
+/** @jsx createElement */
+
+describe('useRef', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	it('provides a stable reference', () => {
+		const values = [];
+
+		function Comp() {
+			const ref = useRef(1);
+			values.push(ref.current);
+			ref.current = 2;
+			return null;
+		}
+
+		render(<Comp />, scratch);
+		render(<Comp />, scratch);
+
+		expect(values).to.deep.equal([1, 2]);
+	});
+
+	it('defaults to undefined', () => {
+		const values = [];
+
+		function Comp() {
+			const ref = useRef();
+			values.push(ref.current);
+			ref.current = 2;
+			return null;
+		}
+
+		render(<Comp />, scratch);
+		render(<Comp />, scratch);
+
+		expect(values).to.deep.equal([undefined, 2]);
+	});
+});
diff --git a/node_modules/preact/hooks/test/browser/useState.test.js b/node_modules/preact/hooks/test/browser/useState.test.js
new file mode 100644
index 0000000..e5b0a1f
--- /dev/null
+++ b/node_modules/preact/hooks/test/browser/useState.test.js
@@ -0,0 +1,191 @@
+import { setupRerender } from 'preact/test-utils';
+import { createElement, render } from 'preact';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+import { useState } from 'preact/hooks';
+
+/** @jsx createElement */
+
+describe('useState', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	/** @type {() => void} */
+	let rerender;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+		rerender = setupRerender();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+	});
+
+	it('serves the same state across render calls', () => {
+		const stateHistory = [];
+
+		function Comp() {
+			const [state] = useState({ a: 1 });
+			stateHistory.push(state);
+			return null;
+		}
+
+		render(<Comp />, scratch);
+		render(<Comp />, scratch);
+
+		expect(stateHistory).to.deep.equal([{ a: 1 }, { a: 1 }]);
+		expect(stateHistory[0]).to.equal(stateHistory[1]);
+	});
+
+	it('can initialize the state via a function', () => {
+		const initState = sinon.spy(() => 1);
+
+		function Comp() {
+			useState(initState);
+			return null;
+		}
+
+		render(<Comp />, scratch);
+		render(<Comp />, scratch);
+
+		expect(initState).to.be.calledOnce;
+	});
+
+	it('does not rerender on equal state', () => {
+		let lastState;
+		let doSetState;
+
+		const Comp = sinon.spy(() => {
+			const [state, setState] = useState(0);
+			lastState = state;
+			doSetState = setState;
+			return null;
+		});
+
+		render(<Comp />, scratch);
+		expect(lastState).to.equal(0);
+		expect(Comp).to.be.calledOnce;
+
+		doSetState(0);
+		rerender();
+		expect(lastState).to.equal(0);
+		expect(Comp).to.be.calledOnce;
+
+		doSetState(() => 0);
+		rerender();
+		expect(lastState).to.equal(0);
+		expect(Comp).to.be.calledOnce;
+	});
+
+	it('rerenders when setting the state', () => {
+		let lastState;
+		let doSetState;
+
+		const Comp = sinon.spy(() => {
+			const [state, setState] = useState(0);
+			lastState = state;
+			doSetState = setState;
+			return null;
+		});
+
+		render(<Comp />, scratch);
+		expect(lastState).to.equal(0);
+		expect(Comp).to.be.calledOnce;
+
+		doSetState(1);
+		rerender();
+		expect(lastState).to.equal(1);
+		expect(Comp).to.be.calledTwice;
+
+		// Updater function style
+		doSetState(current => current * 10);
+		rerender();
+		expect(lastState).to.equal(10);
+		expect(Comp).to.be.calledThrice;
+	});
+
+	it('can be set by another component', () => {
+		function StateContainer() {
+			const [count, setCount] = useState(0);
+			return (
+				<div>
+					<p>Count: {count}</p>
+					<Increment increment={() => setCount(c => c + 10)} />
+				</div>
+			);
+		}
+
+		function Increment(props) {
+			return <button onClick={props.increment}>Increment</button>;
+		}
+
+		render(<StateContainer />, scratch);
+		expect(scratch.textContent).to.include('Count: 0');
+
+		const button = scratch.querySelector('button');
+		button.click();
+
+		rerender();
+		expect(scratch.textContent).to.include('Count: 10');
+	});
+
+	it('should correctly initialize', () => {
+		let scopedThing = 'hi';
+		let arg;
+
+		function useSomething() {
+			const args = useState(setup);
+			function setup(thing = scopedThing) {
+				arg = thing;
+				return thing;
+			}
+			return args;
+		}
+
+		const App = () => {
+			const [state] = useSomething();
+			return <p>{state}</p>;
+		};
+
+		render(<App />, scratch);
+
+		expect(arg).to.equal('hi');
+		expect(scratch.innerHTML).to.equal('<p>hi</p>');
+	});
+
+	it('should handle queued useState', () => {
+		function Message({ message, onClose }) {
+			const [isVisible, setVisible] = useState(Boolean(message));
+			const [prevMessage, setPrevMessage] = useState(message);
+
+			if (message !== prevMessage) {
+				setPrevMessage(message);
+				setVisible(Boolean(message));
+			}
+
+			if (!isVisible) {
+				return null;
+			}
+			return <p onClick={onClose}>{message}</p>;
+		}
+
+		function App() {
+			const [message, setMessage] = useState('Click Here!!');
+			return (
+				<Message
+					onClose={() => {
+						setMessage('');
+					}}
+					message={message}
+				/>
+			);
+		}
+
+		render(<App />, scratch);
+		expect(scratch.textContent).to.equal('Click Here!!');
+		const text = scratch.querySelector('p');
+		text.click();
+		rerender();
+		expect(scratch.innerHTML).to.equal('');
+	});
+});
diff --git a/node_modules/preact/src/diff/index.js b/node_modules/preact/src/diff/index.js
index b7dde36..ff56c3d 100644
--- a/node_modules/preact/src/diff/index.js
+++ b/node_modules/preact/src/diff/index.js
@@ -381,7 +381,11 @@ function diffElementNodes(
 
 			if (newHtml || oldHtml) {
 				// Avoid re-applying the same '__html' if it did not changed between re-render
-				if (!newHtml || !oldHtml || newHtml.__html != oldHtml.__html) {
+				if (
+					!newHtml ||
+					((!oldHtml || newHtml.__html != oldHtml.__html) &&
+						newHtml.__html !== dom.innerHTML)
+				) {
 					dom.innerHTML = (newHtml && newHtml.__html) || '';
 				}
 			}
diff --git a/node_modules/preact/src/diff/props.js b/node_modules/preact/src/diff/props.js
index 36cecae..5221f84 100644
--- a/node_modules/preact/src/diff/props.js
+++ b/node_modules/preact/src/diff/props.js
@@ -34,8 +34,6 @@ export function diffProps(dom, newProps, oldProps, isSvg, hydrate) {
 }
 
 function setStyle(style, key, value) {
-	// if (!(key in style)) {  // -3b
-	// if (key < '.') {  // -1b
 	if (key[0] === '-') {
 		style.setProperty(key, value);
 	} else if (value == null) {
@@ -56,7 +54,7 @@ function setStyle(style, key, value) {
  * @param {boolean} isSvg Whether or not this DOM node is an SVG node or not
  */
 export function setProperty(dom, name, value, oldValue, isSvg) {
-	let useCapture, nameLower;
+	let useCapture, nameLower, proxy;
 
 	if (isSvg && name == 'className') name = 'class';
 
@@ -66,10 +64,10 @@ export function setProperty(dom, name, value, oldValue, isSvg) {
 
 	if (name === 'style') {
 		if (typeof value == 'string') {
-			dom.style = value;
+			dom.style.cssText = value;
 		} else {
 			if (typeof oldValue == 'string') {
-				dom.style = oldValue = '';
+				dom.style.cssText = oldValue = '';
 			}
 
 			if (oldValue) {
@@ -97,12 +95,13 @@ export function setProperty(dom, name, value, oldValue, isSvg) {
 		name = name.slice(2);
 
 		if (!dom._listeners) dom._listeners = {};
-		dom._listeners[name] = value;
+		dom._listeners[name + useCapture] = value;
 
+		proxy = useCapture ? eventProxyCapture : eventProxy;
 		if (value) {
-			if (!oldValue) dom.addEventListener(name, eventProxy, useCapture);
+			if (!oldValue) dom.addEventListener(name, proxy, useCapture);
 		} else {
-			dom.removeEventListener(name, eventProxy, useCapture);
+			dom.removeEventListener(name, proxy, useCapture);
 		}
 	} else if (
 		name !== 'list' &&
@@ -156,5 +155,9 @@ export function setProperty(dom, name, value, oldValue, isSvg) {
  * @private
  */
 function eventProxy(e) {
-	this._listeners[e.type](options.event ? options.event(e) : e);
+	this._listeners[e.type + false](options.event ? options.event(e) : e);
+}
+
+function eventProxyCapture(e) {
+	this._listeners[e.type + true](options.event ? options.event(e) : e);
 }
diff --git a/node_modules/preact/test-utils/test/shared/act.test.js b/node_modules/preact/test-utils/test/shared/act.test.js
new file mode 100644
index 0000000..7769b5b
--- /dev/null
+++ b/node_modules/preact/test-utils/test/shared/act.test.js
@@ -0,0 +1,479 @@
+import { options, createElement, render } from 'preact';
+import { useEffect, useReducer, useState } from 'preact/hooks';
+import { act } from 'preact/test-utils';
+import { setupScratch, teardown } from '../../../test/_util/helpers';
+
+/** @jsx createElement */
+
+// IE11 doesn't support `new Event()`
+function createEvent(name) {
+	if (typeof Event == 'function') return new Event(name);
+
+	const event = document.createEvent('Event');
+	event.initEvent(name, true, true);
+	return event;
+}
+
+describe('act', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	beforeEach(() => {
+		scratch = setupScratch();
+	});
+
+	afterEach(() => {
+		teardown(scratch);
+		options.debounceRendering = undefined;
+	});
+
+	it('should reset options after act finishes', () => {
+		expect(options.requestAnimationFrame).to.equal(undefined);
+		act(() => null);
+		expect(options.requestAnimationFrame).to.equal(undefined);
+	});
+
+	it('should flush pending effects', () => {
+		let spy = sinon.spy();
+		function StateContainer() {
+			useEffect(spy);
+			return <div />;
+		}
+		act(() => render(<StateContainer />, scratch));
+		expect(spy).to.be.calledOnce;
+	});
+
+	it('should flush pending and initial effects', () => {
+		const spy = sinon.spy();
+		function StateContainer() {
+			const [count, setCount] = useState(0);
+			useEffect(() => spy(), [count]);
+			return (
+				<div>
+					<p>Count: {count}</p>
+					<button onClick={() => setCount(c => c + 11)} />
+				</div>
+			);
+		}
+
+		act(() => render(<StateContainer />, scratch));
+		expect(spy).to.be.calledOnce;
+		expect(scratch.textContent).to.include('Count: 0');
+		act(() => {
+			const button = scratch.querySelector('button');
+			button.click();
+			expect(spy).to.be.calledOnce;
+			expect(scratch.textContent).to.include('Count: 0');
+		});
+		expect(spy).to.be.calledTwice;
+		expect(scratch.textContent).to.include('Count: 1');
+	});
+
+	it('should flush series of hooks', () => {
+		const spy = sinon.spy();
+		const spy2 = sinon.spy();
+		function StateContainer() {
+			const [count, setCount] = useState(0);
+			useEffect(() => {
+				spy();
+				if (count === 1) {
+					setCount(() => 2);
+				}
+			}, [count]);
+			useEffect(() => {
+				if (count === 2) {
+					spy2();
+					setCount(() => 4);
+					return () => setCount(() => 3);
+				}
+			}, [count]);
+			return (
+				<div>
+					<p>Count: {count}</p>
+					<button onClick={() => setCount(c => c + 1)} />
+				</div>
+			);
+		}
+		act(() => render(<StateContainer />, scratch));
+		expect(spy).to.be.calledOnce;
+		expect(scratch.textContent).to.include('Count: 0');
+		act(() => {
+			const button = scratch.querySelector('button');
+			button.click();
+		});
+		expect(spy.callCount).to.equal(5);
+		expect(spy2).to.be.calledOnce;
+		expect(scratch.textContent).to.include('Count: 3');
+	});
+
+	it('should drain the queue of hooks', () => {
+		const spy = sinon.spy();
+		function StateContainer() {
+			const [count, setCount] = useState(0);
+			useEffect(() => spy());
+			return (
+				<div>
+					<p>Count: {count}</p>
+					<button onClick={() => setCount(c => c + 11)} />
+				</div>
+			);
+		}
+
+		render(<StateContainer />, scratch);
+		expect(scratch.textContent).to.include('Count: 0');
+		act(() => {
+			const button = scratch.querySelector('button');
+			button.click();
+			expect(scratch.textContent).to.include('Count: 0');
+		});
+		expect(scratch.textContent).to.include('Count: 1');
+	});
+
+	it('should restore options.requestAnimationFrame', () => {
+		const spy = sinon.spy();
+
+		options.requestAnimationFrame = spy;
+		act(() => null);
+
+		expect(options.requestAnimationFrame).to.equal(spy);
+		expect(spy).to.not.be.called;
+	});
+
+	it('should restore options.debounceRendering', () => {
+		const spy = sinon.spy();
+
+		options.debounceRendering = spy;
+		act(() => null);
+
+		expect(options.debounceRendering).to.equal(spy);
+		expect(spy).to.not.be.called;
+	});
+
+	it('should restore options.debounceRendering when it was undefined before', () => {
+		act(() => null);
+		expect(options.debounceRendering).to.equal(undefined);
+	});
+
+	it('should flush state updates if there are pending state updates before `act` call', () => {
+		function CounterButton() {
+			const [count, setCount] = useState(0);
+			const increment = () => setCount(count => count + 1);
+			return <button onClick={increment}>{count}</button>;
+		}
+
+		render(<CounterButton />, scratch);
+		const button = scratch.querySelector('button');
+
+		// Click button. This will schedule an update which is deferred, as is
+		// normal for Preact, since it happens outside an `act` call.
+		button.dispatchEvent(createEvent('click'));
+
+		expect(button.textContent).to.equal('0');
+
+		act(() => {
+			// Click button a second time. This will schedule a second update.
+			button.dispatchEvent(createEvent('click'));
+		});
+		// All state updates should be applied synchronously after the `act`
+		// callback has run but before `act` returns.
+		expect(button.textContent).to.equal('2');
+	});
+
+	it('should flush effects if there are pending effects before `act` call', () => {
+		function Counter() {
+			const [count, setCount] = useState(0);
+			useEffect(() => {
+				setCount(count => count + 1);
+			}, []);
+			return <div>{count}</div>;
+		}
+
+		// Render a component which schedules an effect outside of an `act`
+		// call. This will be scheduled to execute after the next paint as usual.
+		render(<Counter />, scratch);
+		expect(scratch.firstChild.textContent).to.equal('0');
+
+		// Render a component inside an `act` call, this effect should be
+		// executed synchronously before `act` returns.
+		act(() => {
+			render(<div />, scratch);
+			render(<Counter />, scratch);
+		});
+		expect(scratch.firstChild.textContent).to.equal('1');
+	});
+
+	it('returns a Promise if invoked with a sync callback', () => {
+		const result = act(() => {});
+		expect(result.then).to.be.a('function');
+		return result;
+	});
+
+	it('returns a Promise if invoked with an async callback', () => {
+		const result = act(async () => {});
+		expect(result.then).to.be.a('function');
+		return result;
+	});
+
+	it('should await "thenable" result of callback before flushing', async () => {
+		const events = [];
+
+		function TestComponent() {
+			useEffect(() => {
+				events.push('flushed effect');
+			}, []);
+			events.push('scheduled effect');
+			return <div>Test</div>;
+		}
+
+		const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
+
+		events.push('began test');
+		const acted = act(async () => {
+			events.push('began act callback');
+			await delay(1);
+			render(<TestComponent />, scratch);
+			events.push('end act callback');
+		});
+		events.push('act returned');
+		await acted;
+		events.push('act result resolved');
+
+		expect(events).to.deep.equal([
+			'began test',
+			'began act callback',
+			'act returned',
+			'scheduled effect',
+			'end act callback',
+			'flushed effect',
+			'act result resolved'
+		]);
+	});
+
+	context('when `act` calls are nested', () => {
+		it('should invoke nested sync callback and return a Promise', () => {
+			let innerResult;
+			const spy = sinon.stub();
+
+			act(() => {
+				innerResult = act(spy);
+			});
+
+			expect(spy).to.be.calledOnce;
+			expect(innerResult.then).to.be.a('function');
+		});
+
+		it('should invoke nested async callback and return a Promise', async () => {
+			const events = [];
+
+			await act(async () => {
+				events.push('began outer act callback');
+				await act(async () => {
+					events.push('began inner act callback');
+					await Promise.resolve();
+					events.push('end inner act callback');
+				});
+				events.push('end outer act callback');
+			});
+			events.push('act finished');
+
+			expect(events).to.deep.equal([
+				'began outer act callback',
+				'began inner act callback',
+				'end inner act callback',
+				'end outer act callback',
+				'act finished'
+			]);
+		});
+
+		it('should only flush effects when outer `act` call returns', () => {
+			let counter = 0;
+
+			function Widget() {
+				useEffect(() => {
+					++counter;
+				});
+				const [, forceUpdate] = useReducer(x => x + 1, 0);
+				return <button onClick={forceUpdate}>test</button>;
+			}
+
+			act(() => {
+				render(<Widget />, scratch);
+				const button = scratch.querySelector('button');
+				expect(counter).to.equal(0);
+
+				act(() => {
+					button.dispatchEvent(createEvent('click'));
+				});
+
+				// Effect triggered by inner `act` call should not have been
+				// flushed yet.
+				expect(counter).to.equal(0);
+			});
+
+			// Effects triggered by inner `act` call should now have been
+			// flushed.
+			expect(counter).to.equal(2);
+		});
+
+		it('should only flush updates when outer `act` call returns', () => {
+			function Button() {
+				const [count, setCount] = useState(0);
+				const increment = () => setCount(count => count + 1);
+				return <button onClick={increment}>{count}</button>;
+			}
+
+			render(<Button />, scratch);
+			const button = scratch.querySelector('button');
+			expect(button.textContent).to.equal('0');
+
+			act(() => {
+				act(() => {
+					button.dispatchEvent(createEvent('click'));
+				});
+
+				// Update triggered by inner `act` call should not have been
+				// flushed yet.
+				expect(button.textContent).to.equal('0');
+			});
+
+			// Updates from outer and inner `act` calls should now have been
+			// flushed.
+			expect(button.textContent).to.equal('1');
+		});
+	});
+
+	describe('when `act` callback throws an exception', () => {
+		function BrokenWidget() {
+			throw new Error('BrokenWidget is broken');
+		}
+
+		let effectCount;
+
+		function WorkingWidget() {
+			const [count, setCount] = useState(0);
+
+			useEffect(() => {
+				++effectCount;
+			}, []);
+
+			if (count === 0) {
+				setCount(1);
+			}
+
+			return <div>{count}</div>;
+		}
+
+		beforeEach(() => {
+			effectCount = 0;
+		});
+
+		const renderBroken = () => {
+			act(() => {
+				render(<BrokenWidget />, scratch);
+			});
+		};
+
+		const renderWorking = () => {
+			act(() => {
+				render(<WorkingWidget />, scratch);
+			});
+		};
+
+		const tryRenderBroken = () => {
+			try {
+				renderBroken();
+			} catch (e) {}
+		};
+
+		describe('synchronously', () => {
+			it('should rethrow the exception', () => {
+				expect(renderBroken).to.throw('BrokenWidget is broken');
+			});
+
+			it('should not affect state updates in future renders', () => {
+				tryRenderBroken();
+				renderWorking();
+				expect(scratch.textContent).to.equal('1');
+			});
+
+			it('should not affect effects in future renders', () => {
+				tryRenderBroken();
+				renderWorking();
+				expect(effectCount).to.equal(1);
+			});
+		});
+
+		describe('asynchronously', () => {
+			const renderBrokenAsync = async () => {
+				await act(async () => {
+					render(<BrokenWidget />, scratch);
+				});
+			};
+
+			it('should rethrow the exception', async () => {
+				let err;
+				try {
+					await renderBrokenAsync();
+				} catch (e) {
+					err = e;
+				}
+				expect(err.message).to.equal('BrokenWidget is broken');
+			});
+
+			it('should not affect state updates in future renders', async () => {
+				try {
+					await renderBrokenAsync();
+				} catch (e) {}
+
+				renderWorking();
+				expect(scratch.textContent).to.equal('1');
+			});
+
+			it('should not affect effects in future renders', async () => {
+				try {
+					await renderBrokenAsync();
+				} catch (e) {}
+
+				renderWorking();
+				expect(effectCount).to.equal(1);
+			});
+		});
+
+		describe('in an effect', () => {
+			function BrokenEffect() {
+				useEffect(() => {
+					throw new Error('BrokenEffect effect');
+				}, []);
+				return null;
+			}
+
+			const renderBrokenEffect = () => {
+				act(() => {
+					render(<BrokenEffect />, scratch);
+				});
+			};
+
+			it('should rethrow the exception', () => {
+				expect(renderBrokenEffect).to.throw('BrokenEffect effect');
+			});
+
+			it('should not affect state updates in future renders', () => {
+				try {
+					renderBrokenEffect();
+				} catch (e) {}
+
+				renderWorking();
+				expect(scratch.textContent).to.equal('1');
+			});
+
+			it('should not affect effects in future renders', () => {
+				try {
+					renderBrokenEffect();
+				} catch (e) {}
+
+				renderWorking();
+				expect(effectCount).to.equal(1);
+			});
+		});
+	});
+});
diff --git a/node_modules/preact/test-utils/test/shared/rerender.test.js b/node_modules/preact/test-utils/test/shared/rerender.test.js
new file mode 100644
index 0000000..a2e4335
--- /dev/null
+++ b/node_modules/preact/test-utils/test/shared/rerender.test.js
@@ -0,0 +1,59 @@
+import { options, createElement, render, Component } from 'preact';
+import { teardown, setupRerender } from 'preact/test-utils';
+
+/** @jsx createElement */
+
+describe('setupRerender & teardown', () => {
+	/** @type {HTMLDivElement} */
+	let scratch;
+
+	beforeEach(() => {
+		scratch = document.createElement('div');
+	});
+
+	it('should restore previous debounce', () => {
+		let spy = (options.debounceRendering = sinon.spy());
+
+		setupRerender();
+		teardown();
+
+		expect(options.debounceRendering).to.equal(spy);
+	});
+
+	it('teardown should flush the queue', () => {
+		/** @type {() => void} */
+		let increment;
+		class Counter extends Component {
+			constructor(props) {
+				super(props);
+
+				this.state = { count: 0 };
+				increment = () => this.setState({ count: this.state.count + 1 });
+			}
+
+			render() {
+				return <div>{this.state.count}</div>;
+			}
+		}
+
+		sinon.spy(Counter.prototype, 'render');
+
+		// Setup rerender
+		setupRerender();
+
+		// Initial render
+		render(<Counter />, scratch);
+		expect(Counter.prototype.render).to.have.been.calledOnce;
+		expect(scratch.innerHTML).to.equal('<div>0</div>');
+
+		// queue rerender
+		increment();
+		expect(Counter.prototype.render).to.have.been.calledOnce;
+		expect(scratch.innerHTML).to.equal('<div>0</div>');
+
+		// Pretend test forgot to call rerender. Teardown should do that
+		teardown();
+		expect(Counter.prototype.render).to.have.been.calledTwice;
+		expect(scratch.innerHTML).to.equal('<div>1</div>');
+	});
+});
